// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ad_rscl/idl/global_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "ad_mw/proto/runtime_conf.pb.h"
#include "ad_rscl/idl/hetero_channel_config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
namespace senseAD {
namespace rscl {
namespace idl {
class BridgeConfig;
class BridgeConfigDefaultTypeInternal;
extern BridgeConfigDefaultTypeInternal _BridgeConfig_default_instance_;
class CommonBridgeClientConfig;
class CommonBridgeClientConfigDefaultTypeInternal;
extern CommonBridgeClientConfigDefaultTypeInternal _CommonBridgeClientConfig_default_instance_;
class CommonBridgeConfig;
class CommonBridgeConfigDefaultTypeInternal;
extern CommonBridgeConfigDefaultTypeInternal _CommonBridgeConfig_default_instance_;
class CommonBridgeServerConfig;
class CommonBridgeServerConfigDefaultTypeInternal;
extern CommonBridgeServerConfigDefaultTypeInternal _CommonBridgeServerConfig_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ConditionDetail;
class ConditionDetailDefaultTypeInternal;
extern ConditionDetailDefaultTypeInternal _ConditionDetail_default_instance_;
class CrossSystemConfig;
class CrossSystemConfigDefaultTypeInternal;
extern CrossSystemConfigDefaultTypeInternal _CrossSystemConfig_default_instance_;
class CrossSystemEndpoint;
class CrossSystemEndpointDefaultTypeInternal;
extern CrossSystemEndpointDefaultTypeInternal _CrossSystemEndpoint_default_instance_;
class CrossSystemEndpointConfig;
class CrossSystemEndpointConfigDefaultTypeInternal;
extern CrossSystemEndpointConfigDefaultTypeInternal _CrossSystemEndpointConfig_default_instance_;
class CrossSystemStatReportConfig;
class CrossSystemStatReportConfigDefaultTypeInternal;
extern CrossSystemStatReportConfigDefaultTypeInternal _CrossSystemStatReportConfig_default_instance_;
class EnvGroup;
class EnvGroupDefaultTypeInternal;
extern EnvGroupDefaultTypeInternal _EnvGroup_default_instance_;
class EnvGroup_EnvEntry_DoNotUse;
class EnvGroup_EnvEntry_DoNotUseDefaultTypeInternal;
extern EnvGroup_EnvEntry_DoNotUseDefaultTypeInternal _EnvGroup_EnvEntry_DoNotUse_default_instance_;
class Extend;
class ExtendDefaultTypeInternal;
extern ExtendDefaultTypeInternal _Extend_default_instance_;
class GlobalConfig;
class GlobalConfigDefaultTypeInternal;
extern GlobalConfigDefaultTypeInternal _GlobalConfig_default_instance_;
class HeteroChannelConfig;
class HeteroChannelConfigDefaultTypeInternal;
extern HeteroChannelConfigDefaultTypeInternal _HeteroChannelConfig_default_instance_;
class InetBasedService;
class InetBasedServiceDefaultTypeInternal;
extern InetBasedServiceDefaultTypeInternal _InetBasedService_default_instance_;
class NodeConfig;
class NodeConfigDefaultTypeInternal;
extern NodeConfigDefaultTypeInternal _NodeConfig_default_instance_;
class RuntimeConfig;
class RuntimeConfigDefaultTypeInternal;
extern RuntimeConfigDefaultTypeInternal _RuntimeConfig_default_instance_;
class TopicConfig;
class TopicConfigDefaultTypeInternal;
extern TopicConfigDefaultTypeInternal _TopicConfig_default_instance_;
class TopicHeteroChannelConfig;
class TopicHeteroChannelConfigDefaultTypeInternal;
extern TopicHeteroChannelConfigDefaultTypeInternal _TopicHeteroChannelConfig_default_instance_;
class TopicHeteroChannelConfigs;
class TopicHeteroChannelConfigsDefaultTypeInternal;
extern TopicHeteroChannelConfigsDefaultTypeInternal _TopicHeteroChannelConfigs_default_instance_;
}  // namespace idl
}  // namespace rscl
}  // namespace senseAD
PROTOBUF_NAMESPACE_OPEN
template<> ::senseAD::rscl::idl::BridgeConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::BridgeConfig>(Arena*);
template<> ::senseAD::rscl::idl::CommonBridgeClientConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CommonBridgeClientConfig>(Arena*);
template<> ::senseAD::rscl::idl::CommonBridgeConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CommonBridgeConfig>(Arena*);
template<> ::senseAD::rscl::idl::CommonBridgeServerConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CommonBridgeServerConfig>(Arena*);
template<> ::senseAD::rscl::idl::Condition* Arena::CreateMaybeMessage<::senseAD::rscl::idl::Condition>(Arena*);
template<> ::senseAD::rscl::idl::ConditionDetail* Arena::CreateMaybeMessage<::senseAD::rscl::idl::ConditionDetail>(Arena*);
template<> ::senseAD::rscl::idl::CrossSystemConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemConfig>(Arena*);
template<> ::senseAD::rscl::idl::CrossSystemEndpoint* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemEndpoint>(Arena*);
template<> ::senseAD::rscl::idl::CrossSystemEndpointConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemEndpointConfig>(Arena*);
template<> ::senseAD::rscl::idl::CrossSystemStatReportConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemStatReportConfig>(Arena*);
template<> ::senseAD::rscl::idl::EnvGroup* Arena::CreateMaybeMessage<::senseAD::rscl::idl::EnvGroup>(Arena*);
template<> ::senseAD::rscl::idl::EnvGroup_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::senseAD::rscl::idl::EnvGroup_EnvEntry_DoNotUse>(Arena*);
template<> ::senseAD::rscl::idl::Extend* Arena::CreateMaybeMessage<::senseAD::rscl::idl::Extend>(Arena*);
template<> ::senseAD::rscl::idl::GlobalConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::GlobalConfig>(Arena*);
template<> ::senseAD::rscl::idl::HeteroChannelConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::HeteroChannelConfig>(Arena*);
template<> ::senseAD::rscl::idl::InetBasedService* Arena::CreateMaybeMessage<::senseAD::rscl::idl::InetBasedService>(Arena*);
template<> ::senseAD::rscl::idl::NodeConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::NodeConfig>(Arena*);
template<> ::senseAD::rscl::idl::RuntimeConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::RuntimeConfig>(Arena*);
template<> ::senseAD::rscl::idl::TopicConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::TopicConfig>(Arena*);
template<> ::senseAD::rscl::idl::TopicHeteroChannelConfig* Arena::CreateMaybeMessage<::senseAD::rscl::idl::TopicHeteroChannelConfig>(Arena*);
template<> ::senseAD::rscl::idl::TopicHeteroChannelConfigs* Arena::CreateMaybeMessage<::senseAD::rscl::idl::TopicHeteroChannelConfigs>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace senseAD {
namespace rscl {
namespace idl {

enum TopicHeteroChannelConfig_EnabledSide : int {
  TopicHeteroChannelConfig_EnabledSide_BOTH = 0,
  TopicHeteroChannelConfig_EnabledSide_PUBLISHER_ONLY = 1,
  TopicHeteroChannelConfig_EnabledSide_SUBSCRIBER_ONLY = 2
};
bool TopicHeteroChannelConfig_EnabledSide_IsValid(int value);
constexpr TopicHeteroChannelConfig_EnabledSide TopicHeteroChannelConfig_EnabledSide_EnabledSide_MIN = TopicHeteroChannelConfig_EnabledSide_BOTH;
constexpr TopicHeteroChannelConfig_EnabledSide TopicHeteroChannelConfig_EnabledSide_EnabledSide_MAX = TopicHeteroChannelConfig_EnabledSide_SUBSCRIBER_ONLY;
constexpr int TopicHeteroChannelConfig_EnabledSide_EnabledSide_ARRAYSIZE = TopicHeteroChannelConfig_EnabledSide_EnabledSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TopicHeteroChannelConfig_EnabledSide_descriptor();
template<typename T>
inline const std::string& TopicHeteroChannelConfig_EnabledSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TopicHeteroChannelConfig_EnabledSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TopicHeteroChannelConfig_EnabledSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TopicHeteroChannelConfig_EnabledSide_descriptor(), enum_t_value);
}
inline bool TopicHeteroChannelConfig_EnabledSide_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TopicHeteroChannelConfig_EnabledSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TopicHeteroChannelConfig_EnabledSide>(
    TopicHeteroChannelConfig_EnabledSide_descriptor(), name, value);
}
enum CrossSystemMode : int {
  STATIC_PEER = 0,
  DYNAMIC_PEER = 1
};
bool CrossSystemMode_IsValid(int value);
constexpr CrossSystemMode CrossSystemMode_MIN = STATIC_PEER;
constexpr CrossSystemMode CrossSystemMode_MAX = DYNAMIC_PEER;
constexpr int CrossSystemMode_ARRAYSIZE = CrossSystemMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CrossSystemMode_descriptor();
template<typename T>
inline const std::string& CrossSystemMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrossSystemMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrossSystemMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CrossSystemMode_descriptor(), enum_t_value);
}
inline bool CrossSystemMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrossSystemMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CrossSystemMode>(
    CrossSystemMode_descriptor(), name, value);
}
enum CrossSystemOutgoingPrefixMode : int {
  COMMON_TOPIC_ONLY = 0,
  ALL = 1
};
bool CrossSystemOutgoingPrefixMode_IsValid(int value);
constexpr CrossSystemOutgoingPrefixMode CrossSystemOutgoingPrefixMode_MIN = COMMON_TOPIC_ONLY;
constexpr CrossSystemOutgoingPrefixMode CrossSystemOutgoingPrefixMode_MAX = ALL;
constexpr int CrossSystemOutgoingPrefixMode_ARRAYSIZE = CrossSystemOutgoingPrefixMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CrossSystemOutgoingPrefixMode_descriptor();
template<typename T>
inline const std::string& CrossSystemOutgoingPrefixMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrossSystemOutgoingPrefixMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrossSystemOutgoingPrefixMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CrossSystemOutgoingPrefixMode_descriptor(), enum_t_value);
}
inline bool CrossSystemOutgoingPrefixMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrossSystemOutgoingPrefixMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CrossSystemOutgoingPrefixMode>(
    CrossSystemOutgoingPrefixMode_descriptor(), name, value);
}
// ===================================================================

class ConditionDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.ConditionDetail) */ {
 public:
  inline ConditionDetail() : ConditionDetail(nullptr) {}
  virtual ~ConditionDetail();

  ConditionDetail(const ConditionDetail& from);
  ConditionDetail(ConditionDetail&& from) noexcept
    : ConditionDetail() {
    *this = ::std::move(from);
  }

  inline ConditionDetail& operator=(const ConditionDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionDetail& operator=(ConditionDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionDetail& default_instance();

  static inline const ConditionDetail* internal_default_instance() {
    return reinterpret_cast<const ConditionDetail*>(
               &_ConditionDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConditionDetail& a, ConditionDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionDetail* New() const final {
    return CreateMaybeMessage<ConditionDetail>(nullptr);
  }

  ConditionDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionDetail& from);
  void MergeFrom(const ConditionDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.ConditionDetail";
  }
  protected:
  explicit ConditionDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 1,
    kEnvVarFieldNumber = 2,
  };
  // repeated string mac_address = 1;
  int mac_address_size() const;
  private:
  int _internal_mac_address_size() const;
  public:
  void clear_mac_address();
  const std::string& mac_address(int index) const;
  std::string* mutable_mac_address(int index);
  void set_mac_address(int index, const std::string& value);
  void set_mac_address(int index, std::string&& value);
  void set_mac_address(int index, const char* value);
  void set_mac_address(int index, const char* value, size_t size);
  std::string* add_mac_address();
  void add_mac_address(const std::string& value);
  void add_mac_address(std::string&& value);
  void add_mac_address(const char* value);
  void add_mac_address(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mac_address() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mac_address();
  private:
  const std::string& _internal_mac_address(int index) const;
  std::string* _internal_add_mac_address();
  public:

  // repeated string env_var = 2;
  int env_var_size() const;
  private:
  int _internal_env_var_size() const;
  public:
  void clear_env_var();
  const std::string& env_var(int index) const;
  std::string* mutable_env_var(int index);
  void set_env_var(int index, const std::string& value);
  void set_env_var(int index, std::string&& value);
  void set_env_var(int index, const char* value);
  void set_env_var(int index, const char* value, size_t size);
  std::string* add_env_var();
  void add_env_var(const std::string& value);
  void add_env_var(std::string&& value);
  void add_env_var(const char* value);
  void add_env_var(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& env_var() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_env_var();
  private:
  const std::string& _internal_env_var(int index) const;
  std::string* _internal_add_env_var();
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.ConditionDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mac_address_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> env_var_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class Condition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  virtual ~Condition();

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition& default_instance();

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludedFieldNumber = 1,
    kExcludedFieldNumber = 2,
    kOrFieldNumber = 3,
    kAndFieldNumber = 4,
  };
  // repeated string included = 1;
  int included_size() const;
  private:
  int _internal_included_size() const;
  public:
  void clear_included();
  const std::string& included(int index) const;
  std::string* mutable_included(int index);
  void set_included(int index, const std::string& value);
  void set_included(int index, std::string&& value);
  void set_included(int index, const char* value);
  void set_included(int index, const char* value, size_t size);
  std::string* add_included();
  void add_included(const std::string& value);
  void add_included(std::string&& value);
  void add_included(const char* value);
  void add_included(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& included() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_included();
  private:
  const std::string& _internal_included(int index) const;
  std::string* _internal_add_included();
  public:

  // repeated string excluded = 2;
  int excluded_size() const;
  private:
  int _internal_excluded_size() const;
  public:
  void clear_excluded();
  const std::string& excluded(int index) const;
  std::string* mutable_excluded(int index);
  void set_excluded(int index, const std::string& value);
  void set_excluded(int index, std::string&& value);
  void set_excluded(int index, const char* value);
  void set_excluded(int index, const char* value, size_t size);
  std::string* add_excluded();
  void add_excluded(const std::string& value);
  void add_excluded(std::string&& value);
  void add_excluded(const char* value);
  void add_excluded(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& excluded() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_excluded();
  private:
  const std::string& _internal_excluded(int index) const;
  std::string* _internal_add_excluded();
  public:

  // optional .senseAD.rscl.idl.ConditionDetail or = 3;
  bool has_or_() const;
  private:
  bool _internal_has_or_() const;
  public:
  void clear_or_();
  const ::senseAD::rscl::idl::ConditionDetail& or_() const;
  ::senseAD::rscl::idl::ConditionDetail* release_or_();
  ::senseAD::rscl::idl::ConditionDetail* mutable_or_();
  void set_allocated_or_(::senseAD::rscl::idl::ConditionDetail* or_);
  private:
  const ::senseAD::rscl::idl::ConditionDetail& _internal_or_() const;
  ::senseAD::rscl::idl::ConditionDetail* _internal_mutable_or_();
  public:
  void unsafe_arena_set_allocated_or_(
      ::senseAD::rscl::idl::ConditionDetail* or_);
  ::senseAD::rscl::idl::ConditionDetail* unsafe_arena_release_or_();

  // optional .senseAD.rscl.idl.ConditionDetail and = 4;
  bool has_and_() const;
  private:
  bool _internal_has_and_() const;
  public:
  void clear_and_();
  const ::senseAD::rscl::idl::ConditionDetail& and_() const;
  ::senseAD::rscl::idl::ConditionDetail* release_and_();
  ::senseAD::rscl::idl::ConditionDetail* mutable_and_();
  void set_allocated_and_(::senseAD::rscl::idl::ConditionDetail* and_);
  private:
  const ::senseAD::rscl::idl::ConditionDetail& _internal_and_() const;
  ::senseAD::rscl::idl::ConditionDetail* _internal_mutable_and_();
  public:
  void unsafe_arena_set_allocated_and_(
      ::senseAD::rscl::idl::ConditionDetail* and_);
  ::senseAD::rscl::idl::ConditionDetail* unsafe_arena_release_and_();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.Condition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> included_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> excluded_;
  ::senseAD::rscl::idl::ConditionDetail* or__;
  ::senseAD::rscl::idl::ConditionDetail* and__;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class Extend PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.Extend) */ {
 public:
  inline Extend() : Extend(nullptr) {}
  virtual ~Extend();

  Extend(const Extend& from);
  Extend(Extend&& from) noexcept
    : Extend() {
    *this = ::std::move(from);
  }

  inline Extend& operator=(const Extend& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extend& operator=(Extend&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Extend& default_instance();

  static inline const Extend* internal_default_instance() {
    return reinterpret_cast<const Extend*>(
               &_Extend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Extend& a, Extend& b) {
    a.Swap(&b);
  }
  inline void Swap(Extend* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Extend* New() const final {
    return CreateMaybeMessage<Extend>(nullptr);
  }

  Extend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Extend>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Extend& from);
  void MergeFrom(const Extend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.Extend";
  }
  protected:
  explicit Extend(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPbFileFieldNumber = 2,
    kConditionFieldNumber = 1,
  };
  // required string pb_file = 2;
  bool has_pb_file() const;
  private:
  bool _internal_has_pb_file() const;
  public:
  void clear_pb_file();
  const std::string& pb_file() const;
  void set_pb_file(const std::string& value);
  void set_pb_file(std::string&& value);
  void set_pb_file(const char* value);
  void set_pb_file(const char* value, size_t size);
  std::string* mutable_pb_file();
  std::string* release_pb_file();
  void set_allocated_pb_file(std::string* pb_file);
  private:
  const std::string& _internal_pb_file() const;
  void _internal_set_pb_file(const std::string& value);
  std::string* _internal_mutable_pb_file();
  public:

  // optional .senseAD.rscl.idl.Condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::senseAD::rscl::idl::Condition& condition() const;
  ::senseAD::rscl::idl::Condition* release_condition();
  ::senseAD::rscl::idl::Condition* mutable_condition();
  void set_allocated_condition(::senseAD::rscl::idl::Condition* condition);
  private:
  const ::senseAD::rscl::idl::Condition& _internal_condition() const;
  ::senseAD::rscl::idl::Condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::senseAD::rscl::idl::Condition* condition);
  ::senseAD::rscl::idl::Condition* unsafe_arena_release_condition();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.Extend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pb_file_;
  ::senseAD::rscl::idl::Condition* condition_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class EnvGroup_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<EnvGroup_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<EnvGroup_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  EnvGroup_EnvEntry_DoNotUse();
  explicit EnvGroup_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const EnvGroup_EnvEntry_DoNotUse& other);
  static const EnvGroup_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EnvGroup_EnvEntry_DoNotUse*>(&_EnvGroup_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "senseAD.rscl.idl.EnvGroup.EnvEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "senseAD.rscl.idl.EnvGroup.EnvEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class EnvGroup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.EnvGroup) */ {
 public:
  inline EnvGroup() : EnvGroup(nullptr) {}
  virtual ~EnvGroup();

  EnvGroup(const EnvGroup& from);
  EnvGroup(EnvGroup&& from) noexcept
    : EnvGroup() {
    *this = ::std::move(from);
  }

  inline EnvGroup& operator=(const EnvGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvGroup& operator=(EnvGroup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnvGroup& default_instance();

  static inline const EnvGroup* internal_default_instance() {
    return reinterpret_cast<const EnvGroup*>(
               &_EnvGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EnvGroup& a, EnvGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvGroup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnvGroup* New() const final {
    return CreateMaybeMessage<EnvGroup>(nullptr);
  }

  EnvGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnvGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnvGroup& from);
  void MergeFrom(const EnvGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.EnvGroup";
  }
  protected:
  explicit EnvGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 2,
    kConditionFieldNumber = 1,
  };
  // map<string, string> env = 2;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // optional .senseAD.rscl.idl.Condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::senseAD::rscl::idl::Condition& condition() const;
  ::senseAD::rscl::idl::Condition* release_condition();
  ::senseAD::rscl::idl::Condition* mutable_condition();
  void set_allocated_condition(::senseAD::rscl::idl::Condition* condition);
  private:
  const ::senseAD::rscl::idl::Condition& _internal_condition() const;
  ::senseAD::rscl::idl::Condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::senseAD::rscl::idl::Condition* condition);
  ::senseAD::rscl::idl::Condition* unsafe_arena_release_condition();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.EnvGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      EnvGroup_EnvEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
  ::senseAD::rscl::idl::Condition* condition_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class HeteroChannelConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.HeteroChannelConfig) */ {
 public:
  inline HeteroChannelConfig() : HeteroChannelConfig(nullptr) {}
  virtual ~HeteroChannelConfig();

  HeteroChannelConfig(const HeteroChannelConfig& from);
  HeteroChannelConfig(HeteroChannelConfig&& from) noexcept
    : HeteroChannelConfig() {
    *this = ::std::move(from);
  }

  inline HeteroChannelConfig& operator=(const HeteroChannelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeteroChannelConfig& operator=(HeteroChannelConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeteroChannelConfig& default_instance();

  static inline const HeteroChannelConfig* internal_default_instance() {
    return reinterpret_cast<const HeteroChannelConfig*>(
               &_HeteroChannelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeteroChannelConfig& a, HeteroChannelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HeteroChannelConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeteroChannelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeteroChannelConfig* New() const final {
    return CreateMaybeMessage<HeteroChannelConfig>(nullptr);
  }

  HeteroChannelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeteroChannelConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeteroChannelConfig& from);
  void MergeFrom(const HeteroChannelConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeteroChannelConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.HeteroChannelConfig";
  }
  protected:
  explicit HeteroChannelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 3,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .google.protobuf.Any config = 3;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  PROTOBUF_NAMESPACE_ID::Any* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Any >*
      mutable_config();
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_config(int index) const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_add_config();
  public:
  const PROTOBUF_NAMESPACE_ID::Any& config(int index) const;
  PROTOBUF_NAMESPACE_ID::Any* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Any >&
      config() const;

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .senseAD.rscl.idl.SupportedHeteroChannel type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::senseAD::rscl::idl::SupportedHeteroChannel type() const;
  void set_type(::senseAD::rscl::idl::SupportedHeteroChannel value);
  private:
  ::senseAD::rscl::idl::SupportedHeteroChannel _internal_type() const;
  void _internal_set_type(::senseAD::rscl::idl::SupportedHeteroChannel value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.HeteroChannelConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Any > config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TopicHeteroChannelConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.TopicHeteroChannelConfig) */ {
 public:
  inline TopicHeteroChannelConfig() : TopicHeteroChannelConfig(nullptr) {}
  virtual ~TopicHeteroChannelConfig();

  TopicHeteroChannelConfig(const TopicHeteroChannelConfig& from);
  TopicHeteroChannelConfig(TopicHeteroChannelConfig&& from) noexcept
    : TopicHeteroChannelConfig() {
    *this = ::std::move(from);
  }

  inline TopicHeteroChannelConfig& operator=(const TopicHeteroChannelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicHeteroChannelConfig& operator=(TopicHeteroChannelConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopicHeteroChannelConfig& default_instance();

  static inline const TopicHeteroChannelConfig* internal_default_instance() {
    return reinterpret_cast<const TopicHeteroChannelConfig*>(
               &_TopicHeteroChannelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TopicHeteroChannelConfig& a, TopicHeteroChannelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicHeteroChannelConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicHeteroChannelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopicHeteroChannelConfig* New() const final {
    return CreateMaybeMessage<TopicHeteroChannelConfig>(nullptr);
  }

  TopicHeteroChannelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopicHeteroChannelConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopicHeteroChannelConfig& from);
  void MergeFrom(const TopicHeteroChannelConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicHeteroChannelConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.TopicHeteroChannelConfig";
  }
  protected:
  explicit TopicHeteroChannelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TopicHeteroChannelConfig_EnabledSide EnabledSide;
  static constexpr EnabledSide BOTH =
    TopicHeteroChannelConfig_EnabledSide_BOTH;
  static constexpr EnabledSide PUBLISHER_ONLY =
    TopicHeteroChannelConfig_EnabledSide_PUBLISHER_ONLY;
  static constexpr EnabledSide SUBSCRIBER_ONLY =
    TopicHeteroChannelConfig_EnabledSide_SUBSCRIBER_ONLY;
  static inline bool EnabledSide_IsValid(int value) {
    return TopicHeteroChannelConfig_EnabledSide_IsValid(value);
  }
  static constexpr EnabledSide EnabledSide_MIN =
    TopicHeteroChannelConfig_EnabledSide_EnabledSide_MIN;
  static constexpr EnabledSide EnabledSide_MAX =
    TopicHeteroChannelConfig_EnabledSide_EnabledSide_MAX;
  static constexpr int EnabledSide_ARRAYSIZE =
    TopicHeteroChannelConfig_EnabledSide_EnabledSide_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnabledSide_descriptor() {
    return TopicHeteroChannelConfig_EnabledSide_descriptor();
  }
  template<typename T>
  static inline const std::string& EnabledSide_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnabledSide>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnabledSide_Name.");
    return TopicHeteroChannelConfig_EnabledSide_Name(enum_t_value);
  }
  static inline bool EnabledSide_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnabledSide* value) {
    return TopicHeteroChannelConfig_EnabledSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledHeteroFieldNumber = 2,
    kEnabledSideFieldNumber = 1,
  };
  // required string enabled_hetero = 2;
  bool has_enabled_hetero() const;
  private:
  bool _internal_has_enabled_hetero() const;
  public:
  void clear_enabled_hetero();
  const std::string& enabled_hetero() const;
  void set_enabled_hetero(const std::string& value);
  void set_enabled_hetero(std::string&& value);
  void set_enabled_hetero(const char* value);
  void set_enabled_hetero(const char* value, size_t size);
  std::string* mutable_enabled_hetero();
  std::string* release_enabled_hetero();
  void set_allocated_enabled_hetero(std::string* enabled_hetero);
  private:
  const std::string& _internal_enabled_hetero() const;
  void _internal_set_enabled_hetero(const std::string& value);
  std::string* _internal_mutable_enabled_hetero();
  public:

  // required .senseAD.rscl.idl.TopicHeteroChannelConfig.EnabledSide enabled_side = 1;
  bool has_enabled_side() const;
  private:
  bool _internal_has_enabled_side() const;
  public:
  void clear_enabled_side();
  ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide enabled_side() const;
  void set_enabled_side(::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide value);
  private:
  ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide _internal_enabled_side() const;
  void _internal_set_enabled_side(::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.TopicHeteroChannelConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enabled_hetero_;
  int enabled_side_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TopicHeteroChannelConfigs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.TopicHeteroChannelConfigs) */ {
 public:
  inline TopicHeteroChannelConfigs() : TopicHeteroChannelConfigs(nullptr) {}
  virtual ~TopicHeteroChannelConfigs();

  TopicHeteroChannelConfigs(const TopicHeteroChannelConfigs& from);
  TopicHeteroChannelConfigs(TopicHeteroChannelConfigs&& from) noexcept
    : TopicHeteroChannelConfigs() {
    *this = ::std::move(from);
  }

  inline TopicHeteroChannelConfigs& operator=(const TopicHeteroChannelConfigs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicHeteroChannelConfigs& operator=(TopicHeteroChannelConfigs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopicHeteroChannelConfigs& default_instance();

  static inline const TopicHeteroChannelConfigs* internal_default_instance() {
    return reinterpret_cast<const TopicHeteroChannelConfigs*>(
               &_TopicHeteroChannelConfigs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TopicHeteroChannelConfigs& a, TopicHeteroChannelConfigs& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicHeteroChannelConfigs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicHeteroChannelConfigs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopicHeteroChannelConfigs* New() const final {
    return CreateMaybeMessage<TopicHeteroChannelConfigs>(nullptr);
  }

  TopicHeteroChannelConfigs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopicHeteroChannelConfigs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopicHeteroChannelConfigs& from);
  void MergeFrom(const TopicHeteroChannelConfigs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicHeteroChannelConfigs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.TopicHeteroChannelConfigs";
  }
  protected:
  explicit TopicHeteroChannelConfigs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // repeated .senseAD.rscl.idl.TopicHeteroChannelConfig config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  ::senseAD::rscl::idl::TopicHeteroChannelConfig* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicHeteroChannelConfig >*
      mutable_config();
  private:
  const ::senseAD::rscl::idl::TopicHeteroChannelConfig& _internal_config(int index) const;
  ::senseAD::rscl::idl::TopicHeteroChannelConfig* _internal_add_config();
  public:
  const ::senseAD::rscl::idl::TopicHeteroChannelConfig& config(int index) const;
  ::senseAD::rscl::idl::TopicHeteroChannelConfig* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicHeteroChannelConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.TopicHeteroChannelConfigs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicHeteroChannelConfig > config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class InetBasedService PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.InetBasedService) */ {
 public:
  inline InetBasedService() : InetBasedService(nullptr) {}
  virtual ~InetBasedService();

  InetBasedService(const InetBasedService& from);
  InetBasedService(InetBasedService&& from) noexcept
    : InetBasedService() {
    *this = ::std::move(from);
  }

  inline InetBasedService& operator=(const InetBasedService& from) {
    CopyFrom(from);
    return *this;
  }
  inline InetBasedService& operator=(InetBasedService&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InetBasedService& default_instance();

  static inline const InetBasedService* internal_default_instance() {
    return reinterpret_cast<const InetBasedService*>(
               &_InetBasedService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InetBasedService& a, InetBasedService& b) {
    a.Swap(&b);
  }
  inline void Swap(InetBasedService* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InetBasedService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InetBasedService* New() const final {
    return CreateMaybeMessage<InetBasedService>(nullptr);
  }

  InetBasedService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InetBasedService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InetBasedService& from);
  void MergeFrom(const InetBasedService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InetBasedService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.InetBasedService";
  }
  protected:
  explicit InetBasedService(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kIpFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // optional string service_name = 1;
  bool has_service_name() const;
  private:
  bool _internal_has_service_name() const;
  public:
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // optional string ip = 2;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional uint32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.InetBasedService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BridgeConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.BridgeConfig) */ {
 public:
  inline BridgeConfig() : BridgeConfig(nullptr) {}
  virtual ~BridgeConfig();

  BridgeConfig(const BridgeConfig& from);
  BridgeConfig(BridgeConfig&& from) noexcept
    : BridgeConfig() {
    *this = ::std::move(from);
  }

  inline BridgeConfig& operator=(const BridgeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeConfig& operator=(BridgeConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BridgeConfig& default_instance();

  static inline const BridgeConfig* internal_default_instance() {
    return reinterpret_cast<const BridgeConfig*>(
               &_BridgeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BridgeConfig& a, BridgeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BridgeConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BridgeConfig* New() const final {
    return CreateMaybeMessage<BridgeConfig>(nullptr);
  }

  BridgeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BridgeConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BridgeConfig& from);
  void MergeFrom(const BridgeConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BridgeConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.BridgeConfig";
  }
  protected:
  explicit BridgeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kInstanceIdFieldNumber = 2,
    kInstanceSpecifierFieldNumber = 3,
    kMsgTypeFieldNumber = 4,
    kDynamicLibPathFieldNumber = 5,
  };
  // optional string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // optional string instance_id = 2;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  void set_instance_id(const std::string& value);
  void set_instance_id(std::string&& value);
  void set_instance_id(const char* value);
  void set_instance_id(const char* value, size_t size);
  std::string* mutable_instance_id();
  std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // optional string instance_specifier = 3;
  bool has_instance_specifier() const;
  private:
  bool _internal_has_instance_specifier() const;
  public:
  void clear_instance_specifier();
  const std::string& instance_specifier() const;
  void set_instance_specifier(const std::string& value);
  void set_instance_specifier(std::string&& value);
  void set_instance_specifier(const char* value);
  void set_instance_specifier(const char* value, size_t size);
  std::string* mutable_instance_specifier();
  std::string* release_instance_specifier();
  void set_allocated_instance_specifier(std::string* instance_specifier);
  private:
  const std::string& _internal_instance_specifier() const;
  void _internal_set_instance_specifier(const std::string& value);
  std::string* _internal_mutable_instance_specifier();
  public:

  // optional string msg_type = 4;
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  const std::string& msg_type() const;
  void set_msg_type(const std::string& value);
  void set_msg_type(std::string&& value);
  void set_msg_type(const char* value);
  void set_msg_type(const char* value, size_t size);
  std::string* mutable_msg_type();
  std::string* release_msg_type();
  void set_allocated_msg_type(std::string* msg_type);
  private:
  const std::string& _internal_msg_type() const;
  void _internal_set_msg_type(const std::string& value);
  std::string* _internal_mutable_msg_type();
  public:

  // optional string dynamic_lib_path = 5;
  bool has_dynamic_lib_path() const;
  private:
  bool _internal_has_dynamic_lib_path() const;
  public:
  void clear_dynamic_lib_path();
  const std::string& dynamic_lib_path() const;
  void set_dynamic_lib_path(const std::string& value);
  void set_dynamic_lib_path(std::string&& value);
  void set_dynamic_lib_path(const char* value);
  void set_dynamic_lib_path(const char* value, size_t size);
  std::string* mutable_dynamic_lib_path();
  std::string* release_dynamic_lib_path();
  void set_allocated_dynamic_lib_path(std::string* dynamic_lib_path);
  private:
  const std::string& _internal_dynamic_lib_path() const;
  void _internal_set_dynamic_lib_path(const std::string& value);
  std::string* _internal_mutable_dynamic_lib_path();
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.BridgeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_specifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dynamic_lib_path_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TopicConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.TopicConfig) */ {
 public:
  inline TopicConfig() : TopicConfig(nullptr) {}
  virtual ~TopicConfig();

  TopicConfig(const TopicConfig& from);
  TopicConfig(TopicConfig&& from) noexcept
    : TopicConfig() {
    *this = ::std::move(from);
  }

  inline TopicConfig& operator=(const TopicConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicConfig& operator=(TopicConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopicConfig& default_instance();

  static inline const TopicConfig* internal_default_instance() {
    return reinterpret_cast<const TopicConfig*>(
               &_TopicConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TopicConfig& a, TopicConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopicConfig* New() const final {
    return CreateMaybeMessage<TopicConfig>(nullptr);
  }

  TopicConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopicConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopicConfig& from);
  void MergeFrom(const TopicConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.TopicConfig";
  }
  protected:
  explicit TopicConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kTopicSpecificHeteroConfigsFieldNumber = 2,
    kHeteroOnlyFieldNumber = 3,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // optional .senseAD.rscl.idl.TopicHeteroChannelConfigs topic_specific_hetero_configs = 2;
  bool has_topic_specific_hetero_configs() const;
  private:
  bool _internal_has_topic_specific_hetero_configs() const;
  public:
  void clear_topic_specific_hetero_configs();
  const ::senseAD::rscl::idl::TopicHeteroChannelConfigs& topic_specific_hetero_configs() const;
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* release_topic_specific_hetero_configs();
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* mutable_topic_specific_hetero_configs();
  void set_allocated_topic_specific_hetero_configs(::senseAD::rscl::idl::TopicHeteroChannelConfigs* topic_specific_hetero_configs);
  private:
  const ::senseAD::rscl::idl::TopicHeteroChannelConfigs& _internal_topic_specific_hetero_configs() const;
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* _internal_mutable_topic_specific_hetero_configs();
  public:
  void unsafe_arena_set_allocated_topic_specific_hetero_configs(
      ::senseAD::rscl::idl::TopicHeteroChannelConfigs* topic_specific_hetero_configs);
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* unsafe_arena_release_topic_specific_hetero_configs();

  // optional bool hetero_only = 3 [default = false];
  bool has_hetero_only() const;
  private:
  bool _internal_has_hetero_only() const;
  public:
  void clear_hetero_only();
  bool hetero_only() const;
  void set_hetero_only(bool value);
  private:
  bool _internal_hetero_only() const;
  void _internal_set_hetero_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.TopicConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* topic_specific_hetero_configs_;
  bool hetero_only_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrossSystemEndpointConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CrossSystemEndpointConfig) */ {
 public:
  inline CrossSystemEndpointConfig() : CrossSystemEndpointConfig(nullptr) {}
  virtual ~CrossSystemEndpointConfig();

  CrossSystemEndpointConfig(const CrossSystemEndpointConfig& from);
  CrossSystemEndpointConfig(CrossSystemEndpointConfig&& from) noexcept
    : CrossSystemEndpointConfig() {
    *this = ::std::move(from);
  }

  inline CrossSystemEndpointConfig& operator=(const CrossSystemEndpointConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossSystemEndpointConfig& operator=(CrossSystemEndpointConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrossSystemEndpointConfig& default_instance();

  static inline const CrossSystemEndpointConfig* internal_default_instance() {
    return reinterpret_cast<const CrossSystemEndpointConfig*>(
               &_CrossSystemEndpointConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CrossSystemEndpointConfig& a, CrossSystemEndpointConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossSystemEndpointConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossSystemEndpointConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrossSystemEndpointConfig* New() const final {
    return CreateMaybeMessage<CrossSystemEndpointConfig>(nullptr);
  }

  CrossSystemEndpointConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrossSystemEndpointConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrossSystemEndpointConfig& from);
  void MergeFrom(const CrossSystemEndpointConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossSystemEndpointConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CrossSystemEndpointConfig";
  }
  protected:
  explicit CrossSystemEndpointConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketRateLimitExcludedTopicFieldNumber = 2,
    kPacketRateLimitFieldNumber = 1,
    kNonBlockingSendFieldNumber = 4,
    kSendThreadDebugFieldNumber = 5,
    kSendThreadNumFieldNumber = 3,
  };
  // repeated string packet_rate_limit_excluded_topic = 2;
  int packet_rate_limit_excluded_topic_size() const;
  private:
  int _internal_packet_rate_limit_excluded_topic_size() const;
  public:
  void clear_packet_rate_limit_excluded_topic();
  const std::string& packet_rate_limit_excluded_topic(int index) const;
  std::string* mutable_packet_rate_limit_excluded_topic(int index);
  void set_packet_rate_limit_excluded_topic(int index, const std::string& value);
  void set_packet_rate_limit_excluded_topic(int index, std::string&& value);
  void set_packet_rate_limit_excluded_topic(int index, const char* value);
  void set_packet_rate_limit_excluded_topic(int index, const char* value, size_t size);
  std::string* add_packet_rate_limit_excluded_topic();
  void add_packet_rate_limit_excluded_topic(const std::string& value);
  void add_packet_rate_limit_excluded_topic(std::string&& value);
  void add_packet_rate_limit_excluded_topic(const char* value);
  void add_packet_rate_limit_excluded_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& packet_rate_limit_excluded_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_packet_rate_limit_excluded_topic();
  private:
  const std::string& _internal_packet_rate_limit_excluded_topic(int index) const;
  std::string* _internal_add_packet_rate_limit_excluded_topic();
  public:

  // optional int32 packet_rate_limit = 1;
  bool has_packet_rate_limit() const;
  private:
  bool _internal_has_packet_rate_limit() const;
  public:
  void clear_packet_rate_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 packet_rate_limit() const;
  void set_packet_rate_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_packet_rate_limit() const;
  void _internal_set_packet_rate_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool non_blocking_send = 4 [default = false];
  bool has_non_blocking_send() const;
  private:
  bool _internal_has_non_blocking_send() const;
  public:
  void clear_non_blocking_send();
  bool non_blocking_send() const;
  void set_non_blocking_send(bool value);
  private:
  bool _internal_non_blocking_send() const;
  void _internal_set_non_blocking_send(bool value);
  public:

  // optional bool send_thread_debug = 5 [default = false];
  bool has_send_thread_debug() const;
  private:
  bool _internal_has_send_thread_debug() const;
  public:
  void clear_send_thread_debug();
  bool send_thread_debug() const;
  void set_send_thread_debug(bool value);
  private:
  bool _internal_send_thread_debug() const;
  void _internal_set_send_thread_debug(bool value);
  public:

  // optional uint32 send_thread_num = 3 [default = 4];
  bool has_send_thread_num() const;
  private:
  bool _internal_has_send_thread_num() const;
  public:
  void clear_send_thread_num();
  ::PROTOBUF_NAMESPACE_ID::uint32 send_thread_num() const;
  void set_send_thread_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_send_thread_num() const;
  void _internal_set_send_thread_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CrossSystemEndpointConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> packet_rate_limit_excluded_topic_;
  ::PROTOBUF_NAMESPACE_ID::int32 packet_rate_limit_;
  bool non_blocking_send_;
  bool send_thread_debug_;
  ::PROTOBUF_NAMESPACE_ID::uint32 send_thread_num_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrossSystemStatReportConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CrossSystemStatReportConfig) */ {
 public:
  inline CrossSystemStatReportConfig() : CrossSystemStatReportConfig(nullptr) {}
  virtual ~CrossSystemStatReportConfig();

  CrossSystemStatReportConfig(const CrossSystemStatReportConfig& from);
  CrossSystemStatReportConfig(CrossSystemStatReportConfig&& from) noexcept
    : CrossSystemStatReportConfig() {
    *this = ::std::move(from);
  }

  inline CrossSystemStatReportConfig& operator=(const CrossSystemStatReportConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossSystemStatReportConfig& operator=(CrossSystemStatReportConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrossSystemStatReportConfig& default_instance();

  static inline const CrossSystemStatReportConfig* internal_default_instance() {
    return reinterpret_cast<const CrossSystemStatReportConfig*>(
               &_CrossSystemStatReportConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CrossSystemStatReportConfig& a, CrossSystemStatReportConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossSystemStatReportConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossSystemStatReportConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrossSystemStatReportConfig* New() const final {
    return CreateMaybeMessage<CrossSystemStatReportConfig>(nullptr);
  }

  CrossSystemStatReportConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrossSystemStatReportConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrossSystemStatReportConfig& from);
  void MergeFrom(const CrossSystemStatReportConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossSystemStatReportConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CrossSystemStatReportConfig";
  }
  protected:
  explicit CrossSystemStatReportConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
    kSampleIntervalFieldNumber = 50,
    kReportIntervalFieldNumber = 1000,
  };
  // optional bool enable = 1 [default = false];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional uint32 sample_interval = 50 [default = 50];
  bool has_sample_interval() const;
  private:
  bool _internal_has_sample_interval() const;
  public:
  void clear_sample_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 sample_interval() const;
  void set_sample_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sample_interval() const;
  void _internal_set_sample_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 report_interval = 1000 [default = 1000];
  bool has_report_interval() const;
  private:
  bool _internal_has_report_interval() const;
  public:
  void clear_report_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 report_interval() const;
  void set_report_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_report_interval() const;
  void _internal_set_report_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CrossSystemStatReportConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sample_interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 report_interval_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrossSystemEndpoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CrossSystemEndpoint) */ {
 public:
  inline CrossSystemEndpoint() : CrossSystemEndpoint(nullptr) {}
  virtual ~CrossSystemEndpoint();

  CrossSystemEndpoint(const CrossSystemEndpoint& from);
  CrossSystemEndpoint(CrossSystemEndpoint&& from) noexcept
    : CrossSystemEndpoint() {
    *this = ::std::move(from);
  }

  inline CrossSystemEndpoint& operator=(const CrossSystemEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossSystemEndpoint& operator=(CrossSystemEndpoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrossSystemEndpoint& default_instance();

  static inline const CrossSystemEndpoint* internal_default_instance() {
    return reinterpret_cast<const CrossSystemEndpoint*>(
               &_CrossSystemEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CrossSystemEndpoint& a, CrossSystemEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossSystemEndpoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossSystemEndpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrossSystemEndpoint* New() const final {
    return CreateMaybeMessage<CrossSystemEndpoint>(nullptr);
  }

  CrossSystemEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrossSystemEndpoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrossSystemEndpoint& from);
  void MergeFrom(const CrossSystemEndpoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossSystemEndpoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CrossSystemEndpoint";
  }
  protected:
  explicit CrossSystemEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kIpFieldNumber = 2,
    kConfigFieldNumber = 4,
    kPortFieldNumber = 3,
    kSummaryServicePortFieldNumber = 5,
  };
  // required string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // required string ip = 2;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional .senseAD.rscl.idl.CrossSystemEndpointConfig config = 4;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::senseAD::rscl::idl::CrossSystemEndpointConfig& config() const;
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* release_config();
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* mutable_config();
  void set_allocated_config(::senseAD::rscl::idl::CrossSystemEndpointConfig* config);
  private:
  const ::senseAD::rscl::idl::CrossSystemEndpointConfig& _internal_config() const;
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::senseAD::rscl::idl::CrossSystemEndpointConfig* config);
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* unsafe_arena_release_config();

  // optional uint32 port = 3 [default = 5432];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 summary_service_port = 5 [default = 5453];
  bool has_summary_service_port() const;
  private:
  bool _internal_has_summary_service_port() const;
  public:
  void clear_summary_service_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 summary_service_port() const;
  void set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_summary_service_port() const;
  void _internal_set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CrossSystemEndpoint)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 summary_service_port_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrossSystemConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CrossSystemConfig) */ {
 public:
  inline CrossSystemConfig() : CrossSystemConfig(nullptr) {}
  virtual ~CrossSystemConfig();

  CrossSystemConfig(const CrossSystemConfig& from);
  CrossSystemConfig(CrossSystemConfig&& from) noexcept
    : CrossSystemConfig() {
    *this = ::std::move(from);
  }

  inline CrossSystemConfig& operator=(const CrossSystemConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossSystemConfig& operator=(CrossSystemConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrossSystemConfig& default_instance();

  static inline const CrossSystemConfig* internal_default_instance() {
    return reinterpret_cast<const CrossSystemConfig*>(
               &_CrossSystemConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CrossSystemConfig& a, CrossSystemConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossSystemConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossSystemConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrossSystemConfig* New() const final {
    return CreateMaybeMessage<CrossSystemConfig>(nullptr);
  }

  CrossSystemConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrossSystemConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrossSystemConfig& from);
  void MergeFrom(const CrossSystemConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossSystemConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CrossSystemConfig";
  }
  protected:
  explicit CrossSystemConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 3,
    kExcludedTopicFieldNumber = 4,
    kWhitelistTopicFieldNumber = 5,
    kOutgoingOnlyTopicFieldNumber = 6,
    kExtraCommonTopicFieldNumber = 8,
    kHostnameFieldNumber = 1,
    kStatReportConfigFieldNumber = 9,
    kModeFieldNumber = 2,
    kOutgoingPrefixModeFieldNumber = 7,
    kQueryServicePortFieldNumber = 10,
    kSummaryServicePortFieldNumber = 11,
    kDistributeServicePortFieldNumber = 12,
  };
  // repeated .senseAD.rscl.idl.CrossSystemEndpoint endpoint = 3;
  int endpoint_size() const;
  private:
  int _internal_endpoint_size() const;
  public:
  void clear_endpoint();
  ::senseAD::rscl::idl::CrossSystemEndpoint* mutable_endpoint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CrossSystemEndpoint >*
      mutable_endpoint();
  private:
  const ::senseAD::rscl::idl::CrossSystemEndpoint& _internal_endpoint(int index) const;
  ::senseAD::rscl::idl::CrossSystemEndpoint* _internal_add_endpoint();
  public:
  const ::senseAD::rscl::idl::CrossSystemEndpoint& endpoint(int index) const;
  ::senseAD::rscl::idl::CrossSystemEndpoint* add_endpoint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CrossSystemEndpoint >&
      endpoint() const;

  // repeated string excluded_topic = 4;
  int excluded_topic_size() const;
  private:
  int _internal_excluded_topic_size() const;
  public:
  void clear_excluded_topic();
  const std::string& excluded_topic(int index) const;
  std::string* mutable_excluded_topic(int index);
  void set_excluded_topic(int index, const std::string& value);
  void set_excluded_topic(int index, std::string&& value);
  void set_excluded_topic(int index, const char* value);
  void set_excluded_topic(int index, const char* value, size_t size);
  std::string* add_excluded_topic();
  void add_excluded_topic(const std::string& value);
  void add_excluded_topic(std::string&& value);
  void add_excluded_topic(const char* value);
  void add_excluded_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& excluded_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_excluded_topic();
  private:
  const std::string& _internal_excluded_topic(int index) const;
  std::string* _internal_add_excluded_topic();
  public:

  // repeated string whitelist_topic = 5;
  int whitelist_topic_size() const;
  private:
  int _internal_whitelist_topic_size() const;
  public:
  void clear_whitelist_topic();
  const std::string& whitelist_topic(int index) const;
  std::string* mutable_whitelist_topic(int index);
  void set_whitelist_topic(int index, const std::string& value);
  void set_whitelist_topic(int index, std::string&& value);
  void set_whitelist_topic(int index, const char* value);
  void set_whitelist_topic(int index, const char* value, size_t size);
  std::string* add_whitelist_topic();
  void add_whitelist_topic(const std::string& value);
  void add_whitelist_topic(std::string&& value);
  void add_whitelist_topic(const char* value);
  void add_whitelist_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& whitelist_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_whitelist_topic();
  private:
  const std::string& _internal_whitelist_topic(int index) const;
  std::string* _internal_add_whitelist_topic();
  public:

  // repeated string outgoing_only_topic = 6;
  int outgoing_only_topic_size() const;
  private:
  int _internal_outgoing_only_topic_size() const;
  public:
  void clear_outgoing_only_topic();
  const std::string& outgoing_only_topic(int index) const;
  std::string* mutable_outgoing_only_topic(int index);
  void set_outgoing_only_topic(int index, const std::string& value);
  void set_outgoing_only_topic(int index, std::string&& value);
  void set_outgoing_only_topic(int index, const char* value);
  void set_outgoing_only_topic(int index, const char* value, size_t size);
  std::string* add_outgoing_only_topic();
  void add_outgoing_only_topic(const std::string& value);
  void add_outgoing_only_topic(std::string&& value);
  void add_outgoing_only_topic(const char* value);
  void add_outgoing_only_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& outgoing_only_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_outgoing_only_topic();
  private:
  const std::string& _internal_outgoing_only_topic(int index) const;
  std::string* _internal_add_outgoing_only_topic();
  public:

  // repeated string extra_common_topic = 8;
  int extra_common_topic_size() const;
  private:
  int _internal_extra_common_topic_size() const;
  public:
  void clear_extra_common_topic();
  const std::string& extra_common_topic(int index) const;
  std::string* mutable_extra_common_topic(int index);
  void set_extra_common_topic(int index, const std::string& value);
  void set_extra_common_topic(int index, std::string&& value);
  void set_extra_common_topic(int index, const char* value);
  void set_extra_common_topic(int index, const char* value, size_t size);
  std::string* add_extra_common_topic();
  void add_extra_common_topic(const std::string& value);
  void add_extra_common_topic(std::string&& value);
  void add_extra_common_topic(const char* value);
  void add_extra_common_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extra_common_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extra_common_topic();
  private:
  const std::string& _internal_extra_common_topic(int index) const;
  std::string* _internal_add_extra_common_topic();
  public:

  // required string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // optional .senseAD.rscl.idl.CrossSystemStatReportConfig stat_report_config = 9;
  bool has_stat_report_config() const;
  private:
  bool _internal_has_stat_report_config() const;
  public:
  void clear_stat_report_config();
  const ::senseAD::rscl::idl::CrossSystemStatReportConfig& stat_report_config() const;
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* release_stat_report_config();
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* mutable_stat_report_config();
  void set_allocated_stat_report_config(::senseAD::rscl::idl::CrossSystemStatReportConfig* stat_report_config);
  private:
  const ::senseAD::rscl::idl::CrossSystemStatReportConfig& _internal_stat_report_config() const;
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* _internal_mutable_stat_report_config();
  public:
  void unsafe_arena_set_allocated_stat_report_config(
      ::senseAD::rscl::idl::CrossSystemStatReportConfig* stat_report_config);
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* unsafe_arena_release_stat_report_config();

  // optional .senseAD.rscl.idl.CrossSystemMode mode = 2 [default = STATIC_PEER];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::senseAD::rscl::idl::CrossSystemMode mode() const;
  void set_mode(::senseAD::rscl::idl::CrossSystemMode value);
  private:
  ::senseAD::rscl::idl::CrossSystemMode _internal_mode() const;
  void _internal_set_mode(::senseAD::rscl::idl::CrossSystemMode value);
  public:

  // optional .senseAD.rscl.idl.CrossSystemOutgoingPrefixMode outgoing_prefix_mode = 7 [default = ALL];
  bool has_outgoing_prefix_mode() const;
  private:
  bool _internal_has_outgoing_prefix_mode() const;
  public:
  void clear_outgoing_prefix_mode();
  ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode outgoing_prefix_mode() const;
  void set_outgoing_prefix_mode(::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode value);
  private:
  ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode _internal_outgoing_prefix_mode() const;
  void _internal_set_outgoing_prefix_mode(::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode value);
  public:

  // optional uint32 query_service_port = 10 [default = 5452];
  bool has_query_service_port() const;
  private:
  bool _internal_has_query_service_port() const;
  public:
  void clear_query_service_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 query_service_port() const;
  void set_query_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_query_service_port() const;
  void _internal_set_query_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 summary_service_port = 11 [default = 5453];
  bool has_summary_service_port() const;
  private:
  bool _internal_has_summary_service_port() const;
  public:
  void clear_summary_service_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 summary_service_port() const;
  void set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_summary_service_port() const;
  void _internal_set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 distribute_service_port = 12 [default = 5454];
  bool has_distribute_service_port() const;
  private:
  bool _internal_has_distribute_service_port() const;
  public:
  void clear_distribute_service_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 distribute_service_port() const;
  void set_distribute_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_distribute_service_port() const;
  void _internal_set_distribute_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CrossSystemConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CrossSystemEndpoint > endpoint_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> excluded_topic_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> whitelist_topic_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> outgoing_only_topic_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extra_common_topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* stat_report_config_;
  int mode_;
  int outgoing_prefix_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 query_service_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 summary_service_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 distribute_service_port_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class NodeConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.NodeConfig) */ {
 public:
  inline NodeConfig() : NodeConfig(nullptr) {}
  virtual ~NodeConfig();

  NodeConfig(const NodeConfig& from);
  NodeConfig(NodeConfig&& from) noexcept
    : NodeConfig() {
    *this = ::std::move(from);
  }

  inline NodeConfig& operator=(const NodeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeConfig& operator=(NodeConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeConfig& default_instance();

  static inline const NodeConfig* internal_default_instance() {
    return reinterpret_cast<const NodeConfig*>(
               &_NodeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NodeConfig& a, NodeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeConfig* New() const final {
    return CreateMaybeMessage<NodeConfig>(nullptr);
  }

  NodeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeConfig& from);
  void MergeFrom(const NodeConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.NodeConfig";
  }
  protected:
  explicit NodeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeSpecificTopicConfigFieldNumber = 2,
    kNodeNameFieldNumber = 1,
  };
  // repeated .senseAD.rscl.idl.TopicConfig node_specific_topic_config = 2;
  int node_specific_topic_config_size() const;
  private:
  int _internal_node_specific_topic_config_size() const;
  public:
  void clear_node_specific_topic_config();
  ::senseAD::rscl::idl::TopicConfig* mutable_node_specific_topic_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicConfig >*
      mutable_node_specific_topic_config();
  private:
  const ::senseAD::rscl::idl::TopicConfig& _internal_node_specific_topic_config(int index) const;
  ::senseAD::rscl::idl::TopicConfig* _internal_add_node_specific_topic_config();
  public:
  const ::senseAD::rscl::idl::TopicConfig& node_specific_topic_config(int index) const;
  ::senseAD::rscl::idl::TopicConfig* add_node_specific_topic_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicConfig >&
      node_specific_topic_config() const;

  // required string node_name = 1;
  bool has_node_name() const;
  private:
  bool _internal_has_node_name() const;
  public:
  void clear_node_name();
  const std::string& node_name() const;
  void set_node_name(const std::string& value);
  void set_node_name(std::string&& value);
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  std::string* mutable_node_name();
  std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.NodeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicConfig > node_specific_topic_config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class RuntimeConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.RuntimeConfig) */ {
 public:
  inline RuntimeConfig() : RuntimeConfig(nullptr) {}
  virtual ~RuntimeConfig();

  RuntimeConfig(const RuntimeConfig& from);
  RuntimeConfig(RuntimeConfig&& from) noexcept
    : RuntimeConfig() {
    *this = ::std::move(from);
  }

  inline RuntimeConfig& operator=(const RuntimeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeConfig& operator=(RuntimeConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RuntimeConfig& default_instance();

  static inline const RuntimeConfig* internal_default_instance() {
    return reinterpret_cast<const RuntimeConfig*>(
               &_RuntimeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RuntimeConfig& a, RuntimeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeConfig* New() const final {
    return CreateMaybeMessage<RuntimeConfig>(nullptr);
  }

  RuntimeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RuntimeConfig& from);
  void MergeFrom(const RuntimeConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.RuntimeConfig";
  }
  protected:
  explicit RuntimeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // optional .senseAD.rscl.idl.Condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::senseAD::rscl::idl::Condition& condition() const;
  ::senseAD::rscl::idl::Condition* release_condition();
  ::senseAD::rscl::idl::Condition* mutable_condition();
  void set_allocated_condition(::senseAD::rscl::idl::Condition* condition);
  private:
  const ::senseAD::rscl::idl::Condition& _internal_condition() const;
  ::senseAD::rscl::idl::Condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::senseAD::rscl::idl::Condition* condition);
  ::senseAD::rscl::idl::Condition* unsafe_arena_release_condition();

  // optional .senseAD.mw.proto.RuntimeConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::senseAD::mw::proto::RuntimeConfig& config() const;
  ::senseAD::mw::proto::RuntimeConfig* release_config();
  ::senseAD::mw::proto::RuntimeConfig* mutable_config();
  void set_allocated_config(::senseAD::mw::proto::RuntimeConfig* config);
  private:
  const ::senseAD::mw::proto::RuntimeConfig& _internal_config() const;
  ::senseAD::mw::proto::RuntimeConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::senseAD::mw::proto::RuntimeConfig* config);
  ::senseAD::mw::proto::RuntimeConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.RuntimeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::senseAD::rscl::idl::Condition* condition_;
  ::senseAD::mw::proto::RuntimeConfig* config_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CommonBridgeClientConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CommonBridgeClientConfig) */ {
 public:
  inline CommonBridgeClientConfig() : CommonBridgeClientConfig(nullptr) {}
  virtual ~CommonBridgeClientConfig();

  CommonBridgeClientConfig(const CommonBridgeClientConfig& from);
  CommonBridgeClientConfig(CommonBridgeClientConfig&& from) noexcept
    : CommonBridgeClientConfig() {
    *this = ::std::move(from);
  }

  inline CommonBridgeClientConfig& operator=(const CommonBridgeClientConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonBridgeClientConfig& operator=(CommonBridgeClientConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommonBridgeClientConfig& default_instance();

  static inline const CommonBridgeClientConfig* internal_default_instance() {
    return reinterpret_cast<const CommonBridgeClientConfig*>(
               &_CommonBridgeClientConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CommonBridgeClientConfig& a, CommonBridgeClientConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonBridgeClientConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonBridgeClientConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonBridgeClientConfig* New() const final {
    return CreateMaybeMessage<CommonBridgeClientConfig>(nullptr);
  }

  CommonBridgeClientConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonBridgeClientConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommonBridgeClientConfig& from);
  void MergeFrom(const CommonBridgeClientConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonBridgeClientConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CommonBridgeClientConfig";
  }
  protected:
  explicit CommonBridgeClientConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExcludedTopicFieldNumber = 2,
    kIncludedTopicFieldNumber = 3,
    kEndpointFieldNumber = 1,
  };
  // repeated string excluded_topic = 2;
  int excluded_topic_size() const;
  private:
  int _internal_excluded_topic_size() const;
  public:
  void clear_excluded_topic();
  const std::string& excluded_topic(int index) const;
  std::string* mutable_excluded_topic(int index);
  void set_excluded_topic(int index, const std::string& value);
  void set_excluded_topic(int index, std::string&& value);
  void set_excluded_topic(int index, const char* value);
  void set_excluded_topic(int index, const char* value, size_t size);
  std::string* add_excluded_topic();
  void add_excluded_topic(const std::string& value);
  void add_excluded_topic(std::string&& value);
  void add_excluded_topic(const char* value);
  void add_excluded_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& excluded_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_excluded_topic();
  private:
  const std::string& _internal_excluded_topic(int index) const;
  std::string* _internal_add_excluded_topic();
  public:

  // repeated string included_topic = 3;
  int included_topic_size() const;
  private:
  int _internal_included_topic_size() const;
  public:
  void clear_included_topic();
  const std::string& included_topic(int index) const;
  std::string* mutable_included_topic(int index);
  void set_included_topic(int index, const std::string& value);
  void set_included_topic(int index, std::string&& value);
  void set_included_topic(int index, const char* value);
  void set_included_topic(int index, const char* value, size_t size);
  std::string* add_included_topic();
  void add_included_topic(const std::string& value);
  void add_included_topic(std::string&& value);
  void add_included_topic(const char* value);
  void add_included_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& included_topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_included_topic();
  private:
  const std::string& _internal_included_topic(int index) const;
  std::string* _internal_add_included_topic();
  public:

  // required .senseAD.rscl.idl.CrossSystemEndpoint endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::senseAD::rscl::idl::CrossSystemEndpoint& endpoint() const;
  ::senseAD::rscl::idl::CrossSystemEndpoint* release_endpoint();
  ::senseAD::rscl::idl::CrossSystemEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::senseAD::rscl::idl::CrossSystemEndpoint* endpoint);
  private:
  const ::senseAD::rscl::idl::CrossSystemEndpoint& _internal_endpoint() const;
  ::senseAD::rscl::idl::CrossSystemEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::senseAD::rscl::idl::CrossSystemEndpoint* endpoint);
  ::senseAD::rscl::idl::CrossSystemEndpoint* unsafe_arena_release_endpoint();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CommonBridgeClientConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> excluded_topic_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> included_topic_;
  ::senseAD::rscl::idl::CrossSystemEndpoint* endpoint_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CommonBridgeServerConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CommonBridgeServerConfig) */ {
 public:
  inline CommonBridgeServerConfig() : CommonBridgeServerConfig(nullptr) {}
  virtual ~CommonBridgeServerConfig();

  CommonBridgeServerConfig(const CommonBridgeServerConfig& from);
  CommonBridgeServerConfig(CommonBridgeServerConfig&& from) noexcept
    : CommonBridgeServerConfig() {
    *this = ::std::move(from);
  }

  inline CommonBridgeServerConfig& operator=(const CommonBridgeServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonBridgeServerConfig& operator=(CommonBridgeServerConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommonBridgeServerConfig& default_instance();

  static inline const CommonBridgeServerConfig* internal_default_instance() {
    return reinterpret_cast<const CommonBridgeServerConfig*>(
               &_CommonBridgeServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CommonBridgeServerConfig& a, CommonBridgeServerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonBridgeServerConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonBridgeServerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonBridgeServerConfig* New() const final {
    return CreateMaybeMessage<CommonBridgeServerConfig>(nullptr);
  }

  CommonBridgeServerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonBridgeServerConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommonBridgeServerConfig& from);
  void MergeFrom(const CommonBridgeServerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonBridgeServerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CommonBridgeServerConfig";
  }
  protected:
  explicit CommonBridgeServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // required string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // optional uint32 port = 2 [default = 5800];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CommonBridgeServerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CommonBridgeConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.CommonBridgeConfig) */ {
 public:
  inline CommonBridgeConfig() : CommonBridgeConfig(nullptr) {}
  virtual ~CommonBridgeConfig();

  CommonBridgeConfig(const CommonBridgeConfig& from);
  CommonBridgeConfig(CommonBridgeConfig&& from) noexcept
    : CommonBridgeConfig() {
    *this = ::std::move(from);
  }

  inline CommonBridgeConfig& operator=(const CommonBridgeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonBridgeConfig& operator=(CommonBridgeConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommonBridgeConfig& default_instance();

  static inline const CommonBridgeConfig* internal_default_instance() {
    return reinterpret_cast<const CommonBridgeConfig*>(
               &_CommonBridgeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CommonBridgeConfig& a, CommonBridgeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonBridgeConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonBridgeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonBridgeConfig* New() const final {
    return CreateMaybeMessage<CommonBridgeConfig>(nullptr);
  }

  CommonBridgeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonBridgeConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommonBridgeConfig& from);
  void MergeFrom(const CommonBridgeConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonBridgeConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.CommonBridgeConfig";
  }
  protected:
  explicit CommonBridgeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 2,
    kServerFieldNumber = 1,
  };
  // repeated .senseAD.rscl.idl.CommonBridgeClientConfig clients = 2;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  ::senseAD::rscl::idl::CommonBridgeClientConfig* mutable_clients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CommonBridgeClientConfig >*
      mutable_clients();
  private:
  const ::senseAD::rscl::idl::CommonBridgeClientConfig& _internal_clients(int index) const;
  ::senseAD::rscl::idl::CommonBridgeClientConfig* _internal_add_clients();
  public:
  const ::senseAD::rscl::idl::CommonBridgeClientConfig& clients(int index) const;
  ::senseAD::rscl::idl::CommonBridgeClientConfig* add_clients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CommonBridgeClientConfig >&
      clients() const;

  // required .senseAD.rscl.idl.CommonBridgeServerConfig server = 1;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::senseAD::rscl::idl::CommonBridgeServerConfig& server() const;
  ::senseAD::rscl::idl::CommonBridgeServerConfig* release_server();
  ::senseAD::rscl::idl::CommonBridgeServerConfig* mutable_server();
  void set_allocated_server(::senseAD::rscl::idl::CommonBridgeServerConfig* server);
  private:
  const ::senseAD::rscl::idl::CommonBridgeServerConfig& _internal_server() const;
  ::senseAD::rscl::idl::CommonBridgeServerConfig* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::senseAD::rscl::idl::CommonBridgeServerConfig* server);
  ::senseAD::rscl::idl::CommonBridgeServerConfig* unsafe_arena_release_server();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.CommonBridgeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CommonBridgeClientConfig > clients_;
  ::senseAD::rscl::idl::CommonBridgeServerConfig* server_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GlobalConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:senseAD.rscl.idl.GlobalConfig) */ {
 public:
  inline GlobalConfig() : GlobalConfig(nullptr) {}
  virtual ~GlobalConfig();

  GlobalConfig(const GlobalConfig& from);
  GlobalConfig(GlobalConfig&& from) noexcept
    : GlobalConfig() {
    *this = ::std::move(from);
  }

  inline GlobalConfig& operator=(const GlobalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalConfig& operator=(GlobalConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GlobalConfig& default_instance();

  static inline const GlobalConfig* internal_default_instance() {
    return reinterpret_cast<const GlobalConfig*>(
               &_GlobalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GlobalConfig& a, GlobalConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalConfig* New() const final {
    return CreateMaybeMessage<GlobalConfig>(nullptr);
  }

  GlobalConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GlobalConfig& from);
  void MergeFrom(const GlobalConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "senseAD.rscl.idl.GlobalConfig";
  }
  protected:
  explicit GlobalConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto);
    return ::descriptor_table_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvGroupFieldNumber = 1,
    kExtendFieldNumber = 2,
    kMwConfigFieldNumber = 3,
    kNodeConfigFieldNumber = 5,
    kHeteroConfigFieldNumber = 6,
    kInetServiceFieldNumber = 7,
    kCrossSystemFieldNumber = 4,
    kCommonBridgeFieldNumber = 8,
  };
  // repeated .senseAD.rscl.idl.EnvGroup env_group = 1;
  int env_group_size() const;
  private:
  int _internal_env_group_size() const;
  public:
  void clear_env_group();
  ::senseAD::rscl::idl::EnvGroup* mutable_env_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::EnvGroup >*
      mutable_env_group();
  private:
  const ::senseAD::rscl::idl::EnvGroup& _internal_env_group(int index) const;
  ::senseAD::rscl::idl::EnvGroup* _internal_add_env_group();
  public:
  const ::senseAD::rscl::idl::EnvGroup& env_group(int index) const;
  ::senseAD::rscl::idl::EnvGroup* add_env_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::EnvGroup >&
      env_group() const;

  // repeated .senseAD.rscl.idl.Extend extend = 2;
  int extend_size() const;
  private:
  int _internal_extend_size() const;
  public:
  void clear_extend();
  ::senseAD::rscl::idl::Extend* mutable_extend(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::Extend >*
      mutable_extend();
  private:
  const ::senseAD::rscl::idl::Extend& _internal_extend(int index) const;
  ::senseAD::rscl::idl::Extend* _internal_add_extend();
  public:
  const ::senseAD::rscl::idl::Extend& extend(int index) const;
  ::senseAD::rscl::idl::Extend* add_extend();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::Extend >&
      extend() const;

  // repeated .senseAD.rscl.idl.RuntimeConfig mw_config = 3;
  int mw_config_size() const;
  private:
  int _internal_mw_config_size() const;
  public:
  void clear_mw_config();
  ::senseAD::rscl::idl::RuntimeConfig* mutable_mw_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::RuntimeConfig >*
      mutable_mw_config();
  private:
  const ::senseAD::rscl::idl::RuntimeConfig& _internal_mw_config(int index) const;
  ::senseAD::rscl::idl::RuntimeConfig* _internal_add_mw_config();
  public:
  const ::senseAD::rscl::idl::RuntimeConfig& mw_config(int index) const;
  ::senseAD::rscl::idl::RuntimeConfig* add_mw_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::RuntimeConfig >&
      mw_config() const;

  // repeated .senseAD.rscl.idl.NodeConfig node_config = 5;
  int node_config_size() const;
  private:
  int _internal_node_config_size() const;
  public:
  void clear_node_config();
  ::senseAD::rscl::idl::NodeConfig* mutable_node_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::NodeConfig >*
      mutable_node_config();
  private:
  const ::senseAD::rscl::idl::NodeConfig& _internal_node_config(int index) const;
  ::senseAD::rscl::idl::NodeConfig* _internal_add_node_config();
  public:
  const ::senseAD::rscl::idl::NodeConfig& node_config(int index) const;
  ::senseAD::rscl::idl::NodeConfig* add_node_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::NodeConfig >&
      node_config() const;

  // repeated .senseAD.rscl.idl.HeteroChannelConfig hetero_config = 6;
  int hetero_config_size() const;
  private:
  int _internal_hetero_config_size() const;
  public:
  void clear_hetero_config();
  ::senseAD::rscl::idl::HeteroChannelConfig* mutable_hetero_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::HeteroChannelConfig >*
      mutable_hetero_config();
  private:
  const ::senseAD::rscl::idl::HeteroChannelConfig& _internal_hetero_config(int index) const;
  ::senseAD::rscl::idl::HeteroChannelConfig* _internal_add_hetero_config();
  public:
  const ::senseAD::rscl::idl::HeteroChannelConfig& hetero_config(int index) const;
  ::senseAD::rscl::idl::HeteroChannelConfig* add_hetero_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::HeteroChannelConfig >&
      hetero_config() const;

  // repeated .senseAD.rscl.idl.InetBasedService inet_service = 7;
  int inet_service_size() const;
  private:
  int _internal_inet_service_size() const;
  public:
  void clear_inet_service();
  ::senseAD::rscl::idl::InetBasedService* mutable_inet_service(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::InetBasedService >*
      mutable_inet_service();
  private:
  const ::senseAD::rscl::idl::InetBasedService& _internal_inet_service(int index) const;
  ::senseAD::rscl::idl::InetBasedService* _internal_add_inet_service();
  public:
  const ::senseAD::rscl::idl::InetBasedService& inet_service(int index) const;
  ::senseAD::rscl::idl::InetBasedService* add_inet_service();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::InetBasedService >&
      inet_service() const;

  // optional .senseAD.rscl.idl.CrossSystemConfig cross_system = 4;
  bool has_cross_system() const;
  private:
  bool _internal_has_cross_system() const;
  public:
  void clear_cross_system();
  const ::senseAD::rscl::idl::CrossSystemConfig& cross_system() const;
  ::senseAD::rscl::idl::CrossSystemConfig* release_cross_system();
  ::senseAD::rscl::idl::CrossSystemConfig* mutable_cross_system();
  void set_allocated_cross_system(::senseAD::rscl::idl::CrossSystemConfig* cross_system);
  private:
  const ::senseAD::rscl::idl::CrossSystemConfig& _internal_cross_system() const;
  ::senseAD::rscl::idl::CrossSystemConfig* _internal_mutable_cross_system();
  public:
  void unsafe_arena_set_allocated_cross_system(
      ::senseAD::rscl::idl::CrossSystemConfig* cross_system);
  ::senseAD::rscl::idl::CrossSystemConfig* unsafe_arena_release_cross_system();

  // optional .senseAD.rscl.idl.CommonBridgeConfig common_bridge = 8;
  bool has_common_bridge() const;
  private:
  bool _internal_has_common_bridge() const;
  public:
  void clear_common_bridge();
  const ::senseAD::rscl::idl::CommonBridgeConfig& common_bridge() const;
  ::senseAD::rscl::idl::CommonBridgeConfig* release_common_bridge();
  ::senseAD::rscl::idl::CommonBridgeConfig* mutable_common_bridge();
  void set_allocated_common_bridge(::senseAD::rscl::idl::CommonBridgeConfig* common_bridge);
  private:
  const ::senseAD::rscl::idl::CommonBridgeConfig& _internal_common_bridge() const;
  ::senseAD::rscl::idl::CommonBridgeConfig* _internal_mutable_common_bridge();
  public:
  void unsafe_arena_set_allocated_common_bridge(
      ::senseAD::rscl::idl::CommonBridgeConfig* common_bridge);
  ::senseAD::rscl::idl::CommonBridgeConfig* unsafe_arena_release_common_bridge();

  // @@protoc_insertion_point(class_scope:senseAD.rscl.idl.GlobalConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::EnvGroup > env_group_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::Extend > extend_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::RuntimeConfig > mw_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::NodeConfig > node_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::HeteroChannelConfig > hetero_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::InetBasedService > inet_service_;
  ::senseAD::rscl::idl::CrossSystemConfig* cross_system_;
  ::senseAD::rscl::idl::CommonBridgeConfig* common_bridge_;
  friend struct ::TableStruct_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConditionDetail

// repeated string mac_address = 1;
inline int ConditionDetail::_internal_mac_address_size() const {
  return mac_address_.size();
}
inline int ConditionDetail::mac_address_size() const {
  return _internal_mac_address_size();
}
inline void ConditionDetail::clear_mac_address() {
  mac_address_.Clear();
}
inline std::string* ConditionDetail::add_mac_address() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.ConditionDetail.mac_address)
  return _internal_add_mac_address();
}
inline const std::string& ConditionDetail::_internal_mac_address(int index) const {
  return mac_address_.Get(index);
}
inline const std::string& ConditionDetail::mac_address(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.ConditionDetail.mac_address)
  return _internal_mac_address(index);
}
inline std::string* ConditionDetail::mutable_mac_address(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.ConditionDetail.mac_address)
  return mac_address_.Mutable(index);
}
inline void ConditionDetail::set_mac_address(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.ConditionDetail.mac_address)
  mac_address_.Mutable(index)->assign(value);
}
inline void ConditionDetail::set_mac_address(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.ConditionDetail.mac_address)
  mac_address_.Mutable(index)->assign(std::move(value));
}
inline void ConditionDetail::set_mac_address(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mac_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.ConditionDetail.mac_address)
}
inline void ConditionDetail::set_mac_address(int index, const char* value, size_t size) {
  mac_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.ConditionDetail.mac_address)
}
inline std::string* ConditionDetail::_internal_add_mac_address() {
  return mac_address_.Add();
}
inline void ConditionDetail::add_mac_address(const std::string& value) {
  mac_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.ConditionDetail.mac_address)
}
inline void ConditionDetail::add_mac_address(std::string&& value) {
  mac_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.ConditionDetail.mac_address)
}
inline void ConditionDetail::add_mac_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mac_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.ConditionDetail.mac_address)
}
inline void ConditionDetail::add_mac_address(const char* value, size_t size) {
  mac_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.ConditionDetail.mac_address)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConditionDetail::mac_address() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.ConditionDetail.mac_address)
  return mac_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConditionDetail::mutable_mac_address() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.ConditionDetail.mac_address)
  return &mac_address_;
}

// repeated string env_var = 2;
inline int ConditionDetail::_internal_env_var_size() const {
  return env_var_.size();
}
inline int ConditionDetail::env_var_size() const {
  return _internal_env_var_size();
}
inline void ConditionDetail::clear_env_var() {
  env_var_.Clear();
}
inline std::string* ConditionDetail::add_env_var() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.ConditionDetail.env_var)
  return _internal_add_env_var();
}
inline const std::string& ConditionDetail::_internal_env_var(int index) const {
  return env_var_.Get(index);
}
inline const std::string& ConditionDetail::env_var(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.ConditionDetail.env_var)
  return _internal_env_var(index);
}
inline std::string* ConditionDetail::mutable_env_var(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.ConditionDetail.env_var)
  return env_var_.Mutable(index);
}
inline void ConditionDetail::set_env_var(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.ConditionDetail.env_var)
  env_var_.Mutable(index)->assign(value);
}
inline void ConditionDetail::set_env_var(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.ConditionDetail.env_var)
  env_var_.Mutable(index)->assign(std::move(value));
}
inline void ConditionDetail::set_env_var(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  env_var_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.ConditionDetail.env_var)
}
inline void ConditionDetail::set_env_var(int index, const char* value, size_t size) {
  env_var_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.ConditionDetail.env_var)
}
inline std::string* ConditionDetail::_internal_add_env_var() {
  return env_var_.Add();
}
inline void ConditionDetail::add_env_var(const std::string& value) {
  env_var_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.ConditionDetail.env_var)
}
inline void ConditionDetail::add_env_var(std::string&& value) {
  env_var_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.ConditionDetail.env_var)
}
inline void ConditionDetail::add_env_var(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  env_var_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.ConditionDetail.env_var)
}
inline void ConditionDetail::add_env_var(const char* value, size_t size) {
  env_var_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.ConditionDetail.env_var)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConditionDetail::env_var() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.ConditionDetail.env_var)
  return env_var_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConditionDetail::mutable_env_var() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.ConditionDetail.env_var)
  return &env_var_;
}

// -------------------------------------------------------------------

// Condition

// repeated string included = 1;
inline int Condition::_internal_included_size() const {
  return included_.size();
}
inline int Condition::included_size() const {
  return _internal_included_size();
}
inline void Condition::clear_included() {
  included_.Clear();
}
inline std::string* Condition::add_included() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.Condition.included)
  return _internal_add_included();
}
inline const std::string& Condition::_internal_included(int index) const {
  return included_.Get(index);
}
inline const std::string& Condition::included(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.Condition.included)
  return _internal_included(index);
}
inline std::string* Condition::mutable_included(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.Condition.included)
  return included_.Mutable(index);
}
inline void Condition::set_included(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.Condition.included)
  included_.Mutable(index)->assign(value);
}
inline void Condition::set_included(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.Condition.included)
  included_.Mutable(index)->assign(std::move(value));
}
inline void Condition::set_included(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  included_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.Condition.included)
}
inline void Condition::set_included(int index, const char* value, size_t size) {
  included_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.Condition.included)
}
inline std::string* Condition::_internal_add_included() {
  return included_.Add();
}
inline void Condition::add_included(const std::string& value) {
  included_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.Condition.included)
}
inline void Condition::add_included(std::string&& value) {
  included_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.Condition.included)
}
inline void Condition::add_included(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  included_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.Condition.included)
}
inline void Condition::add_included(const char* value, size_t size) {
  included_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.Condition.included)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Condition::included() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.Condition.included)
  return included_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Condition::mutable_included() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.Condition.included)
  return &included_;
}

// repeated string excluded = 2;
inline int Condition::_internal_excluded_size() const {
  return excluded_.size();
}
inline int Condition::excluded_size() const {
  return _internal_excluded_size();
}
inline void Condition::clear_excluded() {
  excluded_.Clear();
}
inline std::string* Condition::add_excluded() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.Condition.excluded)
  return _internal_add_excluded();
}
inline const std::string& Condition::_internal_excluded(int index) const {
  return excluded_.Get(index);
}
inline const std::string& Condition::excluded(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.Condition.excluded)
  return _internal_excluded(index);
}
inline std::string* Condition::mutable_excluded(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.Condition.excluded)
  return excluded_.Mutable(index);
}
inline void Condition::set_excluded(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.Condition.excluded)
  excluded_.Mutable(index)->assign(value);
}
inline void Condition::set_excluded(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.Condition.excluded)
  excluded_.Mutable(index)->assign(std::move(value));
}
inline void Condition::set_excluded(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  excluded_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.Condition.excluded)
}
inline void Condition::set_excluded(int index, const char* value, size_t size) {
  excluded_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.Condition.excluded)
}
inline std::string* Condition::_internal_add_excluded() {
  return excluded_.Add();
}
inline void Condition::add_excluded(const std::string& value) {
  excluded_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.Condition.excluded)
}
inline void Condition::add_excluded(std::string&& value) {
  excluded_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.Condition.excluded)
}
inline void Condition::add_excluded(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  excluded_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.Condition.excluded)
}
inline void Condition::add_excluded(const char* value, size_t size) {
  excluded_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.Condition.excluded)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Condition::excluded() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.Condition.excluded)
  return excluded_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Condition::mutable_excluded() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.Condition.excluded)
  return &excluded_;
}

// optional .senseAD.rscl.idl.ConditionDetail or = 3;
inline bool Condition::_internal_has_or_() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || or__ != nullptr);
  return value;
}
inline bool Condition::has_or_() const {
  return _internal_has_or_();
}
inline void Condition::clear_or_() {
  if (or__ != nullptr) or__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::senseAD::rscl::idl::ConditionDetail& Condition::_internal_or_() const {
  const ::senseAD::rscl::idl::ConditionDetail* p = or__;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::ConditionDetail&>(
      ::senseAD::rscl::idl::_ConditionDetail_default_instance_);
}
inline const ::senseAD::rscl::idl::ConditionDetail& Condition::or_() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.Condition.or)
  return _internal_or_();
}
inline void Condition::unsafe_arena_set_allocated_or_(
    ::senseAD::rscl::idl::ConditionDetail* or_) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(or__);
  }
  or__ = or_;
  if (or_) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.Condition.or)
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::release_or_() {
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::ConditionDetail* temp = or__;
  or__ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::unsafe_arena_release_or_() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.Condition.or)
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::ConditionDetail* temp = or__;
  or__ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::_internal_mutable_or_() {
  _has_bits_[0] |= 0x00000001u;
  if (or__ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::ConditionDetail>(GetArena());
    or__ = p;
  }
  return or__;
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::mutable_or_() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.Condition.or)
  return _internal_mutable_or_();
}
inline void Condition::set_allocated_or_(::senseAD::rscl::idl::ConditionDetail* or_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete or__;
  }
  if (or_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(or_);
    if (message_arena != submessage_arena) {
      or_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, or_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  or__ = or_;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.Condition.or)
}

// optional .senseAD.rscl.idl.ConditionDetail and = 4;
inline bool Condition::_internal_has_and_() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || and__ != nullptr);
  return value;
}
inline bool Condition::has_and_() const {
  return _internal_has_and_();
}
inline void Condition::clear_and_() {
  if (and__ != nullptr) and__->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::senseAD::rscl::idl::ConditionDetail& Condition::_internal_and_() const {
  const ::senseAD::rscl::idl::ConditionDetail* p = and__;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::ConditionDetail&>(
      ::senseAD::rscl::idl::_ConditionDetail_default_instance_);
}
inline const ::senseAD::rscl::idl::ConditionDetail& Condition::and_() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.Condition.and)
  return _internal_and_();
}
inline void Condition::unsafe_arena_set_allocated_and_(
    ::senseAD::rscl::idl::ConditionDetail* and_) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(and__);
  }
  and__ = and_;
  if (and_) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.Condition.and)
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::release_and_() {
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::ConditionDetail* temp = and__;
  and__ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::unsafe_arena_release_and_() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.Condition.and)
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::ConditionDetail* temp = and__;
  and__ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::_internal_mutable_and_() {
  _has_bits_[0] |= 0x00000002u;
  if (and__ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::ConditionDetail>(GetArena());
    and__ = p;
  }
  return and__;
}
inline ::senseAD::rscl::idl::ConditionDetail* Condition::mutable_and_() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.Condition.and)
  return _internal_mutable_and_();
}
inline void Condition::set_allocated_and_(::senseAD::rscl::idl::ConditionDetail* and_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete and__;
  }
  if (and_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(and_);
    if (message_arena != submessage_arena) {
      and_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, and_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  and__ = and_;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.Condition.and)
}

// -------------------------------------------------------------------

// Extend

// optional .senseAD.rscl.idl.Condition condition = 1;
inline bool Extend::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool Extend::has_condition() const {
  return _internal_has_condition();
}
inline void Extend::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::senseAD::rscl::idl::Condition& Extend::_internal_condition() const {
  const ::senseAD::rscl::idl::Condition* p = condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::Condition&>(
      ::senseAD::rscl::idl::_Condition_default_instance_);
}
inline const ::senseAD::rscl::idl::Condition& Extend::condition() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.Extend.condition)
  return _internal_condition();
}
inline void Extend::unsafe_arena_set_allocated_condition(
    ::senseAD::rscl::idl::Condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.Extend.condition)
}
inline ::senseAD::rscl::idl::Condition* Extend::release_condition() {
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::Condition* temp = condition_;
  condition_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::Condition* Extend::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.Extend.condition)
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::Condition* Extend::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000002u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::Condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::senseAD::rscl::idl::Condition* Extend::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.Extend.condition)
  return _internal_mutable_condition();
}
inline void Extend::set_allocated_condition(::senseAD::rscl::idl::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.Extend.condition)
}

// required string pb_file = 2;
inline bool Extend::_internal_has_pb_file() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Extend::has_pb_file() const {
  return _internal_has_pb_file();
}
inline void Extend::clear_pb_file() {
  pb_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extend::pb_file() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.Extend.pb_file)
  return _internal_pb_file();
}
inline void Extend::set_pb_file(const std::string& value) {
  _internal_set_pb_file(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.Extend.pb_file)
}
inline std::string* Extend::mutable_pb_file() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.Extend.pb_file)
  return _internal_mutable_pb_file();
}
inline const std::string& Extend::_internal_pb_file() const {
  return pb_file_.Get();
}
inline void Extend::_internal_set_pb_file(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pb_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Extend::set_pb_file(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pb_file_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.Extend.pb_file)
}
inline void Extend::set_pb_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pb_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.Extend.pb_file)
}
inline void Extend::set_pb_file(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pb_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.Extend.pb_file)
}
inline std::string* Extend::_internal_mutable_pb_file() {
  _has_bits_[0] |= 0x00000001u;
  return pb_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Extend::release_pb_file() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.Extend.pb_file)
  if (!_internal_has_pb_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pb_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Extend::set_allocated_pb_file(std::string* pb_file) {
  if (pb_file != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pb_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pb_file,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.Extend.pb_file)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EnvGroup

// optional .senseAD.rscl.idl.Condition condition = 1;
inline bool EnvGroup::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool EnvGroup::has_condition() const {
  return _internal_has_condition();
}
inline void EnvGroup::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::senseAD::rscl::idl::Condition& EnvGroup::_internal_condition() const {
  const ::senseAD::rscl::idl::Condition* p = condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::Condition&>(
      ::senseAD::rscl::idl::_Condition_default_instance_);
}
inline const ::senseAD::rscl::idl::Condition& EnvGroup::condition() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.EnvGroup.condition)
  return _internal_condition();
}
inline void EnvGroup::unsafe_arena_set_allocated_condition(
    ::senseAD::rscl::idl::Condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.EnvGroup.condition)
}
inline ::senseAD::rscl::idl::Condition* EnvGroup::release_condition() {
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::Condition* temp = condition_;
  condition_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::Condition* EnvGroup::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.EnvGroup.condition)
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::Condition* EnvGroup::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::Condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::senseAD::rscl::idl::Condition* EnvGroup::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.EnvGroup.condition)
  return _internal_mutable_condition();
}
inline void EnvGroup::set_allocated_condition(::senseAD::rscl::idl::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.EnvGroup.condition)
}

// map<string, string> env = 2;
inline int EnvGroup::_internal_env_size() const {
  return env_.size();
}
inline int EnvGroup::env_size() const {
  return _internal_env_size();
}
inline void EnvGroup::clear_env() {
  env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
EnvGroup::_internal_env() const {
  return env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
EnvGroup::env() const {
  // @@protoc_insertion_point(field_map:senseAD.rscl.idl.EnvGroup.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
EnvGroup::_internal_mutable_env() {
  return env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
EnvGroup::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:senseAD.rscl.idl.EnvGroup.env)
  return _internal_mutable_env();
}

// -------------------------------------------------------------------

// HeteroChannelConfig

// required .senseAD.rscl.idl.SupportedHeteroChannel type = 1;
inline bool HeteroChannelConfig::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeteroChannelConfig::has_type() const {
  return _internal_has_type();
}
inline void HeteroChannelConfig::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::senseAD::rscl::idl::SupportedHeteroChannel HeteroChannelConfig::_internal_type() const {
  return static_cast< ::senseAD::rscl::idl::SupportedHeteroChannel >(type_);
}
inline ::senseAD::rscl::idl::SupportedHeteroChannel HeteroChannelConfig::type() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.HeteroChannelConfig.type)
  return _internal_type();
}
inline void HeteroChannelConfig::_internal_set_type(::senseAD::rscl::idl::SupportedHeteroChannel value) {
  assert(::senseAD::rscl::idl::SupportedHeteroChannel_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void HeteroChannelConfig::set_type(::senseAD::rscl::idl::SupportedHeteroChannel value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.HeteroChannelConfig.type)
}

// required string name = 2;
inline bool HeteroChannelConfig::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeteroChannelConfig::has_name() const {
  return _internal_has_name();
}
inline void HeteroChannelConfig::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeteroChannelConfig::name() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.HeteroChannelConfig.name)
  return _internal_name();
}
inline void HeteroChannelConfig::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.HeteroChannelConfig.name)
}
inline std::string* HeteroChannelConfig::mutable_name() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.HeteroChannelConfig.name)
  return _internal_mutable_name();
}
inline const std::string& HeteroChannelConfig::_internal_name() const {
  return name_.Get();
}
inline void HeteroChannelConfig::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HeteroChannelConfig::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.HeteroChannelConfig.name)
}
inline void HeteroChannelConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.HeteroChannelConfig.name)
}
inline void HeteroChannelConfig::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.HeteroChannelConfig.name)
}
inline std::string* HeteroChannelConfig::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HeteroChannelConfig::release_name() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.HeteroChannelConfig.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HeteroChannelConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.HeteroChannelConfig.name)
}

// repeated .google.protobuf.Any config = 3;
inline int HeteroChannelConfig::_internal_config_size() const {
  return config_.size();
}
inline int HeteroChannelConfig::config_size() const {
  return _internal_config_size();
}
inline PROTOBUF_NAMESPACE_ID::Any* HeteroChannelConfig::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.HeteroChannelConfig.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Any >*
HeteroChannelConfig::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.HeteroChannelConfig.config)
  return &config_;
}
inline const PROTOBUF_NAMESPACE_ID::Any& HeteroChannelConfig::_internal_config(int index) const {
  return config_.Get(index);
}
inline const PROTOBUF_NAMESPACE_ID::Any& HeteroChannelConfig::config(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.HeteroChannelConfig.config)
  return _internal_config(index);
}
inline PROTOBUF_NAMESPACE_ID::Any* HeteroChannelConfig::_internal_add_config() {
  return config_.Add();
}
inline PROTOBUF_NAMESPACE_ID::Any* HeteroChannelConfig::add_config() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.HeteroChannelConfig.config)
  return _internal_add_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Any >&
HeteroChannelConfig::config() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.HeteroChannelConfig.config)
  return config_;
}

// -------------------------------------------------------------------

// TopicHeteroChannelConfig

// required .senseAD.rscl.idl.TopicHeteroChannelConfig.EnabledSide enabled_side = 1;
inline bool TopicHeteroChannelConfig::_internal_has_enabled_side() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TopicHeteroChannelConfig::has_enabled_side() const {
  return _internal_has_enabled_side();
}
inline void TopicHeteroChannelConfig::clear_enabled_side() {
  enabled_side_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide TopicHeteroChannelConfig::_internal_enabled_side() const {
  return static_cast< ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide >(enabled_side_);
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide TopicHeteroChannelConfig::enabled_side() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_side)
  return _internal_enabled_side();
}
inline void TopicHeteroChannelConfig::_internal_set_enabled_side(::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide value) {
  assert(::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  enabled_side_ = value;
}
inline void TopicHeteroChannelConfig::set_enabled_side(::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide value) {
  _internal_set_enabled_side(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_side)
}

// required string enabled_hetero = 2;
inline bool TopicHeteroChannelConfig::_internal_has_enabled_hetero() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TopicHeteroChannelConfig::has_enabled_hetero() const {
  return _internal_has_enabled_hetero();
}
inline void TopicHeteroChannelConfig::clear_enabled_hetero() {
  enabled_hetero_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicHeteroChannelConfig::enabled_hetero() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
  return _internal_enabled_hetero();
}
inline void TopicHeteroChannelConfig::set_enabled_hetero(const std::string& value) {
  _internal_set_enabled_hetero(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
}
inline std::string* TopicHeteroChannelConfig::mutable_enabled_hetero() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
  return _internal_mutable_enabled_hetero();
}
inline const std::string& TopicHeteroChannelConfig::_internal_enabled_hetero() const {
  return enabled_hetero_.Get();
}
inline void TopicHeteroChannelConfig::_internal_set_enabled_hetero(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_hetero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TopicHeteroChannelConfig::set_enabled_hetero(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_hetero_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
}
inline void TopicHeteroChannelConfig::set_enabled_hetero(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enabled_hetero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
}
inline void TopicHeteroChannelConfig::set_enabled_hetero(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enabled_hetero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
}
inline std::string* TopicHeteroChannelConfig::_internal_mutable_enabled_hetero() {
  _has_bits_[0] |= 0x00000001u;
  return enabled_hetero_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TopicHeteroChannelConfig::release_enabled_hetero() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
  if (!_internal_has_enabled_hetero()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enabled_hetero_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TopicHeteroChannelConfig::set_allocated_enabled_hetero(std::string* enabled_hetero) {
  if (enabled_hetero != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enabled_hetero_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enabled_hetero,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.TopicHeteroChannelConfig.enabled_hetero)
}

// -------------------------------------------------------------------

// TopicHeteroChannelConfigs

// repeated .senseAD.rscl.idl.TopicHeteroChannelConfig config = 1;
inline int TopicHeteroChannelConfigs::_internal_config_size() const {
  return config_.size();
}
inline int TopicHeteroChannelConfigs::config_size() const {
  return _internal_config_size();
}
inline void TopicHeteroChannelConfigs::clear_config() {
  config_.Clear();
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfig* TopicHeteroChannelConfigs::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.TopicHeteroChannelConfigs.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicHeteroChannelConfig >*
TopicHeteroChannelConfigs::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.TopicHeteroChannelConfigs.config)
  return &config_;
}
inline const ::senseAD::rscl::idl::TopicHeteroChannelConfig& TopicHeteroChannelConfigs::_internal_config(int index) const {
  return config_.Get(index);
}
inline const ::senseAD::rscl::idl::TopicHeteroChannelConfig& TopicHeteroChannelConfigs::config(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.TopicHeteroChannelConfigs.config)
  return _internal_config(index);
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfig* TopicHeteroChannelConfigs::_internal_add_config() {
  return config_.Add();
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfig* TopicHeteroChannelConfigs::add_config() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.TopicHeteroChannelConfigs.config)
  return _internal_add_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicHeteroChannelConfig >&
TopicHeteroChannelConfigs::config() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.TopicHeteroChannelConfigs.config)
  return config_;
}

// -------------------------------------------------------------------

// InetBasedService

// optional string service_name = 1;
inline bool InetBasedService::_internal_has_service_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InetBasedService::has_service_name() const {
  return _internal_has_service_name();
}
inline void InetBasedService::clear_service_name() {
  service_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InetBasedService::service_name() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.InetBasedService.service_name)
  return _internal_service_name();
}
inline void InetBasedService::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.InetBasedService.service_name)
}
inline std::string* InetBasedService::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.InetBasedService.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& InetBasedService::_internal_service_name() const {
  return service_name_.Get();
}
inline void InetBasedService::_internal_set_service_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InetBasedService::set_service_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  service_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.InetBasedService.service_name)
}
inline void InetBasedService::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.InetBasedService.service_name)
}
inline void InetBasedService::set_service_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.InetBasedService.service_name)
}
inline std::string* InetBasedService::_internal_mutable_service_name() {
  _has_bits_[0] |= 0x00000001u;
  return service_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InetBasedService::release_service_name() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.InetBasedService.service_name)
  if (!_internal_has_service_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return service_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InetBasedService::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.InetBasedService.service_name)
}

// optional string ip = 2;
inline bool InetBasedService::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InetBasedService::has_ip() const {
  return _internal_has_ip();
}
inline void InetBasedService::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InetBasedService::ip() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.InetBasedService.ip)
  return _internal_ip();
}
inline void InetBasedService::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.InetBasedService.ip)
}
inline std::string* InetBasedService::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.InetBasedService.ip)
  return _internal_mutable_ip();
}
inline const std::string& InetBasedService::_internal_ip() const {
  return ip_.Get();
}
inline void InetBasedService::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InetBasedService::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.InetBasedService.ip)
}
inline void InetBasedService::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.InetBasedService.ip)
}
inline void InetBasedService::set_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.InetBasedService.ip)
}
inline std::string* InetBasedService::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000002u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InetBasedService::release_ip() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.InetBasedService.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InetBasedService::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.InetBasedService.ip)
}

// optional uint32 port = 3;
inline bool InetBasedService::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InetBasedService::has_port() const {
  return _internal_has_port();
}
inline void InetBasedService::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InetBasedService::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InetBasedService::port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.InetBasedService.port)
  return _internal_port();
}
inline void InetBasedService::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  port_ = value;
}
inline void InetBasedService::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.InetBasedService.port)
}

// -------------------------------------------------------------------

// BridgeConfig

// optional string topic_name = 1;
inline bool BridgeConfig::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BridgeConfig::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void BridgeConfig::clear_topic_name() {
  topic_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BridgeConfig::topic_name() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.BridgeConfig.topic_name)
  return _internal_topic_name();
}
inline void BridgeConfig::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.BridgeConfig.topic_name)
}
inline std::string* BridgeConfig::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.BridgeConfig.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& BridgeConfig::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void BridgeConfig::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BridgeConfig::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.BridgeConfig.topic_name)
}
inline void BridgeConfig::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.BridgeConfig.topic_name)
}
inline void BridgeConfig::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.BridgeConfig.topic_name)
}
inline std::string* BridgeConfig::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BridgeConfig::release_topic_name() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.BridgeConfig.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeConfig::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.BridgeConfig.topic_name)
}

// optional string instance_id = 2;
inline bool BridgeConfig::_internal_has_instance_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BridgeConfig::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void BridgeConfig::clear_instance_id() {
  instance_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BridgeConfig::instance_id() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.BridgeConfig.instance_id)
  return _internal_instance_id();
}
inline void BridgeConfig::set_instance_id(const std::string& value) {
  _internal_set_instance_id(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.BridgeConfig.instance_id)
}
inline std::string* BridgeConfig::mutable_instance_id() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.BridgeConfig.instance_id)
  return _internal_mutable_instance_id();
}
inline const std::string& BridgeConfig::_internal_instance_id() const {
  return instance_id_.Get();
}
inline void BridgeConfig::_internal_set_instance_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BridgeConfig::set_instance_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  instance_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.BridgeConfig.instance_id)
}
inline void BridgeConfig::set_instance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.BridgeConfig.instance_id)
}
inline void BridgeConfig::set_instance_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.BridgeConfig.instance_id)
}
inline std::string* BridgeConfig::_internal_mutable_instance_id() {
  _has_bits_[0] |= 0x00000002u;
  return instance_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BridgeConfig::release_instance_id() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.BridgeConfig.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return instance_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeConfig::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  instance_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.BridgeConfig.instance_id)
}

// optional string instance_specifier = 3;
inline bool BridgeConfig::_internal_has_instance_specifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BridgeConfig::has_instance_specifier() const {
  return _internal_has_instance_specifier();
}
inline void BridgeConfig::clear_instance_specifier() {
  instance_specifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BridgeConfig::instance_specifier() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.BridgeConfig.instance_specifier)
  return _internal_instance_specifier();
}
inline void BridgeConfig::set_instance_specifier(const std::string& value) {
  _internal_set_instance_specifier(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.BridgeConfig.instance_specifier)
}
inline std::string* BridgeConfig::mutable_instance_specifier() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.BridgeConfig.instance_specifier)
  return _internal_mutable_instance_specifier();
}
inline const std::string& BridgeConfig::_internal_instance_specifier() const {
  return instance_specifier_.Get();
}
inline void BridgeConfig::_internal_set_instance_specifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  instance_specifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BridgeConfig::set_instance_specifier(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  instance_specifier_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.BridgeConfig.instance_specifier)
}
inline void BridgeConfig::set_instance_specifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  instance_specifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.BridgeConfig.instance_specifier)
}
inline void BridgeConfig::set_instance_specifier(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  instance_specifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.BridgeConfig.instance_specifier)
}
inline std::string* BridgeConfig::_internal_mutable_instance_specifier() {
  _has_bits_[0] |= 0x00000004u;
  return instance_specifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BridgeConfig::release_instance_specifier() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.BridgeConfig.instance_specifier)
  if (!_internal_has_instance_specifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return instance_specifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeConfig::set_allocated_instance_specifier(std::string* instance_specifier) {
  if (instance_specifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  instance_specifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance_specifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.BridgeConfig.instance_specifier)
}

// optional string msg_type = 4;
inline bool BridgeConfig::_internal_has_msg_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BridgeConfig::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void BridgeConfig::clear_msg_type() {
  msg_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BridgeConfig::msg_type() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.BridgeConfig.msg_type)
  return _internal_msg_type();
}
inline void BridgeConfig::set_msg_type(const std::string& value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.BridgeConfig.msg_type)
}
inline std::string* BridgeConfig::mutable_msg_type() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.BridgeConfig.msg_type)
  return _internal_mutable_msg_type();
}
inline const std::string& BridgeConfig::_internal_msg_type() const {
  return msg_type_.Get();
}
inline void BridgeConfig::_internal_set_msg_type(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  msg_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BridgeConfig::set_msg_type(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  msg_type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.BridgeConfig.msg_type)
}
inline void BridgeConfig::set_msg_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  msg_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.BridgeConfig.msg_type)
}
inline void BridgeConfig::set_msg_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  msg_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.BridgeConfig.msg_type)
}
inline std::string* BridgeConfig::_internal_mutable_msg_type() {
  _has_bits_[0] |= 0x00000008u;
  return msg_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BridgeConfig::release_msg_type() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.BridgeConfig.msg_type)
  if (!_internal_has_msg_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return msg_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeConfig::set_allocated_msg_type(std::string* msg_type) {
  if (msg_type != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  msg_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.BridgeConfig.msg_type)
}

// optional string dynamic_lib_path = 5;
inline bool BridgeConfig::_internal_has_dynamic_lib_path() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BridgeConfig::has_dynamic_lib_path() const {
  return _internal_has_dynamic_lib_path();
}
inline void BridgeConfig::clear_dynamic_lib_path() {
  dynamic_lib_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BridgeConfig::dynamic_lib_path() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
  return _internal_dynamic_lib_path();
}
inline void BridgeConfig::set_dynamic_lib_path(const std::string& value) {
  _internal_set_dynamic_lib_path(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
}
inline std::string* BridgeConfig::mutable_dynamic_lib_path() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
  return _internal_mutable_dynamic_lib_path();
}
inline const std::string& BridgeConfig::_internal_dynamic_lib_path() const {
  return dynamic_lib_path_.Get();
}
inline void BridgeConfig::_internal_set_dynamic_lib_path(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  dynamic_lib_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BridgeConfig::set_dynamic_lib_path(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  dynamic_lib_path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
}
inline void BridgeConfig::set_dynamic_lib_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  dynamic_lib_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
}
inline void BridgeConfig::set_dynamic_lib_path(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  dynamic_lib_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
}
inline std::string* BridgeConfig::_internal_mutable_dynamic_lib_path() {
  _has_bits_[0] |= 0x00000010u;
  return dynamic_lib_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BridgeConfig::release_dynamic_lib_path() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
  if (!_internal_has_dynamic_lib_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return dynamic_lib_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeConfig::set_allocated_dynamic_lib_path(std::string* dynamic_lib_path) {
  if (dynamic_lib_path != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  dynamic_lib_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dynamic_lib_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.BridgeConfig.dynamic_lib_path)
}

// -------------------------------------------------------------------

// TopicConfig

// required string topic_name = 1;
inline bool TopicConfig::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TopicConfig::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void TopicConfig::clear_topic_name() {
  topic_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicConfig::topic_name() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.TopicConfig.topic_name)
  return _internal_topic_name();
}
inline void TopicConfig::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.TopicConfig.topic_name)
}
inline std::string* TopicConfig::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.TopicConfig.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& TopicConfig::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void TopicConfig::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TopicConfig::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.TopicConfig.topic_name)
}
inline void TopicConfig::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.TopicConfig.topic_name)
}
inline void TopicConfig::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.TopicConfig.topic_name)
}
inline std::string* TopicConfig::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TopicConfig::release_topic_name() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.TopicConfig.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TopicConfig::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.TopicConfig.topic_name)
}

// optional .senseAD.rscl.idl.TopicHeteroChannelConfigs topic_specific_hetero_configs = 2;
inline bool TopicConfig::_internal_has_topic_specific_hetero_configs() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || topic_specific_hetero_configs_ != nullptr);
  return value;
}
inline bool TopicConfig::has_topic_specific_hetero_configs() const {
  return _internal_has_topic_specific_hetero_configs();
}
inline void TopicConfig::clear_topic_specific_hetero_configs() {
  if (topic_specific_hetero_configs_ != nullptr) topic_specific_hetero_configs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::senseAD::rscl::idl::TopicHeteroChannelConfigs& TopicConfig::_internal_topic_specific_hetero_configs() const {
  const ::senseAD::rscl::idl::TopicHeteroChannelConfigs* p = topic_specific_hetero_configs_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::TopicHeteroChannelConfigs&>(
      ::senseAD::rscl::idl::_TopicHeteroChannelConfigs_default_instance_);
}
inline const ::senseAD::rscl::idl::TopicHeteroChannelConfigs& TopicConfig::topic_specific_hetero_configs() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.TopicConfig.topic_specific_hetero_configs)
  return _internal_topic_specific_hetero_configs();
}
inline void TopicConfig::unsafe_arena_set_allocated_topic_specific_hetero_configs(
    ::senseAD::rscl::idl::TopicHeteroChannelConfigs* topic_specific_hetero_configs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_specific_hetero_configs_);
  }
  topic_specific_hetero_configs_ = topic_specific_hetero_configs;
  if (topic_specific_hetero_configs) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.TopicConfig.topic_specific_hetero_configs)
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfigs* TopicConfig::release_topic_specific_hetero_configs() {
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* temp = topic_specific_hetero_configs_;
  topic_specific_hetero_configs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfigs* TopicConfig::unsafe_arena_release_topic_specific_hetero_configs() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.TopicConfig.topic_specific_hetero_configs)
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::TopicHeteroChannelConfigs* temp = topic_specific_hetero_configs_;
  topic_specific_hetero_configs_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfigs* TopicConfig::_internal_mutable_topic_specific_hetero_configs() {
  _has_bits_[0] |= 0x00000002u;
  if (topic_specific_hetero_configs_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::TopicHeteroChannelConfigs>(GetArena());
    topic_specific_hetero_configs_ = p;
  }
  return topic_specific_hetero_configs_;
}
inline ::senseAD::rscl::idl::TopicHeteroChannelConfigs* TopicConfig::mutable_topic_specific_hetero_configs() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.TopicConfig.topic_specific_hetero_configs)
  return _internal_mutable_topic_specific_hetero_configs();
}
inline void TopicConfig::set_allocated_topic_specific_hetero_configs(::senseAD::rscl::idl::TopicHeteroChannelConfigs* topic_specific_hetero_configs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete topic_specific_hetero_configs_;
  }
  if (topic_specific_hetero_configs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(topic_specific_hetero_configs);
    if (message_arena != submessage_arena) {
      topic_specific_hetero_configs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic_specific_hetero_configs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  topic_specific_hetero_configs_ = topic_specific_hetero_configs;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.TopicConfig.topic_specific_hetero_configs)
}

// optional bool hetero_only = 3 [default = false];
inline bool TopicConfig::_internal_has_hetero_only() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TopicConfig::has_hetero_only() const {
  return _internal_has_hetero_only();
}
inline void TopicConfig::clear_hetero_only() {
  hetero_only_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TopicConfig::_internal_hetero_only() const {
  return hetero_only_;
}
inline bool TopicConfig::hetero_only() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.TopicConfig.hetero_only)
  return _internal_hetero_only();
}
inline void TopicConfig::_internal_set_hetero_only(bool value) {
  _has_bits_[0] |= 0x00000004u;
  hetero_only_ = value;
}
inline void TopicConfig::set_hetero_only(bool value) {
  _internal_set_hetero_only(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.TopicConfig.hetero_only)
}

// -------------------------------------------------------------------

// CrossSystemEndpointConfig

// optional int32 packet_rate_limit = 1;
inline bool CrossSystemEndpointConfig::_internal_has_packet_rate_limit() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrossSystemEndpointConfig::has_packet_rate_limit() const {
  return _internal_has_packet_rate_limit();
}
inline void CrossSystemEndpointConfig::clear_packet_rate_limit() {
  packet_rate_limit_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CrossSystemEndpointConfig::_internal_packet_rate_limit() const {
  return packet_rate_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CrossSystemEndpointConfig::packet_rate_limit() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit)
  return _internal_packet_rate_limit();
}
inline void CrossSystemEndpointConfig::_internal_set_packet_rate_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  packet_rate_limit_ = value;
}
inline void CrossSystemEndpointConfig::set_packet_rate_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_packet_rate_limit(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit)
}

// repeated string packet_rate_limit_excluded_topic = 2;
inline int CrossSystemEndpointConfig::_internal_packet_rate_limit_excluded_topic_size() const {
  return packet_rate_limit_excluded_topic_.size();
}
inline int CrossSystemEndpointConfig::packet_rate_limit_excluded_topic_size() const {
  return _internal_packet_rate_limit_excluded_topic_size();
}
inline void CrossSystemEndpointConfig::clear_packet_rate_limit_excluded_topic() {
  packet_rate_limit_excluded_topic_.Clear();
}
inline std::string* CrossSystemEndpointConfig::add_packet_rate_limit_excluded_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  return _internal_add_packet_rate_limit_excluded_topic();
}
inline const std::string& CrossSystemEndpointConfig::_internal_packet_rate_limit_excluded_topic(int index) const {
  return packet_rate_limit_excluded_topic_.Get(index);
}
inline const std::string& CrossSystemEndpointConfig::packet_rate_limit_excluded_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  return _internal_packet_rate_limit_excluded_topic(index);
}
inline std::string* CrossSystemEndpointConfig::mutable_packet_rate_limit_excluded_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  return packet_rate_limit_excluded_topic_.Mutable(index);
}
inline void CrossSystemEndpointConfig::set_packet_rate_limit_excluded_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  packet_rate_limit_excluded_topic_.Mutable(index)->assign(value);
}
inline void CrossSystemEndpointConfig::set_packet_rate_limit_excluded_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  packet_rate_limit_excluded_topic_.Mutable(index)->assign(std::move(value));
}
inline void CrossSystemEndpointConfig::set_packet_rate_limit_excluded_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  packet_rate_limit_excluded_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
}
inline void CrossSystemEndpointConfig::set_packet_rate_limit_excluded_topic(int index, const char* value, size_t size) {
  packet_rate_limit_excluded_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
}
inline std::string* CrossSystemEndpointConfig::_internal_add_packet_rate_limit_excluded_topic() {
  return packet_rate_limit_excluded_topic_.Add();
}
inline void CrossSystemEndpointConfig::add_packet_rate_limit_excluded_topic(const std::string& value) {
  packet_rate_limit_excluded_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
}
inline void CrossSystemEndpointConfig::add_packet_rate_limit_excluded_topic(std::string&& value) {
  packet_rate_limit_excluded_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
}
inline void CrossSystemEndpointConfig::add_packet_rate_limit_excluded_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  packet_rate_limit_excluded_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
}
inline void CrossSystemEndpointConfig::add_packet_rate_limit_excluded_topic(const char* value, size_t size) {
  packet_rate_limit_excluded_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossSystemEndpointConfig::packet_rate_limit_excluded_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  return packet_rate_limit_excluded_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossSystemEndpointConfig::mutable_packet_rate_limit_excluded_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CrossSystemEndpointConfig.packet_rate_limit_excluded_topic)
  return &packet_rate_limit_excluded_topic_;
}

// optional uint32 send_thread_num = 3 [default = 4];
inline bool CrossSystemEndpointConfig::_internal_has_send_thread_num() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrossSystemEndpointConfig::has_send_thread_num() const {
  return _internal_has_send_thread_num();
}
inline void CrossSystemEndpointConfig::clear_send_thread_num() {
  send_thread_num_ = 4u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemEndpointConfig::_internal_send_thread_num() const {
  return send_thread_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemEndpointConfig::send_thread_num() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpointConfig.send_thread_num)
  return _internal_send_thread_num();
}
inline void CrossSystemEndpointConfig::_internal_set_send_thread_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  send_thread_num_ = value;
}
inline void CrossSystemEndpointConfig::set_send_thread_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_send_thread_num(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpointConfig.send_thread_num)
}

// optional bool non_blocking_send = 4 [default = false];
inline bool CrossSystemEndpointConfig::_internal_has_non_blocking_send() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrossSystemEndpointConfig::has_non_blocking_send() const {
  return _internal_has_non_blocking_send();
}
inline void CrossSystemEndpointConfig::clear_non_blocking_send() {
  non_blocking_send_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CrossSystemEndpointConfig::_internal_non_blocking_send() const {
  return non_blocking_send_;
}
inline bool CrossSystemEndpointConfig::non_blocking_send() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpointConfig.non_blocking_send)
  return _internal_non_blocking_send();
}
inline void CrossSystemEndpointConfig::_internal_set_non_blocking_send(bool value) {
  _has_bits_[0] |= 0x00000002u;
  non_blocking_send_ = value;
}
inline void CrossSystemEndpointConfig::set_non_blocking_send(bool value) {
  _internal_set_non_blocking_send(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpointConfig.non_blocking_send)
}

// optional bool send_thread_debug = 5 [default = false];
inline bool CrossSystemEndpointConfig::_internal_has_send_thread_debug() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrossSystemEndpointConfig::has_send_thread_debug() const {
  return _internal_has_send_thread_debug();
}
inline void CrossSystemEndpointConfig::clear_send_thread_debug() {
  send_thread_debug_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CrossSystemEndpointConfig::_internal_send_thread_debug() const {
  return send_thread_debug_;
}
inline bool CrossSystemEndpointConfig::send_thread_debug() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpointConfig.send_thread_debug)
  return _internal_send_thread_debug();
}
inline void CrossSystemEndpointConfig::_internal_set_send_thread_debug(bool value) {
  _has_bits_[0] |= 0x00000004u;
  send_thread_debug_ = value;
}
inline void CrossSystemEndpointConfig::set_send_thread_debug(bool value) {
  _internal_set_send_thread_debug(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpointConfig.send_thread_debug)
}

// -------------------------------------------------------------------

// CrossSystemStatReportConfig

// optional bool enable = 1 [default = false];
inline bool CrossSystemStatReportConfig::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrossSystemStatReportConfig::has_enable() const {
  return _internal_has_enable();
}
inline void CrossSystemStatReportConfig::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CrossSystemStatReportConfig::_internal_enable() const {
  return enable_;
}
inline bool CrossSystemStatReportConfig::enable() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemStatReportConfig.enable)
  return _internal_enable();
}
inline void CrossSystemStatReportConfig::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_ = value;
}
inline void CrossSystemStatReportConfig::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemStatReportConfig.enable)
}

// optional uint32 sample_interval = 50 [default = 50];
inline bool CrossSystemStatReportConfig::_internal_has_sample_interval() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrossSystemStatReportConfig::has_sample_interval() const {
  return _internal_has_sample_interval();
}
inline void CrossSystemStatReportConfig::clear_sample_interval() {
  sample_interval_ = 50u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemStatReportConfig::_internal_sample_interval() const {
  return sample_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemStatReportConfig::sample_interval() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemStatReportConfig.sample_interval)
  return _internal_sample_interval();
}
inline void CrossSystemStatReportConfig::_internal_set_sample_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sample_interval_ = value;
}
inline void CrossSystemStatReportConfig::set_sample_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sample_interval(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemStatReportConfig.sample_interval)
}

// optional uint32 report_interval = 1000 [default = 1000];
inline bool CrossSystemStatReportConfig::_internal_has_report_interval() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrossSystemStatReportConfig::has_report_interval() const {
  return _internal_has_report_interval();
}
inline void CrossSystemStatReportConfig::clear_report_interval() {
  report_interval_ = 1000u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemStatReportConfig::_internal_report_interval() const {
  return report_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemStatReportConfig::report_interval() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemStatReportConfig.report_interval)
  return _internal_report_interval();
}
inline void CrossSystemStatReportConfig::_internal_set_report_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  report_interval_ = value;
}
inline void CrossSystemStatReportConfig::set_report_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_report_interval(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemStatReportConfig.report_interval)
}

// -------------------------------------------------------------------

// CrossSystemEndpoint

// required string hostname = 1;
inline bool CrossSystemEndpoint::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrossSystemEndpoint::has_hostname() const {
  return _internal_has_hostname();
}
inline void CrossSystemEndpoint::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrossSystemEndpoint::hostname() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
  return _internal_hostname();
}
inline void CrossSystemEndpoint::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
}
inline std::string* CrossSystemEndpoint::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
  return _internal_mutable_hostname();
}
inline const std::string& CrossSystemEndpoint::_internal_hostname() const {
  return hostname_.Get();
}
inline void CrossSystemEndpoint::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CrossSystemEndpoint::set_hostname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
}
inline void CrossSystemEndpoint::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
}
inline void CrossSystemEndpoint::set_hostname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
}
inline std::string* CrossSystemEndpoint::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CrossSystemEndpoint::release_hostname() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hostname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CrossSystemEndpoint::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CrossSystemEndpoint.hostname)
}

// required string ip = 2;
inline bool CrossSystemEndpoint::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrossSystemEndpoint::has_ip() const {
  return _internal_has_ip();
}
inline void CrossSystemEndpoint::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrossSystemEndpoint::ip() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpoint.ip)
  return _internal_ip();
}
inline void CrossSystemEndpoint::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpoint.ip)
}
inline std::string* CrossSystemEndpoint::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemEndpoint.ip)
  return _internal_mutable_ip();
}
inline const std::string& CrossSystemEndpoint::_internal_ip() const {
  return ip_.Get();
}
inline void CrossSystemEndpoint::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CrossSystemEndpoint::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.CrossSystemEndpoint.ip)
}
inline void CrossSystemEndpoint::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemEndpoint.ip)
}
inline void CrossSystemEndpoint::set_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemEndpoint.ip)
}
inline std::string* CrossSystemEndpoint::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000002u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CrossSystemEndpoint::release_ip() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CrossSystemEndpoint.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CrossSystemEndpoint::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CrossSystemEndpoint.ip)
}

// optional uint32 port = 3 [default = 5432];
inline bool CrossSystemEndpoint::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrossSystemEndpoint::has_port() const {
  return _internal_has_port();
}
inline void CrossSystemEndpoint::clear_port() {
  port_ = 5432u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemEndpoint::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemEndpoint::port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpoint.port)
  return _internal_port();
}
inline void CrossSystemEndpoint::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  port_ = value;
}
inline void CrossSystemEndpoint::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpoint.port)
}

// optional .senseAD.rscl.idl.CrossSystemEndpointConfig config = 4;
inline bool CrossSystemEndpoint::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool CrossSystemEndpoint::has_config() const {
  return _internal_has_config();
}
inline void CrossSystemEndpoint::clear_config() {
  if (config_ != nullptr) config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::senseAD::rscl::idl::CrossSystemEndpointConfig& CrossSystemEndpoint::_internal_config() const {
  const ::senseAD::rscl::idl::CrossSystemEndpointConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::CrossSystemEndpointConfig&>(
      ::senseAD::rscl::idl::_CrossSystemEndpointConfig_default_instance_);
}
inline const ::senseAD::rscl::idl::CrossSystemEndpointConfig& CrossSystemEndpoint::config() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpoint.config)
  return _internal_config();
}
inline void CrossSystemEndpoint::unsafe_arena_set_allocated_config(
    ::senseAD::rscl::idl::CrossSystemEndpointConfig* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.CrossSystemEndpoint.config)
}
inline ::senseAD::rscl::idl::CrossSystemEndpointConfig* CrossSystemEndpoint::release_config() {
  _has_bits_[0] &= ~0x00000004u;
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* temp = config_;
  config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemEndpointConfig* CrossSystemEndpoint::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CrossSystemEndpoint.config)
  _has_bits_[0] &= ~0x00000004u;
  ::senseAD::rscl::idl::CrossSystemEndpointConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemEndpointConfig* CrossSystemEndpoint::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000004u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemEndpointConfig>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::senseAD::rscl::idl::CrossSystemEndpointConfig* CrossSystemEndpoint::mutable_config() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemEndpoint.config)
  return _internal_mutable_config();
}
inline void CrossSystemEndpoint::set_allocated_config(::senseAD::rscl::idl::CrossSystemEndpointConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CrossSystemEndpoint.config)
}

// optional uint32 summary_service_port = 5 [default = 5453];
inline bool CrossSystemEndpoint::_internal_has_summary_service_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CrossSystemEndpoint::has_summary_service_port() const {
  return _internal_has_summary_service_port();
}
inline void CrossSystemEndpoint::clear_summary_service_port() {
  summary_service_port_ = 5453u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemEndpoint::_internal_summary_service_port() const {
  return summary_service_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemEndpoint::summary_service_port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemEndpoint.summary_service_port)
  return _internal_summary_service_port();
}
inline void CrossSystemEndpoint::_internal_set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  summary_service_port_ = value;
}
inline void CrossSystemEndpoint::set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_summary_service_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemEndpoint.summary_service_port)
}

// -------------------------------------------------------------------

// CrossSystemConfig

// required string hostname = 1;
inline bool CrossSystemConfig::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrossSystemConfig::has_hostname() const {
  return _internal_has_hostname();
}
inline void CrossSystemConfig::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrossSystemConfig::hostname() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.hostname)
  return _internal_hostname();
}
inline void CrossSystemConfig::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.hostname)
}
inline std::string* CrossSystemConfig::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.hostname)
  return _internal_mutable_hostname();
}
inline const std::string& CrossSystemConfig::_internal_hostname() const {
  return hostname_.Get();
}
inline void CrossSystemConfig::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CrossSystemConfig::set_hostname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.CrossSystemConfig.hostname)
}
inline void CrossSystemConfig::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemConfig.hostname)
}
inline void CrossSystemConfig::set_hostname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemConfig.hostname)
}
inline std::string* CrossSystemConfig::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CrossSystemConfig::release_hostname() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CrossSystemConfig.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hostname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CrossSystemConfig::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CrossSystemConfig.hostname)
}

// optional .senseAD.rscl.idl.CrossSystemMode mode = 2 [default = STATIC_PEER];
inline bool CrossSystemConfig::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrossSystemConfig::has_mode() const {
  return _internal_has_mode();
}
inline void CrossSystemConfig::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::senseAD::rscl::idl::CrossSystemMode CrossSystemConfig::_internal_mode() const {
  return static_cast< ::senseAD::rscl::idl::CrossSystemMode >(mode_);
}
inline ::senseAD::rscl::idl::CrossSystemMode CrossSystemConfig::mode() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.mode)
  return _internal_mode();
}
inline void CrossSystemConfig::_internal_set_mode(::senseAD::rscl::idl::CrossSystemMode value) {
  assert(::senseAD::rscl::idl::CrossSystemMode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  mode_ = value;
}
inline void CrossSystemConfig::set_mode(::senseAD::rscl::idl::CrossSystemMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.mode)
}

// repeated .senseAD.rscl.idl.CrossSystemEndpoint endpoint = 3;
inline int CrossSystemConfig::_internal_endpoint_size() const {
  return endpoint_.size();
}
inline int CrossSystemConfig::endpoint_size() const {
  return _internal_endpoint_size();
}
inline void CrossSystemConfig::clear_endpoint() {
  endpoint_.Clear();
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CrossSystemConfig::mutable_endpoint(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.endpoint)
  return endpoint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CrossSystemEndpoint >*
CrossSystemConfig::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CrossSystemConfig.endpoint)
  return &endpoint_;
}
inline const ::senseAD::rscl::idl::CrossSystemEndpoint& CrossSystemConfig::_internal_endpoint(int index) const {
  return endpoint_.Get(index);
}
inline const ::senseAD::rscl::idl::CrossSystemEndpoint& CrossSystemConfig::endpoint(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.endpoint)
  return _internal_endpoint(index);
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CrossSystemConfig::_internal_add_endpoint() {
  return endpoint_.Add();
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CrossSystemConfig::add_endpoint() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.endpoint)
  return _internal_add_endpoint();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CrossSystemEndpoint >&
CrossSystemConfig::endpoint() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CrossSystemConfig.endpoint)
  return endpoint_;
}

// repeated string excluded_topic = 4;
inline int CrossSystemConfig::_internal_excluded_topic_size() const {
  return excluded_topic_.size();
}
inline int CrossSystemConfig::excluded_topic_size() const {
  return _internal_excluded_topic_size();
}
inline void CrossSystemConfig::clear_excluded_topic() {
  excluded_topic_.Clear();
}
inline std::string* CrossSystemConfig::add_excluded_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  return _internal_add_excluded_topic();
}
inline const std::string& CrossSystemConfig::_internal_excluded_topic(int index) const {
  return excluded_topic_.Get(index);
}
inline const std::string& CrossSystemConfig::excluded_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  return _internal_excluded_topic(index);
}
inline std::string* CrossSystemConfig::mutable_excluded_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  return excluded_topic_.Mutable(index);
}
inline void CrossSystemConfig::set_excluded_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  excluded_topic_.Mutable(index)->assign(value);
}
inline void CrossSystemConfig::set_excluded_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  excluded_topic_.Mutable(index)->assign(std::move(value));
}
inline void CrossSystemConfig::set_excluded_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  excluded_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
}
inline void CrossSystemConfig::set_excluded_topic(int index, const char* value, size_t size) {
  excluded_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
}
inline std::string* CrossSystemConfig::_internal_add_excluded_topic() {
  return excluded_topic_.Add();
}
inline void CrossSystemConfig::add_excluded_topic(const std::string& value) {
  excluded_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
}
inline void CrossSystemConfig::add_excluded_topic(std::string&& value) {
  excluded_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
}
inline void CrossSystemConfig::add_excluded_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  excluded_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
}
inline void CrossSystemConfig::add_excluded_topic(const char* value, size_t size) {
  excluded_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossSystemConfig::excluded_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  return excluded_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossSystemConfig::mutable_excluded_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CrossSystemConfig.excluded_topic)
  return &excluded_topic_;
}

// repeated string whitelist_topic = 5;
inline int CrossSystemConfig::_internal_whitelist_topic_size() const {
  return whitelist_topic_.size();
}
inline int CrossSystemConfig::whitelist_topic_size() const {
  return _internal_whitelist_topic_size();
}
inline void CrossSystemConfig::clear_whitelist_topic() {
  whitelist_topic_.Clear();
}
inline std::string* CrossSystemConfig::add_whitelist_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  return _internal_add_whitelist_topic();
}
inline const std::string& CrossSystemConfig::_internal_whitelist_topic(int index) const {
  return whitelist_topic_.Get(index);
}
inline const std::string& CrossSystemConfig::whitelist_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  return _internal_whitelist_topic(index);
}
inline std::string* CrossSystemConfig::mutable_whitelist_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  return whitelist_topic_.Mutable(index);
}
inline void CrossSystemConfig::set_whitelist_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  whitelist_topic_.Mutable(index)->assign(value);
}
inline void CrossSystemConfig::set_whitelist_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  whitelist_topic_.Mutable(index)->assign(std::move(value));
}
inline void CrossSystemConfig::set_whitelist_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  whitelist_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
}
inline void CrossSystemConfig::set_whitelist_topic(int index, const char* value, size_t size) {
  whitelist_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
}
inline std::string* CrossSystemConfig::_internal_add_whitelist_topic() {
  return whitelist_topic_.Add();
}
inline void CrossSystemConfig::add_whitelist_topic(const std::string& value) {
  whitelist_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
}
inline void CrossSystemConfig::add_whitelist_topic(std::string&& value) {
  whitelist_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
}
inline void CrossSystemConfig::add_whitelist_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  whitelist_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
}
inline void CrossSystemConfig::add_whitelist_topic(const char* value, size_t size) {
  whitelist_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossSystemConfig::whitelist_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  return whitelist_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossSystemConfig::mutable_whitelist_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CrossSystemConfig.whitelist_topic)
  return &whitelist_topic_;
}

// repeated string outgoing_only_topic = 6;
inline int CrossSystemConfig::_internal_outgoing_only_topic_size() const {
  return outgoing_only_topic_.size();
}
inline int CrossSystemConfig::outgoing_only_topic_size() const {
  return _internal_outgoing_only_topic_size();
}
inline void CrossSystemConfig::clear_outgoing_only_topic() {
  outgoing_only_topic_.Clear();
}
inline std::string* CrossSystemConfig::add_outgoing_only_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  return _internal_add_outgoing_only_topic();
}
inline const std::string& CrossSystemConfig::_internal_outgoing_only_topic(int index) const {
  return outgoing_only_topic_.Get(index);
}
inline const std::string& CrossSystemConfig::outgoing_only_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  return _internal_outgoing_only_topic(index);
}
inline std::string* CrossSystemConfig::mutable_outgoing_only_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  return outgoing_only_topic_.Mutable(index);
}
inline void CrossSystemConfig::set_outgoing_only_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  outgoing_only_topic_.Mutable(index)->assign(value);
}
inline void CrossSystemConfig::set_outgoing_only_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  outgoing_only_topic_.Mutable(index)->assign(std::move(value));
}
inline void CrossSystemConfig::set_outgoing_only_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outgoing_only_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
}
inline void CrossSystemConfig::set_outgoing_only_topic(int index, const char* value, size_t size) {
  outgoing_only_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
}
inline std::string* CrossSystemConfig::_internal_add_outgoing_only_topic() {
  return outgoing_only_topic_.Add();
}
inline void CrossSystemConfig::add_outgoing_only_topic(const std::string& value) {
  outgoing_only_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
}
inline void CrossSystemConfig::add_outgoing_only_topic(std::string&& value) {
  outgoing_only_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
}
inline void CrossSystemConfig::add_outgoing_only_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outgoing_only_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
}
inline void CrossSystemConfig::add_outgoing_only_topic(const char* value, size_t size) {
  outgoing_only_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossSystemConfig::outgoing_only_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  return outgoing_only_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossSystemConfig::mutable_outgoing_only_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CrossSystemConfig.outgoing_only_topic)
  return &outgoing_only_topic_;
}

// optional .senseAD.rscl.idl.CrossSystemOutgoingPrefixMode outgoing_prefix_mode = 7 [default = ALL];
inline bool CrossSystemConfig::_internal_has_outgoing_prefix_mode() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrossSystemConfig::has_outgoing_prefix_mode() const {
  return _internal_has_outgoing_prefix_mode();
}
inline void CrossSystemConfig::clear_outgoing_prefix_mode() {
  outgoing_prefix_mode_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode CrossSystemConfig::_internal_outgoing_prefix_mode() const {
  return static_cast< ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode >(outgoing_prefix_mode_);
}
inline ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode CrossSystemConfig::outgoing_prefix_mode() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.outgoing_prefix_mode)
  return _internal_outgoing_prefix_mode();
}
inline void CrossSystemConfig::_internal_set_outgoing_prefix_mode(::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode value) {
  assert(::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  outgoing_prefix_mode_ = value;
}
inline void CrossSystemConfig::set_outgoing_prefix_mode(::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode value) {
  _internal_set_outgoing_prefix_mode(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.outgoing_prefix_mode)
}

// repeated string extra_common_topic = 8;
inline int CrossSystemConfig::_internal_extra_common_topic_size() const {
  return extra_common_topic_.size();
}
inline int CrossSystemConfig::extra_common_topic_size() const {
  return _internal_extra_common_topic_size();
}
inline void CrossSystemConfig::clear_extra_common_topic() {
  extra_common_topic_.Clear();
}
inline std::string* CrossSystemConfig::add_extra_common_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  return _internal_add_extra_common_topic();
}
inline const std::string& CrossSystemConfig::_internal_extra_common_topic(int index) const {
  return extra_common_topic_.Get(index);
}
inline const std::string& CrossSystemConfig::extra_common_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  return _internal_extra_common_topic(index);
}
inline std::string* CrossSystemConfig::mutable_extra_common_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  return extra_common_topic_.Mutable(index);
}
inline void CrossSystemConfig::set_extra_common_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  extra_common_topic_.Mutable(index)->assign(value);
}
inline void CrossSystemConfig::set_extra_common_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  extra_common_topic_.Mutable(index)->assign(std::move(value));
}
inline void CrossSystemConfig::set_extra_common_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  extra_common_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
}
inline void CrossSystemConfig::set_extra_common_topic(int index, const char* value, size_t size) {
  extra_common_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
}
inline std::string* CrossSystemConfig::_internal_add_extra_common_topic() {
  return extra_common_topic_.Add();
}
inline void CrossSystemConfig::add_extra_common_topic(const std::string& value) {
  extra_common_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
}
inline void CrossSystemConfig::add_extra_common_topic(std::string&& value) {
  extra_common_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
}
inline void CrossSystemConfig::add_extra_common_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  extra_common_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
}
inline void CrossSystemConfig::add_extra_common_topic(const char* value, size_t size) {
  extra_common_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossSystemConfig::extra_common_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  return extra_common_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossSystemConfig::mutable_extra_common_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CrossSystemConfig.extra_common_topic)
  return &extra_common_topic_;
}

// optional .senseAD.rscl.idl.CrossSystemStatReportConfig stat_report_config = 9;
inline bool CrossSystemConfig::_internal_has_stat_report_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || stat_report_config_ != nullptr);
  return value;
}
inline bool CrossSystemConfig::has_stat_report_config() const {
  return _internal_has_stat_report_config();
}
inline void CrossSystemConfig::clear_stat_report_config() {
  if (stat_report_config_ != nullptr) stat_report_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::senseAD::rscl::idl::CrossSystemStatReportConfig& CrossSystemConfig::_internal_stat_report_config() const {
  const ::senseAD::rscl::idl::CrossSystemStatReportConfig* p = stat_report_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::CrossSystemStatReportConfig&>(
      ::senseAD::rscl::idl::_CrossSystemStatReportConfig_default_instance_);
}
inline const ::senseAD::rscl::idl::CrossSystemStatReportConfig& CrossSystemConfig::stat_report_config() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.stat_report_config)
  return _internal_stat_report_config();
}
inline void CrossSystemConfig::unsafe_arena_set_allocated_stat_report_config(
    ::senseAD::rscl::idl::CrossSystemStatReportConfig* stat_report_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat_report_config_);
  }
  stat_report_config_ = stat_report_config;
  if (stat_report_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.CrossSystemConfig.stat_report_config)
}
inline ::senseAD::rscl::idl::CrossSystemStatReportConfig* CrossSystemConfig::release_stat_report_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* temp = stat_report_config_;
  stat_report_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemStatReportConfig* CrossSystemConfig::unsafe_arena_release_stat_report_config() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CrossSystemConfig.stat_report_config)
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::CrossSystemStatReportConfig* temp = stat_report_config_;
  stat_report_config_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemStatReportConfig* CrossSystemConfig::_internal_mutable_stat_report_config() {
  _has_bits_[0] |= 0x00000002u;
  if (stat_report_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemStatReportConfig>(GetArena());
    stat_report_config_ = p;
  }
  return stat_report_config_;
}
inline ::senseAD::rscl::idl::CrossSystemStatReportConfig* CrossSystemConfig::mutable_stat_report_config() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CrossSystemConfig.stat_report_config)
  return _internal_mutable_stat_report_config();
}
inline void CrossSystemConfig::set_allocated_stat_report_config(::senseAD::rscl::idl::CrossSystemStatReportConfig* stat_report_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stat_report_config_;
  }
  if (stat_report_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stat_report_config);
    if (message_arena != submessage_arena) {
      stat_report_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat_report_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stat_report_config_ = stat_report_config;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CrossSystemConfig.stat_report_config)
}

// optional uint32 query_service_port = 10 [default = 5452];
inline bool CrossSystemConfig::_internal_has_query_service_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CrossSystemConfig::has_query_service_port() const {
  return _internal_has_query_service_port();
}
inline void CrossSystemConfig::clear_query_service_port() {
  query_service_port_ = 5452u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemConfig::_internal_query_service_port() const {
  return query_service_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemConfig::query_service_port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.query_service_port)
  return _internal_query_service_port();
}
inline void CrossSystemConfig::_internal_set_query_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  query_service_port_ = value;
}
inline void CrossSystemConfig::set_query_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_query_service_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.query_service_port)
}

// optional uint32 summary_service_port = 11 [default = 5453];
inline bool CrossSystemConfig::_internal_has_summary_service_port() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CrossSystemConfig::has_summary_service_port() const {
  return _internal_has_summary_service_port();
}
inline void CrossSystemConfig::clear_summary_service_port() {
  summary_service_port_ = 5453u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemConfig::_internal_summary_service_port() const {
  return summary_service_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemConfig::summary_service_port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.summary_service_port)
  return _internal_summary_service_port();
}
inline void CrossSystemConfig::_internal_set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  summary_service_port_ = value;
}
inline void CrossSystemConfig::set_summary_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_summary_service_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.summary_service_port)
}

// optional uint32 distribute_service_port = 12 [default = 5454];
inline bool CrossSystemConfig::_internal_has_distribute_service_port() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CrossSystemConfig::has_distribute_service_port() const {
  return _internal_has_distribute_service_port();
}
inline void CrossSystemConfig::clear_distribute_service_port() {
  distribute_service_port_ = 5454u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemConfig::_internal_distribute_service_port() const {
  return distribute_service_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CrossSystemConfig::distribute_service_port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CrossSystemConfig.distribute_service_port)
  return _internal_distribute_service_port();
}
inline void CrossSystemConfig::_internal_set_distribute_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  distribute_service_port_ = value;
}
inline void CrossSystemConfig::set_distribute_service_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_distribute_service_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CrossSystemConfig.distribute_service_port)
}

// -------------------------------------------------------------------

// NodeConfig

// required string node_name = 1;
inline bool NodeConfig::_internal_has_node_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NodeConfig::has_node_name() const {
  return _internal_has_node_name();
}
inline void NodeConfig::clear_node_name() {
  node_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NodeConfig::node_name() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.NodeConfig.node_name)
  return _internal_node_name();
}
inline void NodeConfig::set_node_name(const std::string& value) {
  _internal_set_node_name(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.NodeConfig.node_name)
}
inline std::string* NodeConfig::mutable_node_name() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.NodeConfig.node_name)
  return _internal_mutable_node_name();
}
inline const std::string& NodeConfig::_internal_node_name() const {
  return node_name_.Get();
}
inline void NodeConfig::_internal_set_node_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeConfig::set_node_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.NodeConfig.node_name)
}
inline void NodeConfig::set_node_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.NodeConfig.node_name)
}
inline void NodeConfig::set_node_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.NodeConfig.node_name)
}
inline std::string* NodeConfig::_internal_mutable_node_name() {
  _has_bits_[0] |= 0x00000001u;
  return node_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeConfig::release_node_name() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.NodeConfig.node_name)
  if (!_internal_has_node_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeConfig::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.NodeConfig.node_name)
}

// repeated .senseAD.rscl.idl.TopicConfig node_specific_topic_config = 2;
inline int NodeConfig::_internal_node_specific_topic_config_size() const {
  return node_specific_topic_config_.size();
}
inline int NodeConfig::node_specific_topic_config_size() const {
  return _internal_node_specific_topic_config_size();
}
inline void NodeConfig::clear_node_specific_topic_config() {
  node_specific_topic_config_.Clear();
}
inline ::senseAD::rscl::idl::TopicConfig* NodeConfig::mutable_node_specific_topic_config(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.NodeConfig.node_specific_topic_config)
  return node_specific_topic_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicConfig >*
NodeConfig::mutable_node_specific_topic_config() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.NodeConfig.node_specific_topic_config)
  return &node_specific_topic_config_;
}
inline const ::senseAD::rscl::idl::TopicConfig& NodeConfig::_internal_node_specific_topic_config(int index) const {
  return node_specific_topic_config_.Get(index);
}
inline const ::senseAD::rscl::idl::TopicConfig& NodeConfig::node_specific_topic_config(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.NodeConfig.node_specific_topic_config)
  return _internal_node_specific_topic_config(index);
}
inline ::senseAD::rscl::idl::TopicConfig* NodeConfig::_internal_add_node_specific_topic_config() {
  return node_specific_topic_config_.Add();
}
inline ::senseAD::rscl::idl::TopicConfig* NodeConfig::add_node_specific_topic_config() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.NodeConfig.node_specific_topic_config)
  return _internal_add_node_specific_topic_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::TopicConfig >&
NodeConfig::node_specific_topic_config() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.NodeConfig.node_specific_topic_config)
  return node_specific_topic_config_;
}

// -------------------------------------------------------------------

// RuntimeConfig

// optional .senseAD.rscl.idl.Condition condition = 1;
inline bool RuntimeConfig::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool RuntimeConfig::has_condition() const {
  return _internal_has_condition();
}
inline void RuntimeConfig::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::senseAD::rscl::idl::Condition& RuntimeConfig::_internal_condition() const {
  const ::senseAD::rscl::idl::Condition* p = condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::Condition&>(
      ::senseAD::rscl::idl::_Condition_default_instance_);
}
inline const ::senseAD::rscl::idl::Condition& RuntimeConfig::condition() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.RuntimeConfig.condition)
  return _internal_condition();
}
inline void RuntimeConfig::unsafe_arena_set_allocated_condition(
    ::senseAD::rscl::idl::Condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.RuntimeConfig.condition)
}
inline ::senseAD::rscl::idl::Condition* RuntimeConfig::release_condition() {
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::Condition* temp = condition_;
  condition_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::Condition* RuntimeConfig::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.RuntimeConfig.condition)
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::Condition* RuntimeConfig::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::Condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::senseAD::rscl::idl::Condition* RuntimeConfig::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.RuntimeConfig.condition)
  return _internal_mutable_condition();
}
inline void RuntimeConfig::set_allocated_condition(::senseAD::rscl::idl::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.RuntimeConfig.condition)
}

// optional .senseAD.mw.proto.RuntimeConfig config = 2;
inline bool RuntimeConfig::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool RuntimeConfig::has_config() const {
  return _internal_has_config();
}
inline const ::senseAD::mw::proto::RuntimeConfig& RuntimeConfig::_internal_config() const {
  const ::senseAD::mw::proto::RuntimeConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::mw::proto::RuntimeConfig&>(
      ::senseAD::mw::proto::_RuntimeConfig_default_instance_);
}
inline const ::senseAD::mw::proto::RuntimeConfig& RuntimeConfig::config() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.RuntimeConfig.config)
  return _internal_config();
}
inline void RuntimeConfig::unsafe_arena_set_allocated_config(
    ::senseAD::mw::proto::RuntimeConfig* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.RuntimeConfig.config)
}
inline ::senseAD::mw::proto::RuntimeConfig* RuntimeConfig::release_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::mw::proto::RuntimeConfig* temp = config_;
  config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::mw::proto::RuntimeConfig* RuntimeConfig::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.RuntimeConfig.config)
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::mw::proto::RuntimeConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::senseAD::mw::proto::RuntimeConfig* RuntimeConfig::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000002u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::mw::proto::RuntimeConfig>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::senseAD::mw::proto::RuntimeConfig* RuntimeConfig::mutable_config() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.RuntimeConfig.config)
  return _internal_mutable_config();
}
inline void RuntimeConfig::set_allocated_config(::senseAD::mw::proto::RuntimeConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.RuntimeConfig.config)
}

// -------------------------------------------------------------------

// CommonBridgeClientConfig

// required .senseAD.rscl.idl.CrossSystemEndpoint endpoint = 1;
inline bool CommonBridgeClientConfig::_internal_has_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || endpoint_ != nullptr);
  return value;
}
inline bool CommonBridgeClientConfig::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void CommonBridgeClientConfig::clear_endpoint() {
  if (endpoint_ != nullptr) endpoint_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::senseAD::rscl::idl::CrossSystemEndpoint& CommonBridgeClientConfig::_internal_endpoint() const {
  const ::senseAD::rscl::idl::CrossSystemEndpoint* p = endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::CrossSystemEndpoint&>(
      ::senseAD::rscl::idl::_CrossSystemEndpoint_default_instance_);
}
inline const ::senseAD::rscl::idl::CrossSystemEndpoint& CommonBridgeClientConfig::endpoint() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeClientConfig.endpoint)
  return _internal_endpoint();
}
inline void CommonBridgeClientConfig::unsafe_arena_set_allocated_endpoint(
    ::senseAD::rscl::idl::CrossSystemEndpoint* endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint_);
  }
  endpoint_ = endpoint;
  if (endpoint) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.CommonBridgeClientConfig.endpoint)
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CommonBridgeClientConfig::release_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::CrossSystemEndpoint* temp = endpoint_;
  endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CommonBridgeClientConfig::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CommonBridgeClientConfig.endpoint)
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::CrossSystemEndpoint* temp = endpoint_;
  endpoint_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CommonBridgeClientConfig::_internal_mutable_endpoint() {
  _has_bits_[0] |= 0x00000001u;
  if (endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemEndpoint>(GetArena());
    endpoint_ = p;
  }
  return endpoint_;
}
inline ::senseAD::rscl::idl::CrossSystemEndpoint* CommonBridgeClientConfig::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CommonBridgeClientConfig.endpoint)
  return _internal_mutable_endpoint();
}
inline void CommonBridgeClientConfig::set_allocated_endpoint(::senseAD::rscl::idl::CrossSystemEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete endpoint_;
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(endpoint);
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CommonBridgeClientConfig.endpoint)
}

// repeated string excluded_topic = 2;
inline int CommonBridgeClientConfig::_internal_excluded_topic_size() const {
  return excluded_topic_.size();
}
inline int CommonBridgeClientConfig::excluded_topic_size() const {
  return _internal_excluded_topic_size();
}
inline void CommonBridgeClientConfig::clear_excluded_topic() {
  excluded_topic_.Clear();
}
inline std::string* CommonBridgeClientConfig::add_excluded_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  return _internal_add_excluded_topic();
}
inline const std::string& CommonBridgeClientConfig::_internal_excluded_topic(int index) const {
  return excluded_topic_.Get(index);
}
inline const std::string& CommonBridgeClientConfig::excluded_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  return _internal_excluded_topic(index);
}
inline std::string* CommonBridgeClientConfig::mutable_excluded_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  return excluded_topic_.Mutable(index);
}
inline void CommonBridgeClientConfig::set_excluded_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  excluded_topic_.Mutable(index)->assign(value);
}
inline void CommonBridgeClientConfig::set_excluded_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  excluded_topic_.Mutable(index)->assign(std::move(value));
}
inline void CommonBridgeClientConfig::set_excluded_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  excluded_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
}
inline void CommonBridgeClientConfig::set_excluded_topic(int index, const char* value, size_t size) {
  excluded_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
}
inline std::string* CommonBridgeClientConfig::_internal_add_excluded_topic() {
  return excluded_topic_.Add();
}
inline void CommonBridgeClientConfig::add_excluded_topic(const std::string& value) {
  excluded_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
}
inline void CommonBridgeClientConfig::add_excluded_topic(std::string&& value) {
  excluded_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
}
inline void CommonBridgeClientConfig::add_excluded_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  excluded_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
}
inline void CommonBridgeClientConfig::add_excluded_topic(const char* value, size_t size) {
  excluded_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommonBridgeClientConfig::excluded_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  return excluded_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommonBridgeClientConfig::mutable_excluded_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CommonBridgeClientConfig.excluded_topic)
  return &excluded_topic_;
}

// repeated string included_topic = 3;
inline int CommonBridgeClientConfig::_internal_included_topic_size() const {
  return included_topic_.size();
}
inline int CommonBridgeClientConfig::included_topic_size() const {
  return _internal_included_topic_size();
}
inline void CommonBridgeClientConfig::clear_included_topic() {
  included_topic_.Clear();
}
inline std::string* CommonBridgeClientConfig::add_included_topic() {
  // @@protoc_insertion_point(field_add_mutable:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  return _internal_add_included_topic();
}
inline const std::string& CommonBridgeClientConfig::_internal_included_topic(int index) const {
  return included_topic_.Get(index);
}
inline const std::string& CommonBridgeClientConfig::included_topic(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  return _internal_included_topic(index);
}
inline std::string* CommonBridgeClientConfig::mutable_included_topic(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  return included_topic_.Mutable(index);
}
inline void CommonBridgeClientConfig::set_included_topic(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  included_topic_.Mutable(index)->assign(value);
}
inline void CommonBridgeClientConfig::set_included_topic(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  included_topic_.Mutable(index)->assign(std::move(value));
}
inline void CommonBridgeClientConfig::set_included_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  included_topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
}
inline void CommonBridgeClientConfig::set_included_topic(int index, const char* value, size_t size) {
  included_topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
}
inline std::string* CommonBridgeClientConfig::_internal_add_included_topic() {
  return included_topic_.Add();
}
inline void CommonBridgeClientConfig::add_included_topic(const std::string& value) {
  included_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
}
inline void CommonBridgeClientConfig::add_included_topic(std::string&& value) {
  included_topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
}
inline void CommonBridgeClientConfig::add_included_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  included_topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
}
inline void CommonBridgeClientConfig::add_included_topic(const char* value, size_t size) {
  included_topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommonBridgeClientConfig::included_topic() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  return included_topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommonBridgeClientConfig::mutable_included_topic() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CommonBridgeClientConfig.included_topic)
  return &included_topic_;
}

// -------------------------------------------------------------------

// CommonBridgeServerConfig

// required string hostname = 1;
inline bool CommonBridgeServerConfig::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommonBridgeServerConfig::has_hostname() const {
  return _internal_has_hostname();
}
inline void CommonBridgeServerConfig::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonBridgeServerConfig::hostname() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
  return _internal_hostname();
}
inline void CommonBridgeServerConfig::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
}
inline std::string* CommonBridgeServerConfig::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
  return _internal_mutable_hostname();
}
inline const std::string& CommonBridgeServerConfig::_internal_hostname() const {
  return hostname_.Get();
}
inline void CommonBridgeServerConfig::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CommonBridgeServerConfig::set_hostname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
}
inline void CommonBridgeServerConfig::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
}
inline void CommonBridgeServerConfig::set_hostname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
}
inline std::string* CommonBridgeServerConfig::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CommonBridgeServerConfig::release_hostname() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hostname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommonBridgeServerConfig::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CommonBridgeServerConfig.hostname)
}

// optional uint32 port = 2 [default = 5800];
inline bool CommonBridgeServerConfig::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommonBridgeServerConfig::has_port() const {
  return _internal_has_port();
}
inline void CommonBridgeServerConfig::clear_port() {
  port_ = 5800u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommonBridgeServerConfig::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommonBridgeServerConfig::port() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeServerConfig.port)
  return _internal_port();
}
inline void CommonBridgeServerConfig::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  port_ = value;
}
inline void CommonBridgeServerConfig::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:senseAD.rscl.idl.CommonBridgeServerConfig.port)
}

// -------------------------------------------------------------------

// CommonBridgeConfig

// required .senseAD.rscl.idl.CommonBridgeServerConfig server = 1;
inline bool CommonBridgeConfig::_internal_has_server() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || server_ != nullptr);
  return value;
}
inline bool CommonBridgeConfig::has_server() const {
  return _internal_has_server();
}
inline void CommonBridgeConfig::clear_server() {
  if (server_ != nullptr) server_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::senseAD::rscl::idl::CommonBridgeServerConfig& CommonBridgeConfig::_internal_server() const {
  const ::senseAD::rscl::idl::CommonBridgeServerConfig* p = server_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::CommonBridgeServerConfig&>(
      ::senseAD::rscl::idl::_CommonBridgeServerConfig_default_instance_);
}
inline const ::senseAD::rscl::idl::CommonBridgeServerConfig& CommonBridgeConfig::server() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeConfig.server)
  return _internal_server();
}
inline void CommonBridgeConfig::unsafe_arena_set_allocated_server(
    ::senseAD::rscl::idl::CommonBridgeServerConfig* server) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  server_ = server;
  if (server) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.CommonBridgeConfig.server)
}
inline ::senseAD::rscl::idl::CommonBridgeServerConfig* CommonBridgeConfig::release_server() {
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::CommonBridgeServerConfig* temp = server_;
  server_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::CommonBridgeServerConfig* CommonBridgeConfig::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.CommonBridgeConfig.server)
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::CommonBridgeServerConfig* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::CommonBridgeServerConfig* CommonBridgeConfig::_internal_mutable_server() {
  _has_bits_[0] |= 0x00000001u;
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::CommonBridgeServerConfig>(GetArena());
    server_ = p;
  }
  return server_;
}
inline ::senseAD::rscl::idl::CommonBridgeServerConfig* CommonBridgeConfig::mutable_server() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CommonBridgeConfig.server)
  return _internal_mutable_server();
}
inline void CommonBridgeConfig::set_allocated_server(::senseAD::rscl::idl::CommonBridgeServerConfig* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.CommonBridgeConfig.server)
}

// repeated .senseAD.rscl.idl.CommonBridgeClientConfig clients = 2;
inline int CommonBridgeConfig::_internal_clients_size() const {
  return clients_.size();
}
inline int CommonBridgeConfig::clients_size() const {
  return _internal_clients_size();
}
inline void CommonBridgeConfig::clear_clients() {
  clients_.Clear();
}
inline ::senseAD::rscl::idl::CommonBridgeClientConfig* CommonBridgeConfig::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.CommonBridgeConfig.clients)
  return clients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CommonBridgeClientConfig >*
CommonBridgeConfig::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.CommonBridgeConfig.clients)
  return &clients_;
}
inline const ::senseAD::rscl::idl::CommonBridgeClientConfig& CommonBridgeConfig::_internal_clients(int index) const {
  return clients_.Get(index);
}
inline const ::senseAD::rscl::idl::CommonBridgeClientConfig& CommonBridgeConfig::clients(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.CommonBridgeConfig.clients)
  return _internal_clients(index);
}
inline ::senseAD::rscl::idl::CommonBridgeClientConfig* CommonBridgeConfig::_internal_add_clients() {
  return clients_.Add();
}
inline ::senseAD::rscl::idl::CommonBridgeClientConfig* CommonBridgeConfig::add_clients() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.CommonBridgeConfig.clients)
  return _internal_add_clients();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::CommonBridgeClientConfig >&
CommonBridgeConfig::clients() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.CommonBridgeConfig.clients)
  return clients_;
}

// -------------------------------------------------------------------

// GlobalConfig

// repeated .senseAD.rscl.idl.EnvGroup env_group = 1;
inline int GlobalConfig::_internal_env_group_size() const {
  return env_group_.size();
}
inline int GlobalConfig::env_group_size() const {
  return _internal_env_group_size();
}
inline void GlobalConfig::clear_env_group() {
  env_group_.Clear();
}
inline ::senseAD::rscl::idl::EnvGroup* GlobalConfig::mutable_env_group(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.env_group)
  return env_group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::EnvGroup >*
GlobalConfig::mutable_env_group() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.GlobalConfig.env_group)
  return &env_group_;
}
inline const ::senseAD::rscl::idl::EnvGroup& GlobalConfig::_internal_env_group(int index) const {
  return env_group_.Get(index);
}
inline const ::senseAD::rscl::idl::EnvGroup& GlobalConfig::env_group(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.env_group)
  return _internal_env_group(index);
}
inline ::senseAD::rscl::idl::EnvGroup* GlobalConfig::_internal_add_env_group() {
  return env_group_.Add();
}
inline ::senseAD::rscl::idl::EnvGroup* GlobalConfig::add_env_group() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.GlobalConfig.env_group)
  return _internal_add_env_group();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::EnvGroup >&
GlobalConfig::env_group() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.GlobalConfig.env_group)
  return env_group_;
}

// repeated .senseAD.rscl.idl.Extend extend = 2;
inline int GlobalConfig::_internal_extend_size() const {
  return extend_.size();
}
inline int GlobalConfig::extend_size() const {
  return _internal_extend_size();
}
inline void GlobalConfig::clear_extend() {
  extend_.Clear();
}
inline ::senseAD::rscl::idl::Extend* GlobalConfig::mutable_extend(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.extend)
  return extend_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::Extend >*
GlobalConfig::mutable_extend() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.GlobalConfig.extend)
  return &extend_;
}
inline const ::senseAD::rscl::idl::Extend& GlobalConfig::_internal_extend(int index) const {
  return extend_.Get(index);
}
inline const ::senseAD::rscl::idl::Extend& GlobalConfig::extend(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.extend)
  return _internal_extend(index);
}
inline ::senseAD::rscl::idl::Extend* GlobalConfig::_internal_add_extend() {
  return extend_.Add();
}
inline ::senseAD::rscl::idl::Extend* GlobalConfig::add_extend() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.GlobalConfig.extend)
  return _internal_add_extend();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::Extend >&
GlobalConfig::extend() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.GlobalConfig.extend)
  return extend_;
}

// repeated .senseAD.rscl.idl.RuntimeConfig mw_config = 3;
inline int GlobalConfig::_internal_mw_config_size() const {
  return mw_config_.size();
}
inline int GlobalConfig::mw_config_size() const {
  return _internal_mw_config_size();
}
inline void GlobalConfig::clear_mw_config() {
  mw_config_.Clear();
}
inline ::senseAD::rscl::idl::RuntimeConfig* GlobalConfig::mutable_mw_config(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.mw_config)
  return mw_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::RuntimeConfig >*
GlobalConfig::mutable_mw_config() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.GlobalConfig.mw_config)
  return &mw_config_;
}
inline const ::senseAD::rscl::idl::RuntimeConfig& GlobalConfig::_internal_mw_config(int index) const {
  return mw_config_.Get(index);
}
inline const ::senseAD::rscl::idl::RuntimeConfig& GlobalConfig::mw_config(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.mw_config)
  return _internal_mw_config(index);
}
inline ::senseAD::rscl::idl::RuntimeConfig* GlobalConfig::_internal_add_mw_config() {
  return mw_config_.Add();
}
inline ::senseAD::rscl::idl::RuntimeConfig* GlobalConfig::add_mw_config() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.GlobalConfig.mw_config)
  return _internal_add_mw_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::RuntimeConfig >&
GlobalConfig::mw_config() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.GlobalConfig.mw_config)
  return mw_config_;
}

// optional .senseAD.rscl.idl.CrossSystemConfig cross_system = 4;
inline bool GlobalConfig::_internal_has_cross_system() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || cross_system_ != nullptr);
  return value;
}
inline bool GlobalConfig::has_cross_system() const {
  return _internal_has_cross_system();
}
inline void GlobalConfig::clear_cross_system() {
  if (cross_system_ != nullptr) cross_system_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::senseAD::rscl::idl::CrossSystemConfig& GlobalConfig::_internal_cross_system() const {
  const ::senseAD::rscl::idl::CrossSystemConfig* p = cross_system_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::CrossSystemConfig&>(
      ::senseAD::rscl::idl::_CrossSystemConfig_default_instance_);
}
inline const ::senseAD::rscl::idl::CrossSystemConfig& GlobalConfig::cross_system() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.cross_system)
  return _internal_cross_system();
}
inline void GlobalConfig::unsafe_arena_set_allocated_cross_system(
    ::senseAD::rscl::idl::CrossSystemConfig* cross_system) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cross_system_);
  }
  cross_system_ = cross_system;
  if (cross_system) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.GlobalConfig.cross_system)
}
inline ::senseAD::rscl::idl::CrossSystemConfig* GlobalConfig::release_cross_system() {
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::CrossSystemConfig* temp = cross_system_;
  cross_system_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemConfig* GlobalConfig::unsafe_arena_release_cross_system() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.GlobalConfig.cross_system)
  _has_bits_[0] &= ~0x00000001u;
  ::senseAD::rscl::idl::CrossSystemConfig* temp = cross_system_;
  cross_system_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::CrossSystemConfig* GlobalConfig::_internal_mutable_cross_system() {
  _has_bits_[0] |= 0x00000001u;
  if (cross_system_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::CrossSystemConfig>(GetArena());
    cross_system_ = p;
  }
  return cross_system_;
}
inline ::senseAD::rscl::idl::CrossSystemConfig* GlobalConfig::mutable_cross_system() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.cross_system)
  return _internal_mutable_cross_system();
}
inline void GlobalConfig::set_allocated_cross_system(::senseAD::rscl::idl::CrossSystemConfig* cross_system) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cross_system_;
  }
  if (cross_system) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cross_system);
    if (message_arena != submessage_arena) {
      cross_system = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cross_system, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cross_system_ = cross_system;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.GlobalConfig.cross_system)
}

// repeated .senseAD.rscl.idl.NodeConfig node_config = 5;
inline int GlobalConfig::_internal_node_config_size() const {
  return node_config_.size();
}
inline int GlobalConfig::node_config_size() const {
  return _internal_node_config_size();
}
inline void GlobalConfig::clear_node_config() {
  node_config_.Clear();
}
inline ::senseAD::rscl::idl::NodeConfig* GlobalConfig::mutable_node_config(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.node_config)
  return node_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::NodeConfig >*
GlobalConfig::mutable_node_config() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.GlobalConfig.node_config)
  return &node_config_;
}
inline const ::senseAD::rscl::idl::NodeConfig& GlobalConfig::_internal_node_config(int index) const {
  return node_config_.Get(index);
}
inline const ::senseAD::rscl::idl::NodeConfig& GlobalConfig::node_config(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.node_config)
  return _internal_node_config(index);
}
inline ::senseAD::rscl::idl::NodeConfig* GlobalConfig::_internal_add_node_config() {
  return node_config_.Add();
}
inline ::senseAD::rscl::idl::NodeConfig* GlobalConfig::add_node_config() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.GlobalConfig.node_config)
  return _internal_add_node_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::NodeConfig >&
GlobalConfig::node_config() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.GlobalConfig.node_config)
  return node_config_;
}

// repeated .senseAD.rscl.idl.HeteroChannelConfig hetero_config = 6;
inline int GlobalConfig::_internal_hetero_config_size() const {
  return hetero_config_.size();
}
inline int GlobalConfig::hetero_config_size() const {
  return _internal_hetero_config_size();
}
inline void GlobalConfig::clear_hetero_config() {
  hetero_config_.Clear();
}
inline ::senseAD::rscl::idl::HeteroChannelConfig* GlobalConfig::mutable_hetero_config(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.hetero_config)
  return hetero_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::HeteroChannelConfig >*
GlobalConfig::mutable_hetero_config() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.GlobalConfig.hetero_config)
  return &hetero_config_;
}
inline const ::senseAD::rscl::idl::HeteroChannelConfig& GlobalConfig::_internal_hetero_config(int index) const {
  return hetero_config_.Get(index);
}
inline const ::senseAD::rscl::idl::HeteroChannelConfig& GlobalConfig::hetero_config(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.hetero_config)
  return _internal_hetero_config(index);
}
inline ::senseAD::rscl::idl::HeteroChannelConfig* GlobalConfig::_internal_add_hetero_config() {
  return hetero_config_.Add();
}
inline ::senseAD::rscl::idl::HeteroChannelConfig* GlobalConfig::add_hetero_config() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.GlobalConfig.hetero_config)
  return _internal_add_hetero_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::HeteroChannelConfig >&
GlobalConfig::hetero_config() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.GlobalConfig.hetero_config)
  return hetero_config_;
}

// repeated .senseAD.rscl.idl.InetBasedService inet_service = 7;
inline int GlobalConfig::_internal_inet_service_size() const {
  return inet_service_.size();
}
inline int GlobalConfig::inet_service_size() const {
  return _internal_inet_service_size();
}
inline void GlobalConfig::clear_inet_service() {
  inet_service_.Clear();
}
inline ::senseAD::rscl::idl::InetBasedService* GlobalConfig::mutable_inet_service(int index) {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.inet_service)
  return inet_service_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::InetBasedService >*
GlobalConfig::mutable_inet_service() {
  // @@protoc_insertion_point(field_mutable_list:senseAD.rscl.idl.GlobalConfig.inet_service)
  return &inet_service_;
}
inline const ::senseAD::rscl::idl::InetBasedService& GlobalConfig::_internal_inet_service(int index) const {
  return inet_service_.Get(index);
}
inline const ::senseAD::rscl::idl::InetBasedService& GlobalConfig::inet_service(int index) const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.inet_service)
  return _internal_inet_service(index);
}
inline ::senseAD::rscl::idl::InetBasedService* GlobalConfig::_internal_add_inet_service() {
  return inet_service_.Add();
}
inline ::senseAD::rscl::idl::InetBasedService* GlobalConfig::add_inet_service() {
  // @@protoc_insertion_point(field_add:senseAD.rscl.idl.GlobalConfig.inet_service)
  return _internal_add_inet_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::senseAD::rscl::idl::InetBasedService >&
GlobalConfig::inet_service() const {
  // @@protoc_insertion_point(field_list:senseAD.rscl.idl.GlobalConfig.inet_service)
  return inet_service_;
}

// optional .senseAD.rscl.idl.CommonBridgeConfig common_bridge = 8;
inline bool GlobalConfig::_internal_has_common_bridge() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || common_bridge_ != nullptr);
  return value;
}
inline bool GlobalConfig::has_common_bridge() const {
  return _internal_has_common_bridge();
}
inline void GlobalConfig::clear_common_bridge() {
  if (common_bridge_ != nullptr) common_bridge_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::senseAD::rscl::idl::CommonBridgeConfig& GlobalConfig::_internal_common_bridge() const {
  const ::senseAD::rscl::idl::CommonBridgeConfig* p = common_bridge_;
  return p != nullptr ? *p : reinterpret_cast<const ::senseAD::rscl::idl::CommonBridgeConfig&>(
      ::senseAD::rscl::idl::_CommonBridgeConfig_default_instance_);
}
inline const ::senseAD::rscl::idl::CommonBridgeConfig& GlobalConfig::common_bridge() const {
  // @@protoc_insertion_point(field_get:senseAD.rscl.idl.GlobalConfig.common_bridge)
  return _internal_common_bridge();
}
inline void GlobalConfig::unsafe_arena_set_allocated_common_bridge(
    ::senseAD::rscl::idl::CommonBridgeConfig* common_bridge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_bridge_);
  }
  common_bridge_ = common_bridge;
  if (common_bridge) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:senseAD.rscl.idl.GlobalConfig.common_bridge)
}
inline ::senseAD::rscl::idl::CommonBridgeConfig* GlobalConfig::release_common_bridge() {
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::CommonBridgeConfig* temp = common_bridge_;
  common_bridge_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::senseAD::rscl::idl::CommonBridgeConfig* GlobalConfig::unsafe_arena_release_common_bridge() {
  // @@protoc_insertion_point(field_release:senseAD.rscl.idl.GlobalConfig.common_bridge)
  _has_bits_[0] &= ~0x00000002u;
  ::senseAD::rscl::idl::CommonBridgeConfig* temp = common_bridge_;
  common_bridge_ = nullptr;
  return temp;
}
inline ::senseAD::rscl::idl::CommonBridgeConfig* GlobalConfig::_internal_mutable_common_bridge() {
  _has_bits_[0] |= 0x00000002u;
  if (common_bridge_ == nullptr) {
    auto* p = CreateMaybeMessage<::senseAD::rscl::idl::CommonBridgeConfig>(GetArena());
    common_bridge_ = p;
  }
  return common_bridge_;
}
inline ::senseAD::rscl::idl::CommonBridgeConfig* GlobalConfig::mutable_common_bridge() {
  // @@protoc_insertion_point(field_mutable:senseAD.rscl.idl.GlobalConfig.common_bridge)
  return _internal_mutable_common_bridge();
}
inline void GlobalConfig::set_allocated_common_bridge(::senseAD::rscl::idl::CommonBridgeConfig* common_bridge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete common_bridge_;
  }
  if (common_bridge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(common_bridge);
    if (message_arena != submessage_arena) {
      common_bridge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common_bridge, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  common_bridge_ = common_bridge;
  // @@protoc_insertion_point(field_set_allocated:senseAD.rscl.idl.GlobalConfig.common_bridge)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace idl
}  // namespace rscl
}  // namespace senseAD

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide>() {
  return ::senseAD::rscl::idl::TopicHeteroChannelConfig_EnabledSide_descriptor();
}
template <> struct is_proto_enum< ::senseAD::rscl::idl::CrossSystemMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::senseAD::rscl::idl::CrossSystemMode>() {
  return ::senseAD::rscl::idl::CrossSystemMode_descriptor();
}
template <> struct is_proto_enum< ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode>() {
  return ::senseAD::rscl::idl::CrossSystemOutgoingPrefixMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ad_5frscl_2fidl_2fglobal_5fconfig_2eproto
