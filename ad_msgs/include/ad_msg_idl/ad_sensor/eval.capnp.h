// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: eval.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <ad_msg_idl/std_msgs/header.capnp.h>

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f714a2fb89c7af6b);
CAPNP_DECLARE_SCHEMA(d48479f445320bb8);
CAPNP_DECLARE_SCHEMA(8c040852658a42c0);
CAPNP_DECLARE_SCHEMA(edb4f85eba3a2100);
CAPNP_DECLARE_SCHEMA(ff66f9ddd547d05e);
CAPNP_DECLARE_SCHEMA(9c77a9b78126091c);
CAPNP_DECLARE_SCHEMA(b437994adc13638c);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace sensor {

struct CameraRawDataEval {
  CameraRawDataEval() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f714a2fb89c7af6b, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InsRawDataEval {
  InsRawDataEval() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d48479f445320bb8, 7, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LidarRawDataEval {
  LidarRawDataEval() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c040852658a42c0, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RadarCanStatusEval {
  RadarCanStatusEval() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(edb4f85eba3a2100, 6, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SensorEval {
  SensorEval() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff66f9ddd547d05e, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SensorEvalRawItem {
  SensorEvalRawItem() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c77a9b78126091c, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SensorEvalRaw {
  SensorEvalRaw() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b437994adc13638c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class CameraRawDataEval::Reader {
public:
  typedef CameraRawDataEval Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCameraName() const;
  inline  ::capnp::Text::Reader getCameraName() const;

  inline bool hasCameraType() const;
  inline  ::capnp::Text::Reader getCameraType() const;

  inline float getFrameFrequency() const;

  inline  ::uint64_t getDelayNs() const;

  inline  ::uint64_t getTimeGap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraRawDataEval::Builder {
public:
  typedef CameraRawDataEval Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCameraName();
  inline  ::capnp::Text::Builder getCameraName();
  inline void setCameraName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCameraName(unsigned int size);
  inline void adoptCameraName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCameraName();

  inline bool hasCameraType();
  inline  ::capnp::Text::Builder getCameraType();
  inline void setCameraType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCameraType(unsigned int size);
  inline void adoptCameraType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCameraType();

  inline float getFrameFrequency();
  inline void setFrameFrequency(float value);

  inline  ::uint64_t getDelayNs();
  inline void setDelayNs( ::uint64_t value);

  inline  ::uint64_t getTimeGap();
  inline void setTimeGap( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraRawDataEval::Pipeline {
public:
  typedef CameraRawDataEval Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InsRawDataEval::Reader {
public:
  typedef InsRawDataEval Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline double getGnssParseDelayUs() const;

  inline double getGnssTransDelayUs() const;

  inline double getInsParseDelayUs() const;

  inline double getInsTransDelayUs() const;

  inline double getImuParseDelayUs() const;

  inline double getImuTransDelayUs() const;

  inline double getInsTimeGapMs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InsRawDataEval::Builder {
public:
  typedef InsRawDataEval Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline double getGnssParseDelayUs();
  inline void setGnssParseDelayUs(double value);

  inline double getGnssTransDelayUs();
  inline void setGnssTransDelayUs(double value);

  inline double getInsParseDelayUs();
  inline void setInsParseDelayUs(double value);

  inline double getInsTransDelayUs();
  inline void setInsTransDelayUs(double value);

  inline double getImuParseDelayUs();
  inline void setImuParseDelayUs(double value);

  inline double getImuTransDelayUs();
  inline void setImuTransDelayUs(double value);

  inline double getInsTimeGapMs();
  inline void setInsTimeGapMs(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InsRawDataEval::Pipeline {
public:
  typedef InsRawDataEval Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LidarRawDataEval::Reader {
public:
  typedef LidarRawDataEval Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLidarName() const;
  inline  ::capnp::Text::Reader getLidarName() const;

  inline bool hasLidarType() const;
  inline  ::capnp::Text::Reader getLidarType() const;

  inline float getFrameFrequency() const;

  inline  ::int32_t getDelayNs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LidarRawDataEval::Builder {
public:
  typedef LidarRawDataEval Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLidarName();
  inline  ::capnp::Text::Builder getLidarName();
  inline void setLidarName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLidarName(unsigned int size);
  inline void adoptLidarName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLidarName();

  inline bool hasLidarType();
  inline  ::capnp::Text::Builder getLidarType();
  inline void setLidarType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLidarType(unsigned int size);
  inline void adoptLidarType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLidarType();

  inline float getFrameFrequency();
  inline void setFrameFrequency(float value);

  inline  ::int32_t getDelayNs();
  inline void setDelayNs( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LidarRawDataEval::Pipeline {
public:
  typedef LidarRawDataEval Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RadarCanStatusEval::Reader {
public:
  typedef RadarCanStatusEval Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRadarName() const;
  inline  ::capnp::Text::Reader getRadarName() const;

  inline  ::int32_t getMajorRelease() const;

  inline  ::int32_t getMinorRelease() const;

  inline  ::int32_t getPatchLevel() const;

  inline  ::int32_t getExtendedRange() const;

  inline  ::int32_t getCountryCode() const;

  inline  ::int32_t getVoltageError() const;

  inline  ::int32_t getPersistentError() const;

  inline  ::int32_t getTemperatureError() const;

  inline  ::int32_t getOutputType() const;

  inline  ::int32_t getObjectQuality() const;

  inline  ::int32_t getObjectExtension() const;

  inline  ::int32_t getMotionRxState() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RadarCanStatusEval::Builder {
public:
  typedef RadarCanStatusEval Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRadarName();
  inline  ::capnp::Text::Builder getRadarName();
  inline void setRadarName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRadarName(unsigned int size);
  inline void adoptRadarName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRadarName();

  inline  ::int32_t getMajorRelease();
  inline void setMajorRelease( ::int32_t value);

  inline  ::int32_t getMinorRelease();
  inline void setMinorRelease( ::int32_t value);

  inline  ::int32_t getPatchLevel();
  inline void setPatchLevel( ::int32_t value);

  inline  ::int32_t getExtendedRange();
  inline void setExtendedRange( ::int32_t value);

  inline  ::int32_t getCountryCode();
  inline void setCountryCode( ::int32_t value);

  inline  ::int32_t getVoltageError();
  inline void setVoltageError( ::int32_t value);

  inline  ::int32_t getPersistentError();
  inline void setPersistentError( ::int32_t value);

  inline  ::int32_t getTemperatureError();
  inline void setTemperatureError( ::int32_t value);

  inline  ::int32_t getOutputType();
  inline void setOutputType( ::int32_t value);

  inline  ::int32_t getObjectQuality();
  inline void setObjectQuality( ::int32_t value);

  inline  ::int32_t getObjectExtension();
  inline void setObjectExtension( ::int32_t value);

  inline  ::int32_t getMotionRxState();
  inline void setMotionRxState( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RadarCanStatusEval::Pipeline {
public:
  typedef RadarCanStatusEval Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SensorEval::Reader {
public:
  typedef SensorEval Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasLidarEvalList() const;
  inline  ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Reader getLidarEvalList() const;

  inline bool hasCameraEvalList() const;
  inline  ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Reader getCameraEvalList() const;

  inline bool hasRadarEvalList() const;
  inline  ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Reader getRadarEvalList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SensorEval::Builder {
public:
  typedef SensorEval Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasLidarEvalList();
  inline  ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Builder getLidarEvalList();
  inline void setLidarEvalList( ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Builder initLidarEvalList(unsigned int size);
  inline void adoptLidarEvalList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>> disownLidarEvalList();

  inline bool hasCameraEvalList();
  inline  ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Builder getCameraEvalList();
  inline void setCameraEvalList( ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Builder initCameraEvalList(unsigned int size);
  inline void adoptCameraEvalList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>> disownCameraEvalList();

  inline bool hasRadarEvalList();
  inline  ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Builder getRadarEvalList();
  inline void setRadarEvalList( ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Builder initRadarEvalList(unsigned int size);
  inline void adoptRadarEvalList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>> disownRadarEvalList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SensorEval::Pipeline {
public:
  typedef SensorEval Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SensorEvalRawItem::Reader {
public:
  typedef SensorEvalRawItem Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSensorName() const;
  inline  ::capnp::Text::Reader getSensorName() const;

  inline bool hasEvalType() const;
  inline  ::capnp::Text::Reader getEvalType() const;

  inline bool hasGroup() const;
  inline  ::capnp::Text::Reader getGroup() const;

  inline bool hasDataList() const;
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader getDataList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SensorEvalRawItem::Builder {
public:
  typedef SensorEvalRawItem Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSensorName();
  inline  ::capnp::Text::Builder getSensorName();
  inline void setSensorName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSensorName(unsigned int size);
  inline void adoptSensorName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSensorName();

  inline bool hasEvalType();
  inline  ::capnp::Text::Builder getEvalType();
  inline void setEvalType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initEvalType(unsigned int size);
  inline void adoptEvalType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownEvalType();

  inline bool hasGroup();
  inline  ::capnp::Text::Builder getGroup();
  inline void setGroup( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGroup(unsigned int size);
  inline void adoptGroup(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGroup();

  inline bool hasDataList();
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder getDataList();
  inline void setDataList( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value);
  inline void setDataList(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder initDataList(unsigned int size);
  inline void adoptDataList(::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> disownDataList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SensorEvalRawItem::Pipeline {
public:
  typedef SensorEvalRawItem Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SensorEvalRaw::Reader {
public:
  typedef SensorEvalRaw Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPid() const;
  inline  ::capnp::Text::Reader getPid() const;

  inline bool hasContents() const;
  inline  ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Reader getContents() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SensorEvalRaw::Builder {
public:
  typedef SensorEvalRaw Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPid();
  inline  ::capnp::Text::Builder getPid();
  inline void setPid( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPid(unsigned int size);
  inline void adoptPid(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPid();

  inline bool hasContents();
  inline  ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Builder getContents();
  inline void setContents( ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Builder initContents(unsigned int size);
  inline void adoptContents(::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>> disownContents();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SensorEvalRaw::Pipeline {
public:
  typedef SensorEvalRaw Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool CameraRawDataEval::Reader::hasCameraName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraRawDataEval::Builder::hasCameraName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CameraRawDataEval::Reader::getCameraName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CameraRawDataEval::Builder::getCameraName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraRawDataEval::Builder::setCameraName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CameraRawDataEval::Builder::initCameraName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CameraRawDataEval::Builder::adoptCameraName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CameraRawDataEval::Builder::disownCameraName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraRawDataEval::Reader::hasCameraType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraRawDataEval::Builder::hasCameraType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CameraRawDataEval::Reader::getCameraType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CameraRawDataEval::Builder::getCameraType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraRawDataEval::Builder::setCameraType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CameraRawDataEval::Builder::initCameraType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CameraRawDataEval::Builder::adoptCameraType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CameraRawDataEval::Builder::disownCameraType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float CameraRawDataEval::Reader::getFrameFrequency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float CameraRawDataEval::Builder::getFrameFrequency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CameraRawDataEval::Builder::setFrameFrequency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t CameraRawDataEval::Reader::getDelayNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CameraRawDataEval::Builder::getDelayNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CameraRawDataEval::Builder::setDelayNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t CameraRawDataEval::Reader::getTimeGap() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CameraRawDataEval::Builder::getTimeGap() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CameraRawDataEval::Builder::setTimeGap( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool InsRawDataEval::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InsRawDataEval::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader InsRawDataEval::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder InsRawDataEval::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline InsRawDataEval::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InsRawDataEval::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder InsRawDataEval::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InsRawDataEval::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> InsRawDataEval::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double InsRawDataEval::Reader::getGnssParseDelayUs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getGnssParseDelayUs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setGnssParseDelayUs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double InsRawDataEval::Reader::getGnssTransDelayUs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getGnssTransDelayUs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setGnssTransDelayUs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double InsRawDataEval::Reader::getInsParseDelayUs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getInsParseDelayUs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setInsParseDelayUs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double InsRawDataEval::Reader::getInsTransDelayUs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getInsTransDelayUs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setInsTransDelayUs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double InsRawDataEval::Reader::getImuParseDelayUs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getImuParseDelayUs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setImuParseDelayUs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double InsRawDataEval::Reader::getImuTransDelayUs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getImuTransDelayUs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setImuTransDelayUs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline double InsRawDataEval::Reader::getInsTimeGapMs() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline double InsRawDataEval::Builder::getInsTimeGapMs() {
  return _builder.getDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void InsRawDataEval::Builder::setInsTimeGapMs(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool LidarRawDataEval::Reader::hasLidarName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LidarRawDataEval::Builder::hasLidarName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LidarRawDataEval::Reader::getLidarName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LidarRawDataEval::Builder::getLidarName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LidarRawDataEval::Builder::setLidarName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LidarRawDataEval::Builder::initLidarName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LidarRawDataEval::Builder::adoptLidarName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LidarRawDataEval::Builder::disownLidarName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LidarRawDataEval::Reader::hasLidarType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LidarRawDataEval::Builder::hasLidarType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LidarRawDataEval::Reader::getLidarType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LidarRawDataEval::Builder::getLidarType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LidarRawDataEval::Builder::setLidarType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LidarRawDataEval::Builder::initLidarType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LidarRawDataEval::Builder::adoptLidarType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LidarRawDataEval::Builder::disownLidarType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float LidarRawDataEval::Reader::getFrameFrequency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float LidarRawDataEval::Builder::getFrameFrequency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LidarRawDataEval::Builder::setFrameFrequency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LidarRawDataEval::Reader::getDelayNs() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LidarRawDataEval::Builder::getDelayNs() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LidarRawDataEval::Builder::setDelayNs( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RadarCanStatusEval::Reader::hasRadarName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RadarCanStatusEval::Builder::hasRadarName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RadarCanStatusEval::Reader::getRadarName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RadarCanStatusEval::Builder::getRadarName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RadarCanStatusEval::Builder::setRadarName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RadarCanStatusEval::Builder::initRadarName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RadarCanStatusEval::Builder::adoptRadarName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RadarCanStatusEval::Builder::disownRadarName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t RadarCanStatusEval::Reader::getMajorRelease() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getMajorRelease() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setMajorRelease( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getMinorRelease() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getMinorRelease() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setMinorRelease( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getPatchLevel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getPatchLevel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setPatchLevel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getExtendedRange() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getExtendedRange() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setExtendedRange( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getCountryCode() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getCountryCode() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setCountryCode( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getVoltageError() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getVoltageError() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setVoltageError( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getPersistentError() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getPersistentError() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setPersistentError( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getTemperatureError() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getTemperatureError() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setTemperatureError( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getOutputType() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getOutputType() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setOutputType( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getObjectQuality() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getObjectQuality() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setObjectQuality( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getObjectExtension() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getObjectExtension() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setObjectExtension( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RadarCanStatusEval::Reader::getMotionRxState() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RadarCanStatusEval::Builder::getMotionRxState() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void RadarCanStatusEval::Builder::setMotionRxState( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline bool SensorEval::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEval::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader SensorEval::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder SensorEval::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline SensorEval::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SensorEval::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder SensorEval::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SensorEval::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> SensorEval::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SensorEval::Reader::hasLidarEvalList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEval::Builder::hasLidarEvalList() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Reader SensorEval::Reader::getLidarEvalList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Builder SensorEval::Builder::getLidarEvalList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SensorEval::Builder::setLidarEvalList( ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>::Builder SensorEval::Builder::initLidarEvalList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void SensorEval::Builder::adoptLidarEvalList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>> SensorEval::Builder::disownLidarEvalList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::LidarRawDataEval,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SensorEval::Reader::hasCameraEvalList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEval::Builder::hasCameraEvalList() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Reader SensorEval::Reader::getCameraEvalList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Builder SensorEval::Builder::getCameraEvalList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void SensorEval::Builder::setCameraEvalList( ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>::Builder SensorEval::Builder::initCameraEvalList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void SensorEval::Builder::adoptCameraEvalList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>> SensorEval::Builder::disownCameraEvalList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::CameraRawDataEval,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool SensorEval::Reader::hasRadarEvalList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEval::Builder::hasRadarEvalList() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Reader SensorEval::Reader::getRadarEvalList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Builder SensorEval::Builder::getRadarEvalList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void SensorEval::Builder::setRadarEvalList( ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>::Builder SensorEval::Builder::initRadarEvalList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void SensorEval::Builder::adoptRadarEvalList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>> SensorEval::Builder::disownRadarEvalList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::RadarCanStatusEval,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool SensorEvalRawItem::Reader::hasSensorName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEvalRawItem::Builder::hasSensorName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SensorEvalRawItem::Reader::getSensorName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SensorEvalRawItem::Builder::getSensorName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SensorEvalRawItem::Builder::setSensorName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SensorEvalRawItem::Builder::initSensorName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SensorEvalRawItem::Builder::adoptSensorName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SensorEvalRawItem::Builder::disownSensorName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SensorEvalRawItem::Reader::hasEvalType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEvalRawItem::Builder::hasEvalType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SensorEvalRawItem::Reader::getEvalType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SensorEvalRawItem::Builder::getEvalType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SensorEvalRawItem::Builder::setEvalType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SensorEvalRawItem::Builder::initEvalType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void SensorEvalRawItem::Builder::adoptEvalType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SensorEvalRawItem::Builder::disownEvalType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SensorEvalRawItem::Reader::hasGroup() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEvalRawItem::Builder::hasGroup() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SensorEvalRawItem::Reader::getGroup() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SensorEvalRawItem::Builder::getGroup() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void SensorEvalRawItem::Builder::setGroup( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SensorEvalRawItem::Builder::initGroup(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void SensorEvalRawItem::Builder::adoptGroup(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SensorEvalRawItem::Builder::disownGroup() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool SensorEvalRawItem::Reader::hasDataList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEvalRawItem::Builder::hasDataList() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader SensorEvalRawItem::Reader::getDataList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder SensorEvalRawItem::Builder::getDataList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void SensorEvalRawItem::Builder::setDataList( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void SensorEvalRawItem::Builder::setDataList(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder SensorEvalRawItem::Builder::initDataList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void SensorEvalRawItem::Builder::adoptDataList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> SensorEvalRawItem::Builder::disownDataList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool SensorEvalRaw::Reader::hasPid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEvalRaw::Builder::hasPid() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SensorEvalRaw::Reader::getPid() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SensorEvalRaw::Builder::getPid() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SensorEvalRaw::Builder::setPid( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SensorEvalRaw::Builder::initPid(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SensorEvalRaw::Builder::adoptPid(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SensorEvalRaw::Builder::disownPid() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SensorEvalRaw::Reader::hasContents() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SensorEvalRaw::Builder::hasContents() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Reader SensorEvalRaw::Reader::getContents() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Builder SensorEvalRaw::Builder::getContents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SensorEvalRaw::Builder::setContents( ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>::Builder SensorEvalRaw::Builder::initContents(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void SensorEvalRaw::Builder::adoptContents(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>> SensorEvalRaw::Builder::disownContents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::sensor::SensorEvalRawItem,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

