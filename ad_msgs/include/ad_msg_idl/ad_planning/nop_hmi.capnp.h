// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: nop_hmi.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <ad_msg_idl/std_msgs/header.capnp.h>

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(c30f01690830f5fe);
CAPNP_DECLARE_SCHEMA(9045d22050b60c22);
enum class LcType_9045d22050b60c22: uint16_t {
  LC_TYPE_NONE,
  LC_TYPE_I_L_C,
  LC_TYPE_M_L_C,
  LC_TYPE_A_L_C,
};
CAPNP_DECLARE_ENUM(LcType, 9045d22050b60c22);
CAPNP_DECLARE_SCHEMA(80807de940beba5c);
enum class MlcType_80807de940beba5c: uint16_t {
  MLC_TYPE_NONE,
  MLC_TYPE_ROAD_TO_RAMP,
  MLC_TYPE_RAMP_TO_ROAD,
  MLC_TYPE_ROAD_TO_ROAD,
  MLC_TYPE_RAMP_TO_RAMP,
};
CAPNP_DECLARE_ENUM(MlcType, 80807de940beba5c);
CAPNP_DECLARE_SCHEMA(835c05d40f07d98f);
enum class LcStage_835c05d40f07d98f: uint16_t {
  LC_STAGE_NONE,
  LC_STAGE_WAIT,
  LC_STAGE_PROCESS,
  LC_STAGE_BACK,
  LC_STAGE_DONE,
};
CAPNP_DECLARE_ENUM(LcStage, 835c05d40f07d98f);
CAPNP_DECLARE_SCHEMA(bbf3c3bd0d381c55);
enum class LcDirection_bbf3c3bd0d381c55: uint16_t {
  LC_DIRECTION_NONE,
  LC_DIRECTION_LEFT,
  LC_DIRECTION_RIGHT,
};
CAPNP_DECLARE_ENUM(LcDirection, bbf3c3bd0d381c55);
CAPNP_DECLARE_SCHEMA(83e6ec3025141a6e);
CAPNP_DECLARE_SCHEMA(ce88e31a65d828f0);
CAPNP_DECLARE_SCHEMA(ffdc5006248a1f10);
CAPNP_DECLARE_SCHEMA(c3caf22d53828803);
CAPNP_DECLARE_SCHEMA(f83063a3be87cf8d);
CAPNP_DECLARE_SCHEMA(89d4b6e47a1a630c);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace planning {

struct NopHmiLcInfo {
  NopHmiLcInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::LcType_9045d22050b60c22 LcType;

  typedef ::capnp::schemas::MlcType_80807de940beba5c MlcType;

  typedef ::capnp::schemas::LcStage_835c05d40f07d98f LcStage;

  typedef ::capnp::schemas::LcDirection_bbf3c3bd0d381c55 LcDirection;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c30f01690830f5fe, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NopHmiCipvInfo {
  NopHmiCipvInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83e6ec3025141a6e, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NopHmiRoadInfo {
  NopHmiRoadInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce88e31a65d828f0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NopHmiDodgeInfo {
  NopHmiDodgeInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffdc5006248a1f10, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VelHmiInfo {
  VelHmiInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3caf22d53828803, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NopHmiPanelInfo {
  NopHmiPanelInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f83063a3be87cf8d, 0, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ASStateMachine {
  ASStateMachine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89d4b6e47a1a630c, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class NopHmiLcInfo::Reader {
public:
  typedef NopHmiLcInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::planning::NopHmiLcInfo::LcType getLcType() const;

  inline  ::senseAD::msg::planning::NopHmiLcInfo::MlcType getMlcType() const;

  inline  ::senseAD::msg::planning::NopHmiLcInfo::LcStage getLcStage() const;

  inline  ::senseAD::msg::planning::NopHmiLcInfo::LcDirection getLcDirection() const;

  inline  ::uint64_t getTargetLaneId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NopHmiLcInfo::Builder {
public:
  typedef NopHmiLcInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::planning::NopHmiLcInfo::LcType getLcType();
  inline void setLcType( ::senseAD::msg::planning::NopHmiLcInfo::LcType value);

  inline  ::senseAD::msg::planning::NopHmiLcInfo::MlcType getMlcType();
  inline void setMlcType( ::senseAD::msg::planning::NopHmiLcInfo::MlcType value);

  inline  ::senseAD::msg::planning::NopHmiLcInfo::LcStage getLcStage();
  inline void setLcStage( ::senseAD::msg::planning::NopHmiLcInfo::LcStage value);

  inline  ::senseAD::msg::planning::NopHmiLcInfo::LcDirection getLcDirection();
  inline void setLcDirection( ::senseAD::msg::planning::NopHmiLcInfo::LcDirection value);

  inline  ::uint64_t getTargetLaneId();
  inline void setTargetLaneId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NopHmiLcInfo::Pipeline {
public:
  typedef NopHmiLcInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NopHmiCipvInfo::Reader {
public:
  typedef NopHmiCipvInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getHasCipv() const;

  inline  ::int32_t getTrackId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NopHmiCipvInfo::Builder {
public:
  typedef NopHmiCipvInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getHasCipv();
  inline void setHasCipv(bool value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NopHmiCipvInfo::Pipeline {
public:
  typedef NopHmiCipvInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NopHmiRoadInfo::Reader {
public:
  typedef NopHmiRoadInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getVelLimit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NopHmiRoadInfo::Builder {
public:
  typedef NopHmiRoadInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getVelLimit();
  inline void setVelLimit(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NopHmiRoadInfo::Pipeline {
public:
  typedef NopHmiRoadInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NopHmiDodgeInfo::Reader {
public:
  typedef NopHmiDodgeInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTruckId() const;
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader getTruckId() const;

  inline bool hasObjectId() const;
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader getObjectId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NopHmiDodgeInfo::Builder {
public:
  typedef NopHmiDodgeInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTruckId();
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder getTruckId();
  inline void setTruckId( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setTruckId(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder initTruckId(unsigned int size);
  inline void adoptTruckId(::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> disownTruckId();

  inline bool hasObjectId();
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder getObjectId();
  inline void setObjectId( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setObjectId(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder initObjectId(unsigned int size);
  inline void adoptObjectId(::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> disownObjectId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NopHmiDodgeInfo::Pipeline {
public:
  typedef NopHmiDodgeInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VelHmiInfo::Reader {
public:
  typedef VelHmiInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSelectedTimeHeadway() const;

  inline  ::uint32_t getSelectedSpeed() const;

  inline  ::int32_t getVehicleState() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VelHmiInfo::Builder {
public:
  typedef VelHmiInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSelectedTimeHeadway();
  inline void setSelectedTimeHeadway( ::int32_t value);

  inline  ::uint32_t getSelectedSpeed();
  inline void setSelectedSpeed( ::uint32_t value);

  inline  ::int32_t getVehicleState();
  inline void setVehicleState( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VelHmiInfo::Pipeline {
public:
  typedef VelHmiInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NopHmiPanelInfo::Reader {
public:
  typedef NopHmiPanelInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasLcInfo() const;
  inline  ::senseAD::msg::planning::NopHmiLcInfo::Reader getLcInfo() const;

  inline bool hasCipvInfo() const;
  inline  ::senseAD::msg::planning::NopHmiCipvInfo::Reader getCipvInfo() const;

  inline bool hasRoadInfo() const;
  inline  ::senseAD::msg::planning::NopHmiRoadInfo::Reader getRoadInfo() const;

  inline bool hasDodgeInfo() const;
  inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Reader getDodgeInfo() const;

  inline bool hasVehicleInfo() const;
  inline  ::senseAD::msg::planning::VelHmiInfo::Reader getVehicleInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NopHmiPanelInfo::Builder {
public:
  typedef NopHmiPanelInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasLcInfo();
  inline  ::senseAD::msg::planning::NopHmiLcInfo::Builder getLcInfo();
  inline void setLcInfo( ::senseAD::msg::planning::NopHmiLcInfo::Reader value);
  inline  ::senseAD::msg::planning::NopHmiLcInfo::Builder initLcInfo();
  inline void adoptLcInfo(::capnp::Orphan< ::senseAD::msg::planning::NopHmiLcInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiLcInfo> disownLcInfo();

  inline bool hasCipvInfo();
  inline  ::senseAD::msg::planning::NopHmiCipvInfo::Builder getCipvInfo();
  inline void setCipvInfo( ::senseAD::msg::planning::NopHmiCipvInfo::Reader value);
  inline  ::senseAD::msg::planning::NopHmiCipvInfo::Builder initCipvInfo();
  inline void adoptCipvInfo(::capnp::Orphan< ::senseAD::msg::planning::NopHmiCipvInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiCipvInfo> disownCipvInfo();

  inline bool hasRoadInfo();
  inline  ::senseAD::msg::planning::NopHmiRoadInfo::Builder getRoadInfo();
  inline void setRoadInfo( ::senseAD::msg::planning::NopHmiRoadInfo::Reader value);
  inline  ::senseAD::msg::planning::NopHmiRoadInfo::Builder initRoadInfo();
  inline void adoptRoadInfo(::capnp::Orphan< ::senseAD::msg::planning::NopHmiRoadInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiRoadInfo> disownRoadInfo();

  inline bool hasDodgeInfo();
  inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Builder getDodgeInfo();
  inline void setDodgeInfo( ::senseAD::msg::planning::NopHmiDodgeInfo::Reader value);
  inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Builder initDodgeInfo();
  inline void adoptDodgeInfo(::capnp::Orphan< ::senseAD::msg::planning::NopHmiDodgeInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiDodgeInfo> disownDodgeInfo();

  inline bool hasVehicleInfo();
  inline  ::senseAD::msg::planning::VelHmiInfo::Builder getVehicleInfo();
  inline void setVehicleInfo( ::senseAD::msg::planning::VelHmiInfo::Reader value);
  inline  ::senseAD::msg::planning::VelHmiInfo::Builder initVehicleInfo();
  inline void adoptVehicleInfo(::capnp::Orphan< ::senseAD::msg::planning::VelHmiInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::planning::VelHmiInfo> disownVehicleInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NopHmiPanelInfo::Pipeline {
public:
  typedef NopHmiPanelInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
  inline  ::senseAD::msg::planning::NopHmiLcInfo::Pipeline getLcInfo();
  inline  ::senseAD::msg::planning::NopHmiCipvInfo::Pipeline getCipvInfo();
  inline  ::senseAD::msg::planning::NopHmiRoadInfo::Pipeline getRoadInfo();
  inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Pipeline getDodgeInfo();
  inline  ::senseAD::msg::planning::VelHmiInfo::Pipeline getVehicleInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ASStateMachine::Reader {
public:
  typedef ASStateMachine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline  ::uint8_t getFcwMode() const;

  inline  ::uint8_t getAebMode() const;

  inline  ::uint8_t getLkaMode() const;

  inline  ::uint8_t getElkMode() const;

  inline  ::uint8_t getLdwMode() const;

  inline  ::uint8_t getShadowMode() const;

  inline  ::uint32_t getLookIndex() const;

  inline  ::uint8_t getFctbMode() const;

  inline  ::uint8_t getRctbMode() const;

  inline  ::uint8_t getEsaMode() const;

  inline  ::uint8_t getAesMode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ASStateMachine::Builder {
public:
  typedef ASStateMachine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline  ::uint8_t getFcwMode();
  inline void setFcwMode( ::uint8_t value);

  inline  ::uint8_t getAebMode();
  inline void setAebMode( ::uint8_t value);

  inline  ::uint8_t getLkaMode();
  inline void setLkaMode( ::uint8_t value);

  inline  ::uint8_t getElkMode();
  inline void setElkMode( ::uint8_t value);

  inline  ::uint8_t getLdwMode();
  inline void setLdwMode( ::uint8_t value);

  inline  ::uint8_t getShadowMode();
  inline void setShadowMode( ::uint8_t value);

  inline  ::uint32_t getLookIndex();
  inline void setLookIndex( ::uint32_t value);

  inline  ::uint8_t getFctbMode();
  inline void setFctbMode( ::uint8_t value);

  inline  ::uint8_t getRctbMode();
  inline void setRctbMode( ::uint8_t value);

  inline  ::uint8_t getEsaMode();
  inline void setEsaMode( ::uint8_t value);

  inline  ::uint8_t getAesMode();
  inline void setAesMode( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ASStateMachine::Pipeline {
public:
  typedef ASStateMachine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::senseAD::msg::planning::NopHmiLcInfo::LcType NopHmiLcInfo::Reader::getLcType() const {
  return _reader.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::LcType NopHmiLcInfo::Builder::getLcType() {
  return _builder.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NopHmiLcInfo::Builder::setLcType( ::senseAD::msg::planning::NopHmiLcInfo::LcType value) {
  _builder.setDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::MlcType NopHmiLcInfo::Reader::getMlcType() const {
  return _reader.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::MlcType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::MlcType NopHmiLcInfo::Builder::getMlcType() {
  return _builder.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::MlcType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NopHmiLcInfo::Builder::setMlcType( ::senseAD::msg::planning::NopHmiLcInfo::MlcType value) {
  _builder.setDataField< ::senseAD::msg::planning::NopHmiLcInfo::MlcType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::LcStage NopHmiLcInfo::Reader::getLcStage() const {
  return _reader.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcStage>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::LcStage NopHmiLcInfo::Builder::getLcStage() {
  return _builder.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcStage>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NopHmiLcInfo::Builder::setLcStage( ::senseAD::msg::planning::NopHmiLcInfo::LcStage value) {
  _builder.setDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcStage>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::LcDirection NopHmiLcInfo::Reader::getLcDirection() const {
  return _reader.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcDirection>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::planning::NopHmiLcInfo::LcDirection NopHmiLcInfo::Builder::getLcDirection() {
  return _builder.getDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcDirection>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void NopHmiLcInfo::Builder::setLcDirection( ::senseAD::msg::planning::NopHmiLcInfo::LcDirection value) {
  _builder.setDataField< ::senseAD::msg::planning::NopHmiLcInfo::LcDirection>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t NopHmiLcInfo::Reader::getTargetLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t NopHmiLcInfo::Builder::getTargetLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NopHmiLcInfo::Builder::setTargetLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool NopHmiCipvInfo::Reader::getHasCipv() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool NopHmiCipvInfo::Builder::getHasCipv() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NopHmiCipvInfo::Builder::setHasCipv(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NopHmiCipvInfo::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NopHmiCipvInfo::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NopHmiCipvInfo::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float NopHmiRoadInfo::Reader::getVelLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float NopHmiRoadInfo::Builder::getVelLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NopHmiRoadInfo::Builder::setVelLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool NopHmiDodgeInfo::Reader::hasTruckId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiDodgeInfo::Builder::hasTruckId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader NopHmiDodgeInfo::Reader::getTruckId() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder NopHmiDodgeInfo::Builder::getTruckId() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void NopHmiDodgeInfo::Builder::setTruckId( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void NopHmiDodgeInfo::Builder::setTruckId(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder NopHmiDodgeInfo::Builder::initTruckId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void NopHmiDodgeInfo::Builder::adoptTruckId(
    ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> NopHmiDodgeInfo::Builder::disownTruckId() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool NopHmiDodgeInfo::Reader::hasObjectId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiDodgeInfo::Builder::hasObjectId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader NopHmiDodgeInfo::Reader::getObjectId() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder NopHmiDodgeInfo::Builder::getObjectId() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void NopHmiDodgeInfo::Builder::setObjectId( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void NopHmiDodgeInfo::Builder::setObjectId(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder NopHmiDodgeInfo::Builder::initObjectId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void NopHmiDodgeInfo::Builder::adoptObjectId(
    ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> NopHmiDodgeInfo::Builder::disownObjectId() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t VelHmiInfo::Reader::getSelectedTimeHeadway() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t VelHmiInfo::Builder::getSelectedTimeHeadway() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VelHmiInfo::Builder::setSelectedTimeHeadway( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t VelHmiInfo::Reader::getSelectedSpeed() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t VelHmiInfo::Builder::getSelectedSpeed() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VelHmiInfo::Builder::setSelectedSpeed( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t VelHmiInfo::Reader::getVehicleState() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t VelHmiInfo::Builder::getVehicleState() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void VelHmiInfo::Builder::setVehicleState( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool NopHmiPanelInfo::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiPanelInfo::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader NopHmiPanelInfo::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder NopHmiPanelInfo::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline NopHmiPanelInfo::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void NopHmiPanelInfo::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder NopHmiPanelInfo::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void NopHmiPanelInfo::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> NopHmiPanelInfo::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool NopHmiPanelInfo::Reader::hasLcInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiPanelInfo::Builder::hasLcInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::planning::NopHmiLcInfo::Reader NopHmiPanelInfo::Reader::getLcInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiLcInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::planning::NopHmiLcInfo::Builder NopHmiPanelInfo::Builder::getLcInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiLcInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::planning::NopHmiLcInfo::Pipeline NopHmiPanelInfo::Pipeline::getLcInfo() {
  return  ::senseAD::msg::planning::NopHmiLcInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void NopHmiPanelInfo::Builder::setLcInfo( ::senseAD::msg::planning::NopHmiLcInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiLcInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::planning::NopHmiLcInfo::Builder NopHmiPanelInfo::Builder::initLcInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiLcInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void NopHmiPanelInfo::Builder::adoptLcInfo(
    ::capnp::Orphan< ::senseAD::msg::planning::NopHmiLcInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiLcInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiLcInfo> NopHmiPanelInfo::Builder::disownLcInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiLcInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool NopHmiPanelInfo::Reader::hasCipvInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiPanelInfo::Builder::hasCipvInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::planning::NopHmiCipvInfo::Reader NopHmiPanelInfo::Reader::getCipvInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiCipvInfo>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::planning::NopHmiCipvInfo::Builder NopHmiPanelInfo::Builder::getCipvInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiCipvInfo>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::planning::NopHmiCipvInfo::Pipeline NopHmiPanelInfo::Pipeline::getCipvInfo() {
  return  ::senseAD::msg::planning::NopHmiCipvInfo::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void NopHmiPanelInfo::Builder::setCipvInfo( ::senseAD::msg::planning::NopHmiCipvInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiCipvInfo>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::planning::NopHmiCipvInfo::Builder NopHmiPanelInfo::Builder::initCipvInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiCipvInfo>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void NopHmiPanelInfo::Builder::adoptCipvInfo(
    ::capnp::Orphan< ::senseAD::msg::planning::NopHmiCipvInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiCipvInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiCipvInfo> NopHmiPanelInfo::Builder::disownCipvInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiCipvInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool NopHmiPanelInfo::Reader::hasRoadInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiPanelInfo::Builder::hasRoadInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::planning::NopHmiRoadInfo::Reader NopHmiPanelInfo::Reader::getRoadInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiRoadInfo>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::planning::NopHmiRoadInfo::Builder NopHmiPanelInfo::Builder::getRoadInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiRoadInfo>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::planning::NopHmiRoadInfo::Pipeline NopHmiPanelInfo::Pipeline::getRoadInfo() {
  return  ::senseAD::msg::planning::NopHmiRoadInfo::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void NopHmiPanelInfo::Builder::setRoadInfo( ::senseAD::msg::planning::NopHmiRoadInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiRoadInfo>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::planning::NopHmiRoadInfo::Builder NopHmiPanelInfo::Builder::initRoadInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiRoadInfo>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void NopHmiPanelInfo::Builder::adoptRoadInfo(
    ::capnp::Orphan< ::senseAD::msg::planning::NopHmiRoadInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiRoadInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiRoadInfo> NopHmiPanelInfo::Builder::disownRoadInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiRoadInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool NopHmiPanelInfo::Reader::hasDodgeInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiPanelInfo::Builder::hasDodgeInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Reader NopHmiPanelInfo::Reader::getDodgeInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiDodgeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Builder NopHmiPanelInfo::Builder::getDodgeInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiDodgeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Pipeline NopHmiPanelInfo::Pipeline::getDodgeInfo() {
  return  ::senseAD::msg::planning::NopHmiDodgeInfo::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void NopHmiPanelInfo::Builder::setDodgeInfo( ::senseAD::msg::planning::NopHmiDodgeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiDodgeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::planning::NopHmiDodgeInfo::Builder NopHmiPanelInfo::Builder::initDodgeInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiDodgeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void NopHmiPanelInfo::Builder::adoptDodgeInfo(
    ::capnp::Orphan< ::senseAD::msg::planning::NopHmiDodgeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiDodgeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::planning::NopHmiDodgeInfo> NopHmiPanelInfo::Builder::disownDodgeInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::NopHmiDodgeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool NopHmiPanelInfo::Reader::hasVehicleInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool NopHmiPanelInfo::Builder::hasVehicleInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::planning::VelHmiInfo::Reader NopHmiPanelInfo::Reader::getVehicleInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::VelHmiInfo>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::planning::VelHmiInfo::Builder NopHmiPanelInfo::Builder::getVehicleInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::VelHmiInfo>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::planning::VelHmiInfo::Pipeline NopHmiPanelInfo::Pipeline::getVehicleInfo() {
  return  ::senseAD::msg::planning::VelHmiInfo::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void NopHmiPanelInfo::Builder::setVehicleInfo( ::senseAD::msg::planning::VelHmiInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::VelHmiInfo>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::planning::VelHmiInfo::Builder NopHmiPanelInfo::Builder::initVehicleInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::VelHmiInfo>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void NopHmiPanelInfo::Builder::adoptVehicleInfo(
    ::capnp::Orphan< ::senseAD::msg::planning::VelHmiInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::planning::VelHmiInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::planning::VelHmiInfo> NopHmiPanelInfo::Builder::disownVehicleInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::planning::VelHmiInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool ASStateMachine::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ASStateMachine::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader ASStateMachine::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder ASStateMachine::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline ASStateMachine::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ASStateMachine::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder ASStateMachine::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ASStateMachine::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> ASStateMachine::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t ASStateMachine::Reader::getFcwMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getFcwMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setFcwMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getAebMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getAebMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setAebMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getLkaMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getLkaMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setLkaMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getElkMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getElkMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setElkMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getLdwMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getLdwMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setLdwMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getShadowMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getShadowMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setShadowMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t ASStateMachine::Reader::getLookIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t ASStateMachine::Builder::getLookIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setLookIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getFctbMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getFctbMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setFctbMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getRctbMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getRctbMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setRctbMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getEsaMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getEsaMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setEsaMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ASStateMachine::Reader::getAesMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ASStateMachine::Builder::getAesMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void ASStateMachine::Builder::setAesMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

