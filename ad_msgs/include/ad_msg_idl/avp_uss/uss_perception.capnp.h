// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: uss_perception.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(808405ad420e9530);
CAPNP_DECLARE_SCHEMA(890169cc8cdeafd3);
CAPNP_DECLARE_SCHEMA(cb39525bfaf2c39b);
CAPNP_DECLARE_SCHEMA(843a4d2029573eb5);
CAPNP_DECLARE_SCHEMA(92047e3e185525bf);
CAPNP_DECLARE_SCHEMA(fa089b0a579ec03b);
CAPNP_DECLARE_SCHEMA(e17134d7c55ba722);
CAPNP_DECLARE_SCHEMA(dcc59c4145893b83);
CAPNP_DECLARE_SCHEMA(da0f4738c4d2630c);
CAPNP_DECLARE_SCHEMA(9a323f2ac4b70814);
CAPNP_DECLARE_SCHEMA(c2e588946ff883a0);
CAPNP_DECLARE_SCHEMA(fb494ad7d6ce4ffc);
CAPNP_DECLARE_SCHEMA(e5452dd8f4b4abb9);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace avp_perception {

struct UssEcho {
  UssEcho() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(808405ad420e9530, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssObstacleInfo {
  UssObstacleInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(890169cc8cdeafd3, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssPEBInfo {
  UssPEBInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb39525bfaf2c39b, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssSlot {
  UssSlot() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(843a4d2029573eb5, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssSlotsInfo {
  UssSlotsInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92047e3e185525bf, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssPoint {
  UssPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa089b0a579ec03b, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssObjLine {
  UssObjLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e17134d7c55ba722, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssObjLinesInfo {
  UssObjLinesInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dcc59c4145893b83, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssFusedPoint {
  UssFusedPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da0f4738c4d2630c, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssFusedStaticMap {
  UssFusedStaticMap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a323f2ac4b70814, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point {
  Point() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2e588946ff883a0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssFreespace {
  UssFreespace() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb494ad7d6ce4ffc, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UssFreespaces {
  UssFreespaces() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5452dd8f4b4abb9, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class UssEcho::Reader {
public:
  typedef UssEcho Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRecvTimeNs() const;

  inline bool hasDistance() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getDistance() const;

  inline bool hasWidth() const;
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader getWidth() const;

  inline bool hasHeight() const;
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader getHeight() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssEcho::Builder {
public:
  typedef UssEcho Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRecvTimeNs();
  inline void setRecvTimeNs( ::uint64_t value);

  inline bool hasDistance();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getDistance();
  inline void setDistance( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setDistance(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initDistance(unsigned int size);
  inline void adoptDistance(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownDistance();

  inline bool hasWidth();
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder getWidth();
  inline void setWidth( ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWidth(::kj::ArrayPtr<const  ::int16_t> value);
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder initWidth(unsigned int size);
  inline void adoptWidth(::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>> disownWidth();

  inline bool hasHeight();
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder getHeight();
  inline void setHeight( ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setHeight(::kj::ArrayPtr<const  ::int16_t> value);
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder initHeight(unsigned int size);
  inline void adoptHeight(::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>> disownHeight();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssEcho::Pipeline {
public:
  typedef UssEcho Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssObstacleInfo::Reader {
public:
  typedef UssObstacleInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs() const;

  inline bool hasUssEchoInfoList() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Reader getUssEchoInfoList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssObstacleInfo::Builder {
public:
  typedef UssObstacleInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs();
  inline void setFrameTimestampNs( ::uint64_t value);

  inline bool hasUssEchoInfoList();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Builder getUssEchoInfoList();
  inline void setUssEchoInfoList( ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Builder initUssEchoInfoList(unsigned int size);
  inline void adoptUssEchoInfoList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>> disownUssEchoInfoList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssObstacleInfo::Pipeline {
public:
  typedef UssObstacleInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssPEBInfo::Reader {
public:
  typedef UssPEBInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs() const;

  inline bool hasDistance() const;
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader getDistance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssPEBInfo::Builder {
public:
  typedef UssPEBInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs();
  inline void setFrameTimestampNs( ::uint64_t value);

  inline bool hasDistance();
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder getDistance();
  inline void setDistance( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setDistance(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder initDistance(unsigned int size);
  inline void adoptDistance(::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> disownDistance();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssPEBInfo::Pipeline {
public:
  typedef UssPEBInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssSlot::Reader {
public:
  typedef UssSlot Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getType() const;

  inline float getObj0X() const;

  inline float getObj0Y() const;

  inline float getObj1X() const;

  inline float getObj1Y() const;

  inline float getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssSlot::Builder {
public:
  typedef UssSlot Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getType();
  inline void setType( ::uint32_t value);

  inline float getObj0X();
  inline void setObj0X(float value);

  inline float getObj0Y();
  inline void setObj0Y(float value);

  inline float getObj1X();
  inline void setObj1X(float value);

  inline float getObj1Y();
  inline void setObj1Y(float value);

  inline float getDepth();
  inline void setDepth(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssSlot::Pipeline {
public:
  typedef UssSlot Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssSlotsInfo::Reader {
public:
  typedef UssSlotsInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs() const;

  inline bool hasSlotsList() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Reader getSlotsList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssSlotsInfo::Builder {
public:
  typedef UssSlotsInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs();
  inline void setFrameTimestampNs( ::uint64_t value);

  inline bool hasSlotsList();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Builder getSlotsList();
  inline void setSlotsList( ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Builder initSlotsList(unsigned int size);
  inline void adoptSlotsList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>> disownSlotsList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssSlotsInfo::Pipeline {
public:
  typedef UssSlotsInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssPoint::Reader {
public:
  typedef UssPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline  ::int32_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssPoint::Builder {
public:
  typedef UssPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline  ::int32_t getType();
  inline void setType( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssPoint::Pipeline {
public:
  typedef UssPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssObjLine::Reader {
public:
  typedef UssObjLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs() const;

  inline bool hasPoint0() const;
  inline  ::senseAD::msg::avp_perception::UssPoint::Reader getPoint0() const;

  inline bool hasPoint1() const;
  inline  ::senseAD::msg::avp_perception::UssPoint::Reader getPoint1() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssObjLine::Builder {
public:
  typedef UssObjLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs();
  inline void setFrameTimestampNs( ::uint64_t value);

  inline bool hasPoint0();
  inline  ::senseAD::msg::avp_perception::UssPoint::Builder getPoint0();
  inline void setPoint0( ::senseAD::msg::avp_perception::UssPoint::Reader value);
  inline  ::senseAD::msg::avp_perception::UssPoint::Builder initPoint0();
  inline void adoptPoint0(::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint> disownPoint0();

  inline bool hasPoint1();
  inline  ::senseAD::msg::avp_perception::UssPoint::Builder getPoint1();
  inline void setPoint1( ::senseAD::msg::avp_perception::UssPoint::Reader value);
  inline  ::senseAD::msg::avp_perception::UssPoint::Builder initPoint1();
  inline void adoptPoint1(::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint> disownPoint1();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssObjLine::Pipeline {
public:
  typedef UssObjLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::UssPoint::Pipeline getPoint0();
  inline  ::senseAD::msg::avp_perception::UssPoint::Pipeline getPoint1();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssObjLinesInfo::Reader {
public:
  typedef UssObjLinesInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs() const;

  inline bool hasObjLinesList() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Reader getObjLinesList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssObjLinesInfo::Builder {
public:
  typedef UssObjLinesInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFrameTimestampNs();
  inline void setFrameTimestampNs( ::uint64_t value);

  inline bool hasObjLinesList();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Builder getObjLinesList();
  inline void setObjLinesList( ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Builder initObjLinesList(unsigned int size);
  inline void adoptObjLinesList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>> disownObjLinesList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssObjLinesInfo::Pipeline {
public:
  typedef UssObjLinesInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssFusedPoint::Reader {
public:
  typedef UssFusedPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint16_t getAge() const;

  inline  ::int16_t getX() const;

  inline  ::int16_t getY() const;

  inline  ::uint8_t getLowProb() const;

  inline  ::uint8_t getHighProb() const;

  inline  ::uint8_t getExistProb() const;

  inline  ::uint8_t getFreeProb() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssFusedPoint::Builder {
public:
  typedef UssFusedPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint16_t getAge();
  inline void setAge( ::uint16_t value);

  inline  ::int16_t getX();
  inline void setX( ::int16_t value);

  inline  ::int16_t getY();
  inline void setY( ::int16_t value);

  inline  ::uint8_t getLowProb();
  inline void setLowProb( ::uint8_t value);

  inline  ::uint8_t getHighProb();
  inline void setHighProb( ::uint8_t value);

  inline  ::uint8_t getExistProb();
  inline void setExistProb( ::uint8_t value);

  inline  ::uint8_t getFreeProb();
  inline void setFreeProb( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssFusedPoint::Pipeline {
public:
  typedef UssFusedPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssFusedStaticMap::Reader {
public:
  typedef UssFusedStaticMap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint16_t getSeq() const;

  inline  ::uint16_t getFusedPointsSize() const;

  inline bool hasFusedPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Reader getFusedPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssFusedStaticMap::Builder {
public:
  typedef UssFusedStaticMap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint16_t getSeq();
  inline void setSeq( ::uint16_t value);

  inline  ::uint16_t getFusedPointsSize();
  inline void setFusedPointsSize( ::uint16_t value);

  inline bool hasFusedPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Builder getFusedPoints();
  inline void setFusedPoints( ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Builder initFusedPoints(unsigned int size);
  inline void adoptFusedPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>> disownFusedPoints();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssFusedStaticMap::Pipeline {
public:
  typedef UssFusedStaticMap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point::Reader {
public:
  typedef Point Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point::Builder {
public:
  typedef Point Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point::Pipeline {
public:
  typedef Point Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssFreespace::Reader {
public:
  typedef UssFreespace Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getPolygonPointsSize() const;

  inline  ::uint32_t getSignalWay() const;

  inline float getProbability() const;

  inline bool hasPolygonPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Reader getPolygonPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssFreespace::Builder {
public:
  typedef UssFreespace Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getPolygonPointsSize();
  inline void setPolygonPointsSize( ::uint32_t value);

  inline  ::uint32_t getSignalWay();
  inline void setSignalWay( ::uint32_t value);

  inline float getProbability();
  inline void setProbability(float value);

  inline bool hasPolygonPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Builder getPolygonPoints();
  inline void setPolygonPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Builder initPolygonPoints(unsigned int size);
  inline void adoptPolygonPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>> disownPolygonPoints();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssFreespace::Pipeline {
public:
  typedef UssFreespace Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UssFreespaces::Reader {
public:
  typedef UssFreespaces Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getFreespacesSize() const;

  inline bool hasFreespaces() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Reader getFreespaces() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UssFreespaces::Builder {
public:
  typedef UssFreespaces Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getFreespacesSize();
  inline void setFreespacesSize( ::uint32_t value);

  inline bool hasFreespaces();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Builder getFreespaces();
  inline void setFreespaces( ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Builder initFreespaces(unsigned int size);
  inline void adoptFreespaces(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>> disownFreespaces();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UssFreespaces::Pipeline {
public:
  typedef UssFreespaces Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t UssEcho::Reader::getRecvTimeNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssEcho::Builder::getRecvTimeNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssEcho::Builder::setRecvTimeNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UssEcho::Reader::hasDistance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssEcho::Builder::hasDistance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader UssEcho::Reader::getDistance() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder UssEcho::Builder::getDistance() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssEcho::Builder::setDistance( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void UssEcho::Builder::setDistance(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder UssEcho::Builder::initDistance(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssEcho::Builder::adoptDistance(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> UssEcho::Builder::disownDistance() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UssEcho::Reader::hasWidth() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool UssEcho::Builder::hasWidth() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader UssEcho::Reader::getWidth() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder UssEcho::Builder::getWidth() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void UssEcho::Builder::setWidth( ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void UssEcho::Builder::setWidth(::kj::ArrayPtr<const  ::int16_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder UssEcho::Builder::initWidth(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void UssEcho::Builder::adoptWidth(
    ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>> UssEcho::Builder::disownWidth() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool UssEcho::Reader::hasHeight() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool UssEcho::Builder::hasHeight() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader UssEcho::Reader::getHeight() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder UssEcho::Builder::getHeight() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void UssEcho::Builder::setHeight( ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void UssEcho::Builder::setHeight(::kj::ArrayPtr<const  ::int16_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder UssEcho::Builder::initHeight(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void UssEcho::Builder::adoptHeight(
    ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>> UssEcho::Builder::disownHeight() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint64_t UssObstacleInfo::Reader::getFrameTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssObstacleInfo::Builder::getFrameTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssObstacleInfo::Builder::setFrameTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UssObstacleInfo::Reader::hasUssEchoInfoList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssObstacleInfo::Builder::hasUssEchoInfoList() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Reader UssObstacleInfo::Reader::getUssEchoInfoList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Builder UssObstacleInfo::Builder::getUssEchoInfoList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssObstacleInfo::Builder::setUssEchoInfoList( ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>::Builder UssObstacleInfo::Builder::initUssEchoInfoList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssObstacleInfo::Builder::adoptUssEchoInfoList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>> UssObstacleInfo::Builder::disownUssEchoInfoList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssEcho,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t UssPEBInfo::Reader::getFrameTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssPEBInfo::Builder::getFrameTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssPEBInfo::Builder::setFrameTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UssPEBInfo::Reader::hasDistance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssPEBInfo::Builder::hasDistance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader UssPEBInfo::Reader::getDistance() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder UssPEBInfo::Builder::getDistance() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssPEBInfo::Builder::setDistance( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void UssPEBInfo::Builder::setDistance(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder UssPEBInfo::Builder::initDistance(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssPEBInfo::Builder::adoptDistance(
    ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> UssPEBInfo::Builder::disownDistance() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t UssSlot::Reader::getType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t UssSlot::Builder::getType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssSlot::Builder::setType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float UssSlot::Reader::getObj0X() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float UssSlot::Builder::getObj0X() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void UssSlot::Builder::setObj0X(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float UssSlot::Reader::getObj0Y() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float UssSlot::Builder::getObj0Y() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void UssSlot::Builder::setObj0Y(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float UssSlot::Reader::getObj1X() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float UssSlot::Builder::getObj1X() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void UssSlot::Builder::setObj1X(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float UssSlot::Reader::getObj1Y() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float UssSlot::Builder::getObj1Y() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void UssSlot::Builder::setObj1Y(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float UssSlot::Reader::getDepth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float UssSlot::Builder::getDepth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void UssSlot::Builder::setDepth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t UssSlotsInfo::Reader::getFrameTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssSlotsInfo::Builder::getFrameTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssSlotsInfo::Builder::setFrameTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UssSlotsInfo::Reader::hasSlotsList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssSlotsInfo::Builder::hasSlotsList() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Reader UssSlotsInfo::Reader::getSlotsList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Builder UssSlotsInfo::Builder::getSlotsList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssSlotsInfo::Builder::setSlotsList( ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>::Builder UssSlotsInfo::Builder::initSlotsList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssSlotsInfo::Builder::adoptSlotsList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>> UssSlotsInfo::Builder::disownSlotsList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssSlot,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float UssPoint::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float UssPoint::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssPoint::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float UssPoint::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float UssPoint::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void UssPoint::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t UssPoint::Reader::getType() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t UssPoint::Builder::getType() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void UssPoint::Builder::setType( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t UssObjLine::Reader::getFrameTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssObjLine::Builder::getFrameTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssObjLine::Builder::setFrameTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UssObjLine::Reader::hasPoint0() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssObjLine::Builder::hasPoint0() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::UssPoint::Reader UssObjLine::Reader::getPoint0() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::UssPoint::Builder UssObjLine::Builder::getPoint0() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::UssPoint::Pipeline UssObjLine::Pipeline::getPoint0() {
  return  ::senseAD::msg::avp_perception::UssPoint::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void UssObjLine::Builder::setPoint0( ::senseAD::msg::avp_perception::UssPoint::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::UssPoint::Builder UssObjLine::Builder::initPoint0() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssObjLine::Builder::adoptPoint0(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint> UssObjLine::Builder::disownPoint0() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UssObjLine::Reader::hasPoint1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool UssObjLine::Builder::hasPoint1() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::UssPoint::Reader UssObjLine::Reader::getPoint1() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::UssPoint::Builder UssObjLine::Builder::getPoint1() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::UssPoint::Pipeline UssObjLine::Pipeline::getPoint1() {
  return  ::senseAD::msg::avp_perception::UssPoint::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void UssObjLine::Builder::setPoint1( ::senseAD::msg::avp_perception::UssPoint::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::UssPoint::Builder UssObjLine::Builder::initPoint1() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void UssObjLine::Builder::adoptPoint1(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::UssPoint> UssObjLine::Builder::disownPoint1() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::UssPoint>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t UssObjLinesInfo::Reader::getFrameTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssObjLinesInfo::Builder::getFrameTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssObjLinesInfo::Builder::setFrameTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UssObjLinesInfo::Reader::hasObjLinesList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssObjLinesInfo::Builder::hasObjLinesList() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Reader UssObjLinesInfo::Reader::getObjLinesList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Builder UssObjLinesInfo::Builder::getObjLinesList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssObjLinesInfo::Builder::setObjLinesList( ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>::Builder UssObjLinesInfo::Builder::initObjLinesList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssObjLinesInfo::Builder::adoptObjLinesList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>> UssObjLinesInfo::Builder::disownObjLinesList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssObjLine,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t UssFusedPoint::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssFusedPoint::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t UssFusedPoint::Reader::getAge() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t UssFusedPoint::Builder::getAge() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setAge( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t UssFusedPoint::Reader::getX() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int16_t UssFusedPoint::Builder::getX() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setX( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t UssFusedPoint::Reader::getY() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int16_t UssFusedPoint::Builder::getY() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setY( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t UssFusedPoint::Reader::getLowProb() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t UssFusedPoint::Builder::getLowProb() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setLowProb( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t UssFusedPoint::Reader::getHighProb() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t UssFusedPoint::Builder::getHighProb() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setHighProb( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t UssFusedPoint::Reader::getExistProb() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t UssFusedPoint::Builder::getExistProb() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setExistProb( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t UssFusedPoint::Reader::getFreeProb() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t UssFusedPoint::Builder::getFreeProb() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void UssFusedPoint::Builder::setFreeProb( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t UssFusedStaticMap::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssFusedStaticMap::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssFusedStaticMap::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t UssFusedStaticMap::Reader::getSeq() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t UssFusedStaticMap::Builder::getSeq() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void UssFusedStaticMap::Builder::setSeq( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t UssFusedStaticMap::Reader::getFusedPointsSize() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t UssFusedStaticMap::Builder::getFusedPointsSize() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void UssFusedStaticMap::Builder::setFusedPointsSize( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool UssFusedStaticMap::Reader::hasFusedPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssFusedStaticMap::Builder::hasFusedPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Reader UssFusedStaticMap::Reader::getFusedPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Builder UssFusedStaticMap::Builder::getFusedPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssFusedStaticMap::Builder::setFusedPoints( ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>::Builder UssFusedStaticMap::Builder::initFusedPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssFusedStaticMap::Builder::adoptFusedPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>> UssFusedStaticMap::Builder::disownFusedPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFusedPoint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Point::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Point::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Point::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Point::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t UssFreespace::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssFreespace::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssFreespace::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UssFreespace::Reader::getPolygonPointsSize() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t UssFreespace::Builder::getPolygonPointsSize() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void UssFreespace::Builder::setPolygonPointsSize( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UssFreespace::Reader::getSignalWay() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t UssFreespace::Builder::getSignalWay() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void UssFreespace::Builder::setSignalWay( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float UssFreespace::Reader::getProbability() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float UssFreespace::Builder::getProbability() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void UssFreespace::Builder::setProbability(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool UssFreespace::Reader::hasPolygonPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssFreespace::Builder::hasPolygonPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Reader UssFreespace::Reader::getPolygonPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Builder UssFreespace::Builder::getPolygonPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssFreespace::Builder::setPolygonPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>::Builder UssFreespace::Builder::initPolygonPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssFreespace::Builder::adoptPolygonPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>> UssFreespace::Builder::disownPolygonPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t UssFreespaces::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UssFreespaces::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UssFreespaces::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UssFreespaces::Reader::getFreespacesSize() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t UssFreespaces::Builder::getFreespacesSize() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void UssFreespaces::Builder::setFreespacesSize( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool UssFreespaces::Reader::hasFreespaces() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UssFreespaces::Builder::hasFreespaces() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Reader UssFreespaces::Reader::getFreespaces() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Builder UssFreespaces::Builder::getFreespaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UssFreespaces::Builder::setFreespaces( ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>::Builder UssFreespaces::Builder::initFreespaces(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UssFreespaces::Builder::adoptFreespaces(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>> UssFreespaces::Builder::disownFreespaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssFreespace,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

