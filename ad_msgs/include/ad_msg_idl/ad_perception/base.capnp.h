// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: base.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <ad_msg_idl/std_msgs/typed_data_list.capnp.h>

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(db6d2291e9953353);
CAPNP_DECLARE_SCHEMA(8e995ecc94bf41c8);
CAPNP_DECLARE_SCHEMA(c7b471c111847150);
CAPNP_DECLARE_SCHEMA(e8e5d3e52272482f);
CAPNP_DECLARE_SCHEMA(946ab94c21a825f6);
CAPNP_DECLARE_SCHEMA(b93d34cb7e03d2ca);
CAPNP_DECLARE_SCHEMA(c96cd34df8f4eebe);
CAPNP_DECLARE_SCHEMA(db57d6181627a4d4);
CAPNP_DECLARE_SCHEMA(9a5139468055673c);
CAPNP_DECLARE_SCHEMA(c6bf83416ea3362f);
CAPNP_DECLARE_SCHEMA(e271db45bfca370e);
CAPNP_DECLARE_SCHEMA(8d3e7e7a5fee9f21);
enum class TrafficSignal_8d3e7e7a5fee9f21: uint16_t {
  SIGNAL_NONE,
  SIGNAL_GREEN,
  SIGNAL_YELLOW,
  SIGNAL_RED,
  SIGNAL_GREEN_FLASH,
  SIGNAL_YELLOW_FLASH,
  SIGNAL_BLACK,
  SIGNAL_GREEN_NUMBER,
};
CAPNP_DECLARE_ENUM(TrafficSignal, 8d3e7e7a5fee9f21);
CAPNP_DECLARE_SCHEMA(e82ec07943add14a);
CAPNP_DECLARE_SCHEMA(a98bfa4ba0feaf9c);
CAPNP_DECLARE_SCHEMA(cbd4897a642c68e2);
CAPNP_DECLARE_SCHEMA(cd4fa9e987a857aa);
CAPNP_DECLARE_SCHEMA(d9a89e45ee153e20);
CAPNP_DECLARE_SCHEMA(df4b50b2de09a83f);
CAPNP_DECLARE_SCHEMA(9088de9ccc090e23);
CAPNP_DECLARE_SCHEMA(914a9cc37f20c8dd);
CAPNP_DECLARE_SCHEMA(f26321ae01e8e167);
CAPNP_DECLARE_SCHEMA(bac173d8b8deacdb);
CAPNP_DECLARE_SCHEMA(a22a4780f9e7673b);
CAPNP_DECLARE_SCHEMA(93e23bddce78c77c);
CAPNP_DECLARE_SCHEMA(f0477afcab63064f);
CAPNP_DECLARE_SCHEMA(87da02e85c95adb6);
enum class LaneLineType_87da02e85c95adb6: uint16_t {
  LANE_LINE_NONE_TYPE,
  SINGLE_DASHED,
  SINGLE_SOLID,
  LEFT_DASHED_RIGHT_SOLID,
  LEFT_SOLID_RIGHT_DASHED,
  DOUBLE_SOLID,
  DOUBLE_DASHED,
  SAWTOOTH_SOLID,
  FISHBONE_DASHED,
  FISHBONE_SOLID,
  ROAD_EDGE,
  FENCE,
  LANE_LINE_UNKNOWN_TYPE,
  LANELINE_TYPE_ENUM_MAX,
};
CAPNP_DECLARE_ENUM(LaneLineType, 87da02e85c95adb6);
CAPNP_DECLARE_SCHEMA(d103add039b51ba7);
enum class LaneLineColor_d103add039b51ba7: uint16_t {
  LANE_LINE_NONE_COLOR,
  LANE_LINE_WHITE,
  LANE_LINE_YELLOE,
  LANE_LINE_UNKNOWN,
  LANE_LINE_COLOR_MAX,
};
CAPNP_DECLARE_ENUM(LaneLineColor, d103add039b51ba7);
CAPNP_DECLARE_SCHEMA(cd05b34d81f73550);
CAPNP_DECLARE_SCHEMA(86fb0550f8cef13e);
CAPNP_DECLARE_SCHEMA(ee61947049989c9e);
enum class TurnType_ee61947049989c9e: uint16_t {
  TURNTYPE_FREE,
  TURNTYPE_TURN_LEFT,
  TURNTYPE_TURN_RIGHT,
  TURNTYPE_LEFT_AROUND,
  TURNTYPE_RIGHT_AROUND,
  TURNTYPE_STRAIGHT,
};
CAPNP_DECLARE_ENUM(TurnType, ee61947049989c9e);
CAPNP_DECLARE_SCHEMA(a9491a6fece68470);
CAPNP_DECLARE_SCHEMA(d0f4e035adc71079);
CAPNP_DECLARE_SCHEMA(a45b6a60fcbfcdbf);
CAPNP_DECLARE_SCHEMA(ae8707895bd02f3d);
enum class RegionType_ae8707895bd02f3d: uint16_t {
  REGION_TYPE_NONE,
  DIVERSION_AREA,
  FREESPACE,
  ROAD_HUMP,
  REGION_TYPE_UNKNOWN,
};
CAPNP_DECLARE_ENUM(RegionType, ae8707895bd02f3d);
CAPNP_DECLARE_SCHEMA(f06b35d34d0a0acb);
CAPNP_DECLARE_SCHEMA(a44d02bc36b2d2f5);
CAPNP_DECLARE_SCHEMA(882773bd2f5a5bbe);
CAPNP_DECLARE_SCHEMA(ffb50bb4473d3cdb);
CAPNP_DECLARE_SCHEMA(8a2e26cf621e02cc);
CAPNP_DECLARE_SCHEMA(d842cb0e2f8298d6);
CAPNP_DECLARE_SCHEMA(bedb8d17491f852f);
CAPNP_DECLARE_SCHEMA(ab0952084c1e1fc0);
CAPNP_DECLARE_SCHEMA(eac1672d168c5c3b);
CAPNP_DECLARE_SCHEMA(ad14b624d5d9d1a0);
CAPNP_DECLARE_SCHEMA(e8e7bf3f263eecd2);
CAPNP_DECLARE_SCHEMA(c671c08c5161f72b);
CAPNP_DECLARE_SCHEMA(b4e9ef152ab57ed4);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace avp_perception {

struct Point2i {
  Point2i() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db6d2291e9953353, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point2f {
  Point2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e995ecc94bf41c8, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point3f {
  Point3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c7b471c111847150, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Polygon2D {
  Polygon2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8e5d3e52272482f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Polygon3D {
  Polygon3D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(946ab94c21a825f6, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PolygonBox {
  PolygonBox() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b93d34cb7e03d2ca, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VecPoint2f {
  VecPoint2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c96cd34df8f4eebe, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3d {
  Vector3d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db57d6181627a4d4, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3f {
  Vector3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a5139468055673c, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector4i {
  Vector4i() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6bf83416ea3362f, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Matrix3f {
  Matrix3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e271db45bfca370e, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::TrafficSignal_8d3e7e7a5fee9f21 TrafficSignal;

struct AutomobileLightStatus {
  AutomobileLightStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e82ec07943add14a, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BaseCameraAttribute {
  BaseCameraAttribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a98bfa4ba0feaf9c, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Bbox2D {
  Bbox2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cbd4897a642c68e2, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BirdViewCorners {
  BirdViewCorners() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cd4fa9e987a857aa, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Boundary {
  Boundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9a89e45ee153e20, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraBBox2DInfo {
  CameraBBox2DInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df4b50b2de09a83f, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PositionInfo {
  PositionInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9088de9ccc090e23, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DepthDetPoint {
  DepthDetPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(914a9cc37f20c8dd, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DirectionInfo {
  DirectionInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f26321ae01e8e167, 4, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Freespace {
  Freespace() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bac173d8b8deacdb, 2, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneLine {
  LaneLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a22a4780f9e7673b, 7, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LidarDangerousZone {
  LidarDangerousZone() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93e23bddce78c77c, 3, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LMLaneLine {
  LMLaneLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::LaneLineType_87da02e85c95adb6 LaneLineType;

  typedef ::capnp::schemas::LaneLineColor_d103add039b51ba7 LaneLineColor;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f0477afcab63064f, 3, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LMLanePoint2f {
  LMLanePoint2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cd05b34d81f73550, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LMLaneSpeedLimitSign {
  LMLaneSpeedLimitSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(86fb0550f8cef13e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::TurnType_ee61947049989c9e TurnType;

struct LMLaneTurnTypeSign {
  LMLaneTurnTypeSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9491a6fece68470, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LMPerceptionRoad {
  LMPerceptionRoad() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d0f4e035adc71079, 0, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LMRegion {
  LMRegion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::RegionType_ae8707895bd02f3d RegionType;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a45b6a60fcbfcdbf, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LMSpeedLimitSign {
  LMSpeedLimitSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f06b35d34d0a0acb, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MatchedSensorObjectInfo {
  MatchedSensorObjectInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a44d02bc36b2d2f5, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ModelOutputFeature {
  ModelOutputFeature() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(882773bd2f5a5bbe, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MotionInfo {
  MotionInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffb50bb4473d3cdb, 3, 8)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NonAutomobileVehicleLightStatus {
  NonAutomobileVehicleLightStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a2e26cf621e02cc, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PedestrianIntention {
  PedestrianIntention() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d842cb0e2f8298d6, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RoadArea {
  RoadArea() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bedb8d17491f852f, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RoadStruct {
  RoadStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab0952084c1e1fc0, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SizeInfo {
  SizeInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eac1672d168c5c3b, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StopLine {
  StopLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ad14b624d5d9d1a0, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TLImage2DInfo {
  TLImage2DInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8e7bf3f263eecd2, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrafficLight {
  TrafficLight() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c671c08c5161f72b, 2, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrafficLightGroup {
  TrafficLightGroup() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b4e9ef152ab57ed4, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Point2i::Reader {
public:
  typedef Point2i Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point2i::Builder {
public:
  typedef Point2i Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point2i::Pipeline {
public:
  typedef Point2i Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point2f::Reader {
public:
  typedef Point2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point2f::Builder {
public:
  typedef Point2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point2f::Pipeline {
public:
  typedef Point2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point3f::Reader {
public:
  typedef Point3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point3f::Builder {
public:
  typedef Point3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point3f::Pipeline {
public:
  typedef Point3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Polygon2D::Reader {
public:
  typedef Polygon2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP2d() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getP2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Polygon2D::Builder {
public:
  typedef Polygon2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP2d();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getP2d();
  inline void setP2d( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initP2d(unsigned int size);
  inline void adoptP2d(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownP2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Polygon2D::Pipeline {
public:
  typedef Polygon2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Polygon3D::Reader {
public:
  typedef Polygon3D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP3d() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader getP3d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Polygon3D::Builder {
public:
  typedef Polygon3D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP3d();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder getP3d();
  inline void setP3d( ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder initP3d(unsigned int size);
  inline void adoptP3d(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>> disownP3d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Polygon3D::Pipeline {
public:
  typedef Polygon3D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PolygonBox::Reader {
public:
  typedef PolygonBox Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline bool hasPolygonContour() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getPolygonContour() const;

  inline float getHeightLowerSurface() const;

  inline float getHeightUpperSurface() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PolygonBox::Builder {
public:
  typedef PolygonBox Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline bool hasPolygonContour();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getPolygonContour();
  inline void setPolygonContour( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initPolygonContour(unsigned int size);
  inline void adoptPolygonContour(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownPolygonContour();

  inline float getHeightLowerSurface();
  inline void setHeightLowerSurface(float value);

  inline float getHeightUpperSurface();
  inline void setHeightUpperSurface(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PolygonBox::Pipeline {
public:
  typedef PolygonBox Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VecPoint2f::Reader {
public:
  typedef VecPoint2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVector() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VecPoint2f::Builder {
public:
  typedef VecPoint2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVector();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getVector();
  inline void setVector( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initVector(unsigned int size);
  inline void adoptVector(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VecPoint2f::Pipeline {
public:
  typedef VecPoint2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3d::Reader {
public:
  typedef Vector3d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3d::Builder {
public:
  typedef Vector3d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3d::Pipeline {
public:
  typedef Vector3d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3f::Reader {
public:
  typedef Vector3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3f::Builder {
public:
  typedef Vector3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3f::Pipeline {
public:
  typedef Vector3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector4i::Reader {
public:
  typedef Vector4i Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

  inline  ::int32_t getZ() const;

  inline  ::int32_t getW() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector4i::Builder {
public:
  typedef Vector4i Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

  inline  ::int32_t getZ();
  inline void setZ( ::int32_t value);

  inline  ::int32_t getW();
  inline void setW( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector4i::Pipeline {
public:
  typedef Vector4i Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Matrix3f::Reader {
public:
  typedef Matrix3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasX() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getX() const;

  inline bool hasY() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getY() const;

  inline bool hasZ() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Matrix3f::Builder {
public:
  typedef Matrix3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasX();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getX();
  inline void setX( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initX();
  inline void adoptX(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownX();

  inline bool hasY();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getY();
  inline void setY( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initY();
  inline void adoptY(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownY();

  inline bool hasZ();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getZ();
  inline void setZ( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initZ();
  inline void adoptZ(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownZ();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Matrix3f::Pipeline {
public:
  typedef Matrix3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getX();
  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getY();
  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getZ();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AutomobileLightStatus::Reader {
public:
  typedef AutomobileLightStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn() const;

  inline  ::int32_t getRightTurn() const;

  inline  ::int32_t getHazard() const;

  inline  ::int32_t getBrake() const;

  inline float getLeftTurnConfidence() const;

  inline float getRightTurnConfidence() const;

  inline float getHazardConfidence() const;

  inline float getBrakeConfidence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AutomobileLightStatus::Builder {
public:
  typedef AutomobileLightStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn();
  inline void setLeftTurn( ::int32_t value);

  inline  ::int32_t getRightTurn();
  inline void setRightTurn( ::int32_t value);

  inline  ::int32_t getHazard();
  inline void setHazard( ::int32_t value);

  inline  ::int32_t getBrake();
  inline void setBrake( ::int32_t value);

  inline float getLeftTurnConfidence();
  inline void setLeftTurnConfidence(float value);

  inline float getRightTurnConfidence();
  inline void setRightTurnConfidence(float value);

  inline float getHazardConfidence();
  inline void setHazardConfidence(float value);

  inline float getBrakeConfidence();
  inline void setBrakeConfidence(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AutomobileLightStatus::Pipeline {
public:
  typedef AutomobileLightStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BaseCameraAttribute::Reader {
public:
  typedef BaseCameraAttribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsLandmarkValid() const;

  inline bool hasLandmark() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getLandmark() const;

  inline bool hasLandmarkScores() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getLandmarkScores() const;

  inline bool getIsDirectionValid() const;

  inline bool hasViewportDirection() const;
  inline  ::senseAD::msg::avp_perception::Point2f::Reader getViewportDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BaseCameraAttribute::Builder {
public:
  typedef BaseCameraAttribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsLandmarkValid();
  inline void setIsLandmarkValid(bool value);

  inline bool hasLandmark();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getLandmark();
  inline void setLandmark( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initLandmark(unsigned int size);
  inline void adoptLandmark(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownLandmark();

  inline bool hasLandmarkScores();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getLandmarkScores();
  inline void setLandmarkScores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setLandmarkScores(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initLandmarkScores(unsigned int size);
  inline void adoptLandmarkScores(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownLandmarkScores();

  inline bool getIsDirectionValid();
  inline void setIsDirectionValid(bool value);

  inline bool hasViewportDirection();
  inline  ::senseAD::msg::avp_perception::Point2f::Builder getViewportDirection();
  inline void setViewportDirection( ::senseAD::msg::avp_perception::Point2f::Reader value);
  inline  ::senseAD::msg::avp_perception::Point2f::Builder initViewportDirection();
  inline void adoptViewportDirection(::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> disownViewportDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BaseCameraAttribute::Pipeline {
public:
  typedef BaseCameraAttribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Point2f::Pipeline getViewportDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Bbox2D::Reader {
public:
  typedef Bbox2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getInitialized() const;

  inline float getTopLeftX() const;

  inline float getTopLeftY() const;

  inline float getBottomRightX() const;

  inline float getBottomRightY() const;

  inline float getConfidence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Bbox2D::Builder {
public:
  typedef Bbox2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getInitialized();
  inline void setInitialized(bool value);

  inline float getTopLeftX();
  inline void setTopLeftX(float value);

  inline float getTopLeftY();
  inline void setTopLeftY(float value);

  inline float getBottomRightX();
  inline void setBottomRightX(float value);

  inline float getBottomRightY();
  inline void setBottomRightY(float value);

  inline float getConfidence();
  inline void setConfidence(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Bbox2D::Pipeline {
public:
  typedef Bbox2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BirdViewCorners::Reader {
public:
  typedef BirdViewCorners Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline bool hasBvCorners() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader getBvCorners() const;

  inline bool hasCornerConf() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getCornerConf() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BirdViewCorners::Builder {
public:
  typedef BirdViewCorners Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline bool hasBvCorners();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder getBvCorners();
  inline void setBvCorners( ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder initBvCorners(unsigned int size);
  inline void adoptBvCorners(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>> disownBvCorners();

  inline bool hasCornerConf();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getCornerConf();
  inline void setCornerConf( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setCornerConf(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initCornerConf(unsigned int size);
  inline void adoptCornerConf(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownCornerConf();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BirdViewCorners::Pipeline {
public:
  typedef BirdViewCorners Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Boundary::Reader {
public:
  typedef Boundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getImagePoints() const;

  inline bool hasWorldPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getWorldPoints() const;

  inline float getDirectionX() const;

  inline float getDirectionY() const;

  inline float getConfidence() const;

  inline bool getIsLine() const;

  inline  ::int32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Boundary::Builder {
public:
  typedef Boundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getImagePoints();
  inline void setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initImagePoints(unsigned int size);
  inline void adoptImagePoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownImagePoints();

  inline bool hasWorldPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getWorldPoints();
  inline void setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initWorldPoints(unsigned int size);
  inline void adoptWorldPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownWorldPoints();

  inline float getDirectionX();
  inline void setDirectionX(float value);

  inline float getDirectionY();
  inline void setDirectionY(float value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool getIsLine();
  inline void setIsLine(bool value);

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Boundary::Pipeline {
public:
  typedef Boundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraBBox2DInfo::Reader {
public:
  typedef CameraBBox2DInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRawDetectionBox() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getRawDetectionBox() const;

  inline bool hasTrackedBox() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getTrackedBox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraBBox2DInfo::Builder {
public:
  typedef CameraBBox2DInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRawDetectionBox();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getRawDetectionBox();
  inline void setRawDetectionBox( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initRawDetectionBox();
  inline void adoptRawDetectionBox(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownRawDetectionBox();

  inline bool hasTrackedBox();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getTrackedBox();
  inline void setTrackedBox( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initTrackedBox();
  inline void adoptTrackedBox(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownTrackedBox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraBBox2DInfo::Pipeline {
public:
  typedef CameraBBox2DInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getRawDetectionBox();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getTrackedBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PositionInfo::Reader {
public:
  typedef PositionInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline bool hasPosition() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getPosition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PositionInfo::Builder {
public:
  typedef PositionInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline bool hasPosition();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getPosition();
  inline void setPosition( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownPosition();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PositionInfo::Pipeline {
public:
  typedef PositionInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DepthDetPoint::Reader {
public:
  typedef DepthDetPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getNearestPointX() const;

  inline float getDepthPointX() const;

  inline float getDepthPointY() const;

  inline  ::int32_t getOrientation() const;

  inline  ::int32_t getLabel() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DepthDetPoint::Builder {
public:
  typedef DepthDetPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getNearestPointX();
  inline void setNearestPointX(float value);

  inline float getDepthPointX();
  inline void setDepthPointX(float value);

  inline float getDepthPointY();
  inline void setDepthPointY(float value);

  inline  ::int32_t getOrientation();
  inline void setOrientation( ::int32_t value);

  inline  ::int32_t getLabel();
  inline void setLabel( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DepthDetPoint::Pipeline {
public:
  typedef DepthDetPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DirectionInfo::Reader {
public:
  typedef DirectionInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline bool hasDirectionYpr() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getDirectionYpr() const;

  inline bool hasDirectionYprUncertainty() const;
  inline  ::senseAD::msg::avp_perception::Matrix3f::Reader getDirectionYprUncertainty() const;

  inline float getYaw() const;

  inline float getYawUncertainty() const;

  inline float getYawRate() const;

  inline float getYawRateUncertainty() const;

  inline  ::int32_t getSurface() const;

  inline float getSurfaceScore() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DirectionInfo::Builder {
public:
  typedef DirectionInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline bool hasDirectionYpr();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getDirectionYpr();
  inline void setDirectionYpr( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initDirectionYpr();
  inline void adoptDirectionYpr(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownDirectionYpr();

  inline bool hasDirectionYprUncertainty();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder getDirectionYprUncertainty();
  inline void setDirectionYprUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder initDirectionYprUncertainty();
  inline void adoptDirectionYprUncertainty(::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> disownDirectionYprUncertainty();

  inline float getYaw();
  inline void setYaw(float value);

  inline float getYawUncertainty();
  inline void setYawUncertainty(float value);

  inline float getYawRate();
  inline void setYawRate(float value);

  inline float getYawRateUncertainty();
  inline void setYawRateUncertainty(float value);

  inline  ::int32_t getSurface();
  inline void setSurface( ::int32_t value);

  inline float getSurfaceScore();
  inline void setSurfaceScore(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DirectionInfo::Pipeline {
public:
  typedef DirectionInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getDirectionYpr();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline getDirectionYprUncertainty();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Freespace::Reader {
public:
  typedef Freespace Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline bool hasImagePoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getImagePoints() const;

  inline bool hasWorldPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getWorldPoints() const;

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

  inline bool hasBitMap() const;
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader getBitMap() const;

  inline bool hasConfidence() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getConfidence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Freespace::Builder {
public:
  typedef Freespace Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasImagePoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getImagePoints();
  inline void setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initImagePoints(unsigned int size);
  inline void adoptImagePoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownImagePoints();

  inline bool hasWorldPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getWorldPoints();
  inline void setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initWorldPoints(unsigned int size);
  inline void adoptWorldPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownWorldPoints();

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

  inline bool hasBitMap();
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder getBitMap();
  inline void setBitMap( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setBitMap(::kj::ArrayPtr<const bool> value);
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder initBitMap(unsigned int size);
  inline void adoptBitMap(::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> disownBitMap();

  inline bool hasConfidence();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getConfidence();
  inline void setConfidence( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConfidence(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initConfidence(unsigned int size);
  inline void adoptConfidence(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownConfidence();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Freespace::Pipeline {
public:
  typedef Freespace Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneLine::Reader {
public:
  typedef LaneLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getImagePoints() const;

  inline bool hasWorldPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getWorldPoints() const;

  inline bool hasWorldPointsReproj() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getWorldPointsReproj() const;

  inline float getLaneConfidence() const;

  inline float getColorConfidence() const;

  inline float getLineConfidence() const;

  inline float getEdgeConfidence() const;

  inline bool getFittingOnImgPlane() const;

  inline  ::int32_t getId() const;

  inline  ::int32_t getTrackId() const;

  inline  ::int32_t getTrackAge() const;

  inline float getDistanceToLeftBumper() const;

  inline float getDistanceToRightBumper() const;

  inline  ::int32_t getLaneCategory() const;

  inline  ::int32_t getColorId() const;

  inline  ::int32_t getLineId() const;

  inline  ::int32_t getEdgeId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneLine::Builder {
public:
  typedef LaneLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getImagePoints();
  inline void setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initImagePoints(unsigned int size);
  inline void adoptImagePoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownImagePoints();

  inline bool hasWorldPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getWorldPoints();
  inline void setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initWorldPoints(unsigned int size);
  inline void adoptWorldPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownWorldPoints();

  inline bool hasWorldPointsReproj();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getWorldPointsReproj();
  inline void setWorldPointsReproj( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initWorldPointsReproj(unsigned int size);
  inline void adoptWorldPointsReproj(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownWorldPointsReproj();

  inline float getLaneConfidence();
  inline void setLaneConfidence(float value);

  inline float getColorConfidence();
  inline void setColorConfidence(float value);

  inline float getLineConfidence();
  inline void setLineConfidence(float value);

  inline float getEdgeConfidence();
  inline void setEdgeConfidence(float value);

  inline bool getFittingOnImgPlane();
  inline void setFittingOnImgPlane(bool value);

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline  ::int32_t getTrackAge();
  inline void setTrackAge( ::int32_t value);

  inline float getDistanceToLeftBumper();
  inline void setDistanceToLeftBumper(float value);

  inline float getDistanceToRightBumper();
  inline void setDistanceToRightBumper(float value);

  inline  ::int32_t getLaneCategory();
  inline void setLaneCategory( ::int32_t value);

  inline  ::int32_t getColorId();
  inline void setColorId( ::int32_t value);

  inline  ::int32_t getLineId();
  inline void setLineId( ::int32_t value);

  inline  ::int32_t getEdgeId();
  inline void setEdgeId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneLine::Pipeline {
public:
  typedef LaneLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LidarDangerousZone::Reader {
public:
  typedef LidarDangerousZone Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPolygon() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getPolygon() const;

  inline  ::int32_t getDangerousLevel() const;

  inline  ::uint64_t getDzoneId() const;

  inline bool hasPreDzoneIds() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getPreDzoneIds() const;

  inline bool hasOccluderIds() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getOccluderIds() const;

  inline bool hasShadowIds() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShadowIds() const;

  inline float getHeight() const;

  inline  ::int32_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LidarDangerousZone::Builder {
public:
  typedef LidarDangerousZone Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPolygon();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getPolygon();
  inline void setPolygon( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initPolygon(unsigned int size);
  inline void adoptPolygon(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownPolygon();

  inline  ::int32_t getDangerousLevel();
  inline void setDangerousLevel( ::int32_t value);

  inline  ::uint64_t getDzoneId();
  inline void setDzoneId( ::uint64_t value);

  inline bool hasPreDzoneIds();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getPreDzoneIds();
  inline void setPreDzoneIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPreDzoneIds(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initPreDzoneIds(unsigned int size);
  inline void adoptPreDzoneIds(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownPreDzoneIds();

  inline bool hasOccluderIds();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getOccluderIds();
  inline void setOccluderIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setOccluderIds(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initOccluderIds(unsigned int size);
  inline void adoptOccluderIds(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownOccluderIds();

  inline bool hasShadowIds();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShadowIds();
  inline void setShadowIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShadowIds(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShadowIds(unsigned int size);
  inline void adoptShadowIds(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShadowIds();

  inline float getHeight();
  inline void setHeight(float value);

  inline  ::int32_t getType();
  inline void setType( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LidarDangerousZone::Pipeline {
public:
  typedef LidarDangerousZone Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMLaneLine::Reader {
public:
  typedef LMLaneLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType getClosestSegmentLaneLineType() const;

  inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor getClosestSegmentLaneLineColor() const;

  inline float getClosestSegmentLaneLineColorConfidence() const;

  inline  ::uint32_t getPolyFitOrder() const;

  inline bool hasPolyFitCoefficients() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getPolyFitCoefficients() const;

  inline bool hasStartPoint() const;
  inline  ::senseAD::msg::avp_perception::Point2f::Reader getStartPoint() const;

  inline bool hasEndPoint() const;
  inline  ::senseAD::msg::avp_perception::Point2f::Reader getEndPoint() const;

  inline bool hasJunctionPoint() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Reader getJunctionPoint() const;

  inline float getLaneLineWidthMeter() const;

  inline  ::int32_t getTrackId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMLaneLine::Builder {
public:
  typedef LMLaneLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType getClosestSegmentLaneLineType();
  inline void setClosestSegmentLaneLineType( ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType value);

  inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor getClosestSegmentLaneLineColor();
  inline void setClosestSegmentLaneLineColor( ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor value);

  inline float getClosestSegmentLaneLineColorConfidence();
  inline void setClosestSegmentLaneLineColorConfidence(float value);

  inline  ::uint32_t getPolyFitOrder();
  inline void setPolyFitOrder( ::uint32_t value);

  inline bool hasPolyFitCoefficients();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getPolyFitCoefficients();
  inline void setPolyFitCoefficients( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPolyFitCoefficients(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initPolyFitCoefficients(unsigned int size);
  inline void adoptPolyFitCoefficients(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownPolyFitCoefficients();

  inline bool hasStartPoint();
  inline  ::senseAD::msg::avp_perception::Point2f::Builder getStartPoint();
  inline void setStartPoint( ::senseAD::msg::avp_perception::Point2f::Reader value);
  inline  ::senseAD::msg::avp_perception::Point2f::Builder initStartPoint();
  inline void adoptStartPoint(::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> disownStartPoint();

  inline bool hasEndPoint();
  inline  ::senseAD::msg::avp_perception::Point2f::Builder getEndPoint();
  inline void setEndPoint( ::senseAD::msg::avp_perception::Point2f::Reader value);
  inline  ::senseAD::msg::avp_perception::Point2f::Builder initEndPoint();
  inline void adoptEndPoint(::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> disownEndPoint();

  inline bool hasJunctionPoint();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Builder getJunctionPoint();
  inline void setJunctionPoint( ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Builder initJunctionPoint(unsigned int size);
  inline void adoptJunctionPoint(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>> disownJunctionPoint();

  inline float getLaneLineWidthMeter();
  inline void setLaneLineWidthMeter(float value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMLaneLine::Pipeline {
public:
  typedef LMLaneLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Point2f::Pipeline getStartPoint();
  inline  ::senseAD::msg::avp_perception::Point2f::Pipeline getEndPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMLanePoint2f::Reader {
public:
  typedef LMLanePoint2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline  ::uint32_t getNextSegmentLaneLineType() const;

  inline  ::uint32_t getNextSegmentLaneLineColor() const;

  inline  ::uint32_t getNextSegmentLaneLineColorConfidence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMLanePoint2f::Builder {
public:
  typedef LMLanePoint2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline  ::uint32_t getNextSegmentLaneLineType();
  inline void setNextSegmentLaneLineType( ::uint32_t value);

  inline  ::uint32_t getNextSegmentLaneLineColor();
  inline void setNextSegmentLaneLineColor( ::uint32_t value);

  inline  ::uint32_t getNextSegmentLaneLineColorConfidence();
  inline void setNextSegmentLaneLineColorConfidence( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMLanePoint2f::Pipeline {
public:
  typedef LMLanePoint2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMLaneSpeedLimitSign::Reader {
public:
  typedef LMLaneSpeedLimitSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getLimitedSpeed() const;

  inline  ::int32_t getTrackId() const;

  inline bool hasBbox2d() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getBbox2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMLaneSpeedLimitSign::Builder {
public:
  typedef LMLaneSpeedLimitSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getLimitedSpeed();
  inline void setLimitedSpeed(float value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline bool hasBbox2d();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getBbox2d();
  inline void setBbox2d( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownBbox2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMLaneSpeedLimitSign::Pipeline {
public:
  typedef LMLaneSpeedLimitSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMLaneTurnTypeSign::Reader {
public:
  typedef LMLaneTurnTypeSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::TurnType getTurnType() const;

  inline  ::int32_t getTrackId() const;

  inline bool hasBbox2d() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getBbox2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMLaneTurnTypeSign::Builder {
public:
  typedef LMLaneTurnTypeSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::TurnType getTurnType();
  inline void setTurnType( ::senseAD::msg::avp_perception::TurnType value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline bool hasBbox2d();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getBbox2d();
  inline void setBbox2d( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownBbox2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMLaneTurnTypeSign::Pipeline {
public:
  typedef LMLaneTurnTypeSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMPerceptionRoad::Reader {
public:
  typedef LMPerceptionRoad Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLaneLines() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Reader getLaneLines() const;

  inline bool hasLaneTurntypeSigns() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Reader getLaneTurntypeSigns() const;

  inline bool hasLaneSpeedLimitSigns() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader getLaneSpeedLimitSigns() const;

  inline bool hasSpeedLimitSigns() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader getSpeedLimitSigns() const;

  inline bool hasRegions() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Reader getRegions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMPerceptionRoad::Builder {
public:
  typedef LMPerceptionRoad Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLaneLines();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Builder getLaneLines();
  inline void setLaneLines( ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Builder initLaneLines(unsigned int size);
  inline void adoptLaneLines(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>> disownLaneLines();

  inline bool hasLaneTurntypeSigns();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Builder getLaneTurntypeSigns();
  inline void setLaneTurntypeSigns( ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Builder initLaneTurntypeSigns(unsigned int size);
  inline void adoptLaneTurntypeSigns(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>> disownLaneTurntypeSigns();

  inline bool hasLaneSpeedLimitSigns();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder getLaneSpeedLimitSigns();
  inline void setLaneSpeedLimitSigns( ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder initLaneSpeedLimitSigns(unsigned int size);
  inline void adoptLaneSpeedLimitSigns(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>> disownLaneSpeedLimitSigns();

  inline bool hasSpeedLimitSigns();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder getSpeedLimitSigns();
  inline void setSpeedLimitSigns( ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder initSpeedLimitSigns(unsigned int size);
  inline void adoptSpeedLimitSigns(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>> disownSpeedLimitSigns();

  inline bool hasRegions();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Builder getRegions();
  inline void setRegions( ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Builder initRegions(unsigned int size);
  inline void adoptRegions(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>> disownRegions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMPerceptionRoad::Pipeline {
public:
  typedef LMPerceptionRoad Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMRegion::Reader {
public:
  typedef LMRegion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::LMRegion::RegionType getRegionType() const;

  inline float getRegionTypeConfidence() const;

  inline  ::int32_t getTrackId() const;

  inline bool hasRegionBoundary() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getRegionBoundary() const;

  inline bool hasJunctionPoint() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getJunctionPoint() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMRegion::Builder {
public:
  typedef LMRegion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::LMRegion::RegionType getRegionType();
  inline void setRegionType( ::senseAD::msg::avp_perception::LMRegion::RegionType value);

  inline float getRegionTypeConfidence();
  inline void setRegionTypeConfidence(float value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline bool hasRegionBoundary();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getRegionBoundary();
  inline void setRegionBoundary( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initRegionBoundary(unsigned int size);
  inline void adoptRegionBoundary(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownRegionBoundary();

  inline bool hasJunctionPoint();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getJunctionPoint();
  inline void setJunctionPoint( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initJunctionPoint(unsigned int size);
  inline void adoptJunctionPoint(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownJunctionPoint();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMRegion::Pipeline {
public:
  typedef LMRegion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LMSpeedLimitSign::Reader {
public:
  typedef LMSpeedLimitSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getLimitedSpeed() const;

  inline  ::int32_t getTrackId() const;

  inline bool hasBbox2d() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getBbox2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LMSpeedLimitSign::Builder {
public:
  typedef LMSpeedLimitSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getLimitedSpeed();
  inline void setLimitedSpeed(float value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline bool hasBbox2d();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getBbox2d();
  inline void setBbox2d( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownBbox2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LMSpeedLimitSign::Pipeline {
public:
  typedef LMSpeedLimitSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MatchedSensorObjectInfo::Reader {
public:
  typedef MatchedSensorObjectInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSensorId() const;

  inline  ::uint64_t getFrameTimestampNs() const;

  inline  ::uint64_t getObjectId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MatchedSensorObjectInfo::Builder {
public:
  typedef MatchedSensorObjectInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSensorId();
  inline void setSensorId( ::int32_t value);

  inline  ::uint64_t getFrameTimestampNs();
  inline void setFrameTimestampNs( ::uint64_t value);

  inline  ::uint64_t getObjectId();
  inline void setObjectId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MatchedSensorObjectInfo::Pipeline {
public:
  typedef MatchedSensorObjectInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ModelOutputFeature::Reader {
public:
  typedef ModelOutputFeature Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasValue() const;
  inline  ::senseAD::msg::std_msgs::Float32List::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ModelOutputFeature::Builder {
public:
  typedef ModelOutputFeature Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasValue();
  inline  ::senseAD::msg::std_msgs::Float32List::Builder getValue();
  inline void setValue( ::senseAD::msg::std_msgs::Float32List::Reader value);
  inline  ::senseAD::msg::std_msgs::Float32List::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::senseAD::msg::std_msgs::Float32List>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Float32List> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ModelOutputFeature::Pipeline {
public:
  typedef ModelOutputFeature Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Float32List::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MotionInfo::Reader {
public:
  typedef MotionInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline  ::int32_t getMotionStatus() const;

  inline bool hasCenter() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getCenter() const;

  inline bool hasCenterUncertainty() const;
  inline  ::senseAD::msg::avp_perception::Matrix3f::Reader getCenterUncertainty() const;

  inline bool hasVelocity() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getVelocity() const;

  inline bool hasVelocityUncertainty() const;
  inline  ::senseAD::msg::avp_perception::Matrix3f::Reader getVelocityUncertainty() const;

  inline bool hasAcceleration() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getAcceleration() const;

  inline bool hasAccelerationUncertainty() const;
  inline  ::senseAD::msg::avp_perception::Matrix3f::Reader getAccelerationUncertainty() const;

  inline bool hasJerk() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getJerk() const;

  inline bool hasJerkUncertainty() const;
  inline  ::senseAD::msg::avp_perception::Matrix3f::Reader getJerkUncertainty() const;

  inline float getVelocityHeading() const;

  inline float getVelocityHeadingUncertainty() const;

  inline float getVelocityHeadingRate() const;

  inline float getVelocityHeadingRateUncertainty() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MotionInfo::Builder {
public:
  typedef MotionInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline  ::int32_t getMotionStatus();
  inline void setMotionStatus( ::int32_t value);

  inline bool hasCenter();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getCenter();
  inline void setCenter( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initCenter();
  inline void adoptCenter(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownCenter();

  inline bool hasCenterUncertainty();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder getCenterUncertainty();
  inline void setCenterUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder initCenterUncertainty();
  inline void adoptCenterUncertainty(::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> disownCenterUncertainty();

  inline bool hasVelocity();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getVelocity();
  inline void setVelocity( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownVelocity();

  inline bool hasVelocityUncertainty();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder getVelocityUncertainty();
  inline void setVelocityUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder initVelocityUncertainty();
  inline void adoptVelocityUncertainty(::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> disownVelocityUncertainty();

  inline bool hasAcceleration();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getAcceleration();
  inline void setAcceleration( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initAcceleration();
  inline void adoptAcceleration(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownAcceleration();

  inline bool hasAccelerationUncertainty();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder getAccelerationUncertainty();
  inline void setAccelerationUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder initAccelerationUncertainty();
  inline void adoptAccelerationUncertainty(::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> disownAccelerationUncertainty();

  inline bool hasJerk();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getJerk();
  inline void setJerk( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initJerk();
  inline void adoptJerk(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownJerk();

  inline bool hasJerkUncertainty();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder getJerkUncertainty();
  inline void setJerkUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder initJerkUncertainty();
  inline void adoptJerkUncertainty(::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> disownJerkUncertainty();

  inline float getVelocityHeading();
  inline void setVelocityHeading(float value);

  inline float getVelocityHeadingUncertainty();
  inline void setVelocityHeadingUncertainty(float value);

  inline float getVelocityHeadingRate();
  inline void setVelocityHeadingRate(float value);

  inline float getVelocityHeadingRateUncertainty();
  inline void setVelocityHeadingRateUncertainty(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MotionInfo::Pipeline {
public:
  typedef MotionInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getCenter();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline getCenterUncertainty();
  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getVelocity();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline getVelocityUncertainty();
  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getAcceleration();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline getAccelerationUncertainty();
  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getJerk();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline getJerkUncertainty();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NonAutomobileVehicleLightStatus::Reader {
public:
  typedef NonAutomobileVehicleLightStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn() const;

  inline  ::int32_t getRightTurn() const;

  inline  ::int32_t getBrake() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NonAutomobileVehicleLightStatus::Builder {
public:
  typedef NonAutomobileVehicleLightStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn();
  inline void setLeftTurn( ::int32_t value);

  inline  ::int32_t getRightTurn();
  inline void setRightTurn( ::int32_t value);

  inline  ::int32_t getBrake();
  inline void setBrake( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NonAutomobileVehicleLightStatus::Pipeline {
public:
  typedef NonAutomobileVehicleLightStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PedestrianIntention::Reader {
public:
  typedef PedestrianIntention Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCrossing() const;

  inline  ::int32_t getAttentionToEgoCar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PedestrianIntention::Builder {
public:
  typedef PedestrianIntention Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCrossing();
  inline void setCrossing( ::int32_t value);

  inline  ::int32_t getAttentionToEgoCar();
  inline void setAttentionToEgoCar( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PedestrianIntention::Pipeline {
public:
  typedef PedestrianIntention Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RoadArea::Reader {
public:
  typedef RoadArea Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImage() const;
  inline  ::capnp::Data::Reader getImage() const;

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RoadArea::Builder {
public:
  typedef RoadArea Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImage();
  inline  ::capnp::Data::Builder getImage();
  inline void setImage( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initImage(unsigned int size);
  inline void adoptImage(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownImage();

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RoadArea::Pipeline {
public:
  typedef RoadArea Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RoadStruct::Reader {
public:
  typedef RoadStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLanelineResults() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Reader getLanelineResults() const;

  inline bool hasStoplineResults() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Reader getStoplineResults() const;

  inline bool hasBoundaryResults() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Reader getBoundaryResults() const;

  inline bool hasFreespaceResults() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Reader getFreespaceResults() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RoadStruct::Builder {
public:
  typedef RoadStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLanelineResults();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Builder getLanelineResults();
  inline void setLanelineResults( ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Builder initLanelineResults(unsigned int size);
  inline void adoptLanelineResults(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>> disownLanelineResults();

  inline bool hasStoplineResults();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Builder getStoplineResults();
  inline void setStoplineResults( ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Builder initStoplineResults(unsigned int size);
  inline void adoptStoplineResults(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>> disownStoplineResults();

  inline bool hasBoundaryResults();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Builder getBoundaryResults();
  inline void setBoundaryResults( ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Builder initBoundaryResults(unsigned int size);
  inline void adoptBoundaryResults(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>> disownBoundaryResults();

  inline bool hasFreespaceResults();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Builder getFreespaceResults();
  inline void setFreespaceResults( ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Builder initFreespaceResults(unsigned int size);
  inline void adoptFreespaceResults(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>> disownFreespaceResults();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RoadStruct::Pipeline {
public:
  typedef RoadStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SizeInfo::Reader {
public:
  typedef SizeInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline bool hasSize() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getSize() const;

  inline bool hasSizeUncertainty() const;
  inline  ::senseAD::msg::avp_perception::Matrix3f::Reader getSizeUncertainty() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SizeInfo::Builder {
public:
  typedef SizeInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline bool hasSize();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getSize();
  inline void setSize( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initSize();
  inline void adoptSize(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownSize();

  inline bool hasSizeUncertainty();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder getSizeUncertainty();
  inline void setSizeUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Matrix3f::Builder initSizeUncertainty();
  inline void adoptSizeUncertainty(::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> disownSizeUncertainty();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SizeInfo::Pipeline {
public:
  typedef SizeInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getSize();
  inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline getSizeUncertainty();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StopLine::Reader {
public:
  typedef StopLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getImagePoints() const;

  inline bool hasWorldPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getWorldPoints() const;

  inline bool hasConfidence() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getConfidence() const;

  inline  ::int32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StopLine::Builder {
public:
  typedef StopLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getImagePoints();
  inline void setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initImagePoints(unsigned int size);
  inline void adoptImagePoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownImagePoints();

  inline bool hasWorldPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getWorldPoints();
  inline void setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initWorldPoints(unsigned int size);
  inline void adoptWorldPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownWorldPoints();

  inline bool hasConfidence();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getConfidence();
  inline void setConfidence( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConfidence(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initConfidence(unsigned int size);
  inline void adoptConfidence(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownConfidence();

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StopLine::Pipeline {
public:
  typedef StopLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TLImage2DInfo::Reader {
public:
  typedef TLImage2DInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCameraName() const;
  inline  ::capnp::Text::Reader getCameraName() const;

  inline bool hasDetectedBbox() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getDetectedBbox() const;

  inline bool getIsProjectionValid() const;

  inline bool hasProjectedCenterPoint() const;
  inline  ::senseAD::msg::avp_perception::Point2f::Reader getProjectedCenterPoint() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TLImage2DInfo::Builder {
public:
  typedef TLImage2DInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCameraName();
  inline  ::capnp::Text::Builder getCameraName();
  inline void setCameraName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCameraName(unsigned int size);
  inline void adoptCameraName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCameraName();

  inline bool hasDetectedBbox();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getDetectedBbox();
  inline void setDetectedBbox( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initDetectedBbox();
  inline void adoptDetectedBbox(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownDetectedBbox();

  inline bool getIsProjectionValid();
  inline void setIsProjectionValid(bool value);

  inline bool hasProjectedCenterPoint();
  inline  ::senseAD::msg::avp_perception::Point2f::Builder getProjectedCenterPoint();
  inline void setProjectedCenterPoint( ::senseAD::msg::avp_perception::Point2f::Reader value);
  inline  ::senseAD::msg::avp_perception::Point2f::Builder initProjectedCenterPoint();
  inline void adoptProjectedCenterPoint(::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> disownProjectedCenterPoint();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TLImage2DInfo::Pipeline {
public:
  typedef TLImage2DInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getDetectedBbox();
  inline  ::senseAD::msg::avp_perception::Point2f::Pipeline getProjectedCenterPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrafficLight::Reader {
public:
  typedef TrafficLight Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestampNs() const;

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

  inline bool hasGroupId() const;
  inline  ::capnp::Text::Reader getGroupId() const;

  inline  ::senseAD::msg::avp_perception::TrafficSignal getColorLabel() const;

  inline  ::senseAD::msg::avp_perception::TurnType getTurnType() const;

  inline float getDuringTime() const;

  inline bool hasImage2dInfo() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Reader getImage2dInfo() const;

  inline bool hasWorldGeometry() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Reader getWorldGeometry() const;

  inline bool hasLocalGeometry() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getLocalGeometry() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrafficLight::Builder {
public:
  typedef TrafficLight Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestampNs();
  inline void setTimestampNs( ::uint64_t value);

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

  inline bool hasGroupId();
  inline  ::capnp::Text::Builder getGroupId();
  inline void setGroupId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGroupId(unsigned int size);
  inline void adoptGroupId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGroupId();

  inline  ::senseAD::msg::avp_perception::TrafficSignal getColorLabel();
  inline void setColorLabel( ::senseAD::msg::avp_perception::TrafficSignal value);

  inline  ::senseAD::msg::avp_perception::TurnType getTurnType();
  inline void setTurnType( ::senseAD::msg::avp_perception::TurnType value);

  inline float getDuringTime();
  inline void setDuringTime(float value);

  inline bool hasImage2dInfo();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Builder getImage2dInfo();
  inline void setImage2dInfo( ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Builder initImage2dInfo(unsigned int size);
  inline void adoptImage2dInfo(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>> disownImage2dInfo();

  inline bool hasWorldGeometry();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Builder getWorldGeometry();
  inline void setWorldGeometry( ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Builder initWorldGeometry(unsigned int size);
  inline void adoptWorldGeometry(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>> disownWorldGeometry();

  inline bool hasLocalGeometry();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getLocalGeometry();
  inline void setLocalGeometry( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initLocalGeometry();
  inline void adoptLocalGeometry(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownLocalGeometry();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrafficLight::Pipeline {
public:
  typedef TrafficLight Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getLocalGeometry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrafficLightGroup::Reader {
public:
  typedef TrafficLightGroup Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTrafficLights() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Reader getTrafficLights() const;

  inline bool hasGroupId() const;
  inline  ::capnp::Text::Reader getGroupId() const;

  inline  ::senseAD::msg::avp_perception::TrafficSignal getColorLabel() const;

  inline  ::senseAD::msg::avp_perception::TurnType getTurnType() const;

  inline float getDuringTime() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrafficLightGroup::Builder {
public:
  typedef TrafficLightGroup Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTrafficLights();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Builder getTrafficLights();
  inline void setTrafficLights( ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Builder initTrafficLights(unsigned int size);
  inline void adoptTrafficLights(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>> disownTrafficLights();

  inline bool hasGroupId();
  inline  ::capnp::Text::Builder getGroupId();
  inline void setGroupId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGroupId(unsigned int size);
  inline void adoptGroupId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGroupId();

  inline  ::senseAD::msg::avp_perception::TrafficSignal getColorLabel();
  inline void setColorLabel( ::senseAD::msg::avp_perception::TrafficSignal value);

  inline  ::senseAD::msg::avp_perception::TurnType getTurnType();
  inline void setTurnType( ::senseAD::msg::avp_perception::TurnType value);

  inline float getDuringTime();
  inline void setDuringTime(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrafficLightGroup::Pipeline {
public:
  typedef TrafficLightGroup Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::int32_t Point2i::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Point2i::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point2i::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Point2i::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Point2i::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point2i::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point2f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Point2f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point2f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Point2f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Point2f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point2f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point3f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Point3f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point3f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Point3f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Point3f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point3f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point3f::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Point3f::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point3f::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Polygon2D::Reader::hasP2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Polygon2D::Builder::hasP2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader Polygon2D::Reader::getP2d() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Polygon2D::Builder::getP2d() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Polygon2D::Builder::setP2d( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Polygon2D::Builder::initP2d(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Polygon2D::Builder::adoptP2d(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> Polygon2D::Builder::disownP2d() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Polygon3D::Reader::hasP3d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Polygon3D::Builder::hasP3d() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader Polygon3D::Reader::getP3d() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder Polygon3D::Builder::getP3d() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Polygon3D::Builder::setP3d( ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder Polygon3D::Builder::initP3d(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Polygon3D::Builder::adoptP3d(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>> Polygon3D::Builder::disownP3d() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PolygonBox::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool PolygonBox::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PolygonBox::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PolygonBox::Reader::hasPolygonContour() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PolygonBox::Builder::hasPolygonContour() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader PolygonBox::Reader::getPolygonContour() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder PolygonBox::Builder::getPolygonContour() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PolygonBox::Builder::setPolygonContour( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder PolygonBox::Builder::initPolygonContour(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PolygonBox::Builder::adoptPolygonContour(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> PolygonBox::Builder::disownPolygonContour() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float PolygonBox::Reader::getHeightLowerSurface() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float PolygonBox::Builder::getHeightLowerSurface() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PolygonBox::Builder::setHeightLowerSurface(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float PolygonBox::Reader::getHeightUpperSurface() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float PolygonBox::Builder::getHeightUpperSurface() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void PolygonBox::Builder::setHeightUpperSurface(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool VecPoint2f::Reader::hasVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VecPoint2f::Builder::hasVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader VecPoint2f::Reader::getVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder VecPoint2f::Builder::getVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VecPoint2f::Builder::setVector( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder VecPoint2f::Builder::initVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VecPoint2f::Builder::adoptVector(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> VecPoint2f::Builder::disownVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Vector3d::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Vector3d::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3d::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Vector3d::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Vector3d::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3d::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Vector3d::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Vector3d::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3d::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Vector4i::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Vector4i::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector4i::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Vector4i::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Vector4i::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector4i::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Vector4i::Reader::getZ() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Vector4i::Builder::getZ() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector4i::Builder::setZ( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Vector4i::Reader::getW() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Vector4i::Builder::getW() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Vector4i::Builder::setW( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Matrix3f::Reader::hasX() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix3f::Builder::hasX() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader Matrix3f::Reader::getX() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder Matrix3f::Builder::getX() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline Matrix3f::Pipeline::getX() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Matrix3f::Builder::setX( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder Matrix3f::Builder::initX() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Matrix3f::Builder::adoptX(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> Matrix3f::Builder::disownX() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Matrix3f::Reader::hasY() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix3f::Builder::hasY() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader Matrix3f::Reader::getY() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder Matrix3f::Builder::getY() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline Matrix3f::Pipeline::getY() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Matrix3f::Builder::setY( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder Matrix3f::Builder::initY() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Matrix3f::Builder::adoptY(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> Matrix3f::Builder::disownY() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Matrix3f::Reader::hasZ() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix3f::Builder::hasZ() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader Matrix3f::Reader::getZ() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder Matrix3f::Builder::getZ() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline Matrix3f::Pipeline::getZ() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Matrix3f::Builder::setZ( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder Matrix3f::Builder::initZ() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Matrix3f::Builder::adoptZ(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> Matrix3f::Builder::disownZ() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::int32_t AutomobileLightStatus::Reader::getLeftTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getLeftTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setLeftTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AutomobileLightStatus::Reader::getRightTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getRightTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setRightTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AutomobileLightStatus::Reader::getHazard() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getHazard() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setHazard( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AutomobileLightStatus::Reader::getBrake() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getBrake() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setBrake( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float AutomobileLightStatus::Reader::getLeftTurnConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float AutomobileLightStatus::Builder::getLeftTurnConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setLeftTurnConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float AutomobileLightStatus::Reader::getRightTurnConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float AutomobileLightStatus::Builder::getRightTurnConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setRightTurnConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float AutomobileLightStatus::Reader::getHazardConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float AutomobileLightStatus::Builder::getHazardConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setHazardConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float AutomobileLightStatus::Reader::getBrakeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float AutomobileLightStatus::Builder::getBrakeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setBrakeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline bool BaseCameraAttribute::Reader::getIsLandmarkValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool BaseCameraAttribute::Builder::getIsLandmarkValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BaseCameraAttribute::Builder::setIsLandmarkValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BaseCameraAttribute::Reader::hasLandmark() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BaseCameraAttribute::Builder::hasLandmark() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader BaseCameraAttribute::Reader::getLandmark() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder BaseCameraAttribute::Builder::getLandmark() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BaseCameraAttribute::Builder::setLandmark( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder BaseCameraAttribute::Builder::initLandmark(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BaseCameraAttribute::Builder::adoptLandmark(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> BaseCameraAttribute::Builder::disownLandmark() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BaseCameraAttribute::Reader::hasLandmarkScores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BaseCameraAttribute::Builder::hasLandmarkScores() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader BaseCameraAttribute::Reader::getLandmarkScores() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder BaseCameraAttribute::Builder::getLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BaseCameraAttribute::Builder::setLandmarkScores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BaseCameraAttribute::Builder::setLandmarkScores(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder BaseCameraAttribute::Builder::initLandmarkScores(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BaseCameraAttribute::Builder::adoptLandmarkScores(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> BaseCameraAttribute::Builder::disownLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BaseCameraAttribute::Reader::getIsDirectionValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool BaseCameraAttribute::Builder::getIsDirectionValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BaseCameraAttribute::Builder::setIsDirectionValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BaseCameraAttribute::Reader::hasViewportDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BaseCameraAttribute::Builder::hasViewportDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Point2f::Reader BaseCameraAttribute::Reader::getViewportDirection() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder BaseCameraAttribute::Builder::getViewportDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Point2f::Pipeline BaseCameraAttribute::Pipeline::getViewportDirection() {
  return  ::senseAD::msg::avp_perception::Point2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void BaseCameraAttribute::Builder::setViewportDirection( ::senseAD::msg::avp_perception::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder BaseCameraAttribute::Builder::initViewportDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BaseCameraAttribute::Builder::adoptViewportDirection(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> BaseCameraAttribute::Builder::disownViewportDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Bbox2D::Reader::getInitialized() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Bbox2D::Builder::getInitialized() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Bbox2D::Builder::setInitialized(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Bbox2D::Reader::getTopLeftX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Bbox2D::Builder::getTopLeftX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Bbox2D::Builder::setTopLeftX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Bbox2D::Reader::getTopLeftY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Bbox2D::Builder::getTopLeftY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Bbox2D::Builder::setTopLeftY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Bbox2D::Reader::getBottomRightX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float Bbox2D::Builder::getBottomRightX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Bbox2D::Builder::setBottomRightX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float Bbox2D::Reader::getBottomRightY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float Bbox2D::Builder::getBottomRightY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Bbox2D::Builder::setBottomRightY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float Bbox2D::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float Bbox2D::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Bbox2D::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool BirdViewCorners::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool BirdViewCorners::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BirdViewCorners::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BirdViewCorners::Reader::hasBvCorners() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BirdViewCorners::Builder::hasBvCorners() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader BirdViewCorners::Reader::getBvCorners() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder BirdViewCorners::Builder::getBvCorners() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BirdViewCorners::Builder::setBvCorners( ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>::Builder BirdViewCorners::Builder::initBvCorners(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BirdViewCorners::Builder::adoptBvCorners(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>> BirdViewCorners::Builder::disownBvCorners() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point3f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BirdViewCorners::Reader::hasCornerConf() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BirdViewCorners::Builder::hasCornerConf() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader BirdViewCorners::Reader::getCornerConf() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder BirdViewCorners::Builder::getCornerConf() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BirdViewCorners::Builder::setCornerConf( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BirdViewCorners::Builder::setCornerConf(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder BirdViewCorners::Builder::initCornerConf(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BirdViewCorners::Builder::adoptCornerConf(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> BirdViewCorners::Builder::disownCornerConf() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Boundary::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Boundary::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader Boundary::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Boundary::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Boundary::Builder::setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Boundary::Builder::initImagePoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Boundary::Builder::adoptImagePoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> Boundary::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Boundary::Reader::hasWorldPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Boundary::Builder::hasWorldPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader Boundary::Reader::getWorldPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Boundary::Builder::getWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Boundary::Builder::setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Boundary::Builder::initWorldPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Boundary::Builder::adoptWorldPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> Boundary::Builder::disownWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float Boundary::Reader::getDirectionX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Boundary::Builder::getDirectionX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setDirectionX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Boundary::Reader::getDirectionY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Boundary::Builder::getDirectionY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setDirectionY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Boundary::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Boundary::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Boundary::Reader::getIsLine() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}

inline bool Boundary::Builder::getIsLine() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setIsLine(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Boundary::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Boundary::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool CameraBBox2DInfo::Reader::hasRawDetectionBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraBBox2DInfo::Builder::hasRawDetectionBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader CameraBBox2DInfo::Reader::getRawDetectionBox() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder CameraBBox2DInfo::Builder::getRawDetectionBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline CameraBBox2DInfo::Pipeline::getRawDetectionBox() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CameraBBox2DInfo::Builder::setRawDetectionBox( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder CameraBBox2DInfo::Builder::initRawDetectionBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraBBox2DInfo::Builder::adoptRawDetectionBox(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> CameraBBox2DInfo::Builder::disownRawDetectionBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraBBox2DInfo::Reader::hasTrackedBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraBBox2DInfo::Builder::hasTrackedBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader CameraBBox2DInfo::Reader::getTrackedBox() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder CameraBBox2DInfo::Builder::getTrackedBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline CameraBBox2DInfo::Pipeline::getTrackedBox() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CameraBBox2DInfo::Builder::setTrackedBox( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder CameraBBox2DInfo::Builder::initTrackedBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraBBox2DInfo::Builder::adoptTrackedBox(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> CameraBBox2DInfo::Builder::disownTrackedBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PositionInfo::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool PositionInfo::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PositionInfo::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PositionInfo::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PositionInfo::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader PositionInfo::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder PositionInfo::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline PositionInfo::Pipeline::getPosition() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PositionInfo::Builder::setPosition( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder PositionInfo::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PositionInfo::Builder::adoptPosition(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> PositionInfo::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float DepthDetPoint::Reader::getNearestPointX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float DepthDetPoint::Builder::getNearestPointX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setNearestPointX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float DepthDetPoint::Reader::getDepthPointX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float DepthDetPoint::Builder::getDepthPointX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setDepthPointX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float DepthDetPoint::Reader::getDepthPointY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float DepthDetPoint::Builder::getDepthPointY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setDepthPointY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t DepthDetPoint::Reader::getOrientation() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t DepthDetPoint::Builder::getOrientation() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setOrientation( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t DepthDetPoint::Reader::getLabel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t DepthDetPoint::Builder::getLabel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setLabel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool DirectionInfo::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool DirectionInfo::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool DirectionInfo::Reader::hasDirectionYpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DirectionInfo::Builder::hasDirectionYpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader DirectionInfo::Reader::getDirectionYpr() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder DirectionInfo::Builder::getDirectionYpr() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline DirectionInfo::Pipeline::getDirectionYpr() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void DirectionInfo::Builder::setDirectionYpr( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder DirectionInfo::Builder::initDirectionYpr() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DirectionInfo::Builder::adoptDirectionYpr(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> DirectionInfo::Builder::disownDirectionYpr() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DirectionInfo::Reader::hasDirectionYprUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool DirectionInfo::Builder::hasDirectionYprUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Reader DirectionInfo::Reader::getDirectionYprUncertainty() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder DirectionInfo::Builder::getDirectionYprUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline DirectionInfo::Pipeline::getDirectionYprUncertainty() {
  return  ::senseAD::msg::avp_perception::Matrix3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void DirectionInfo::Builder::setDirectionYprUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder DirectionInfo::Builder::initDirectionYprUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void DirectionInfo::Builder::adoptDirectionYprUncertainty(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> DirectionInfo::Builder::disownDirectionYprUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float DirectionInfo::Reader::getYaw() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float DirectionInfo::Builder::getYaw() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setYaw(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float DirectionInfo::Reader::getYawUncertainty() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float DirectionInfo::Builder::getYawUncertainty() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setYawUncertainty(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float DirectionInfo::Reader::getYawRate() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float DirectionInfo::Builder::getYawRate() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setYawRate(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float DirectionInfo::Reader::getYawRateUncertainty() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float DirectionInfo::Builder::getYawRateUncertainty() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setYawRateUncertainty(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t DirectionInfo::Reader::getSurface() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t DirectionInfo::Builder::getSurface() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setSurface( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float DirectionInfo::Reader::getSurfaceScore() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float DirectionInfo::Builder::getSurfaceScore() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void DirectionInfo::Builder::setSurfaceScore(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Freespace::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Freespace::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Freespace::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Freespace::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Freespace::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader Freespace::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Freespace::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Freespace::Builder::setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Freespace::Builder::initImagePoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Freespace::Builder::adoptImagePoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> Freespace::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Freespace::Reader::hasWorldPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Freespace::Builder::hasWorldPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader Freespace::Reader::getWorldPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Freespace::Builder::getWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Freespace::Builder::setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder Freespace::Builder::initWorldPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Freespace::Builder::adoptWorldPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> Freespace::Builder::disownWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t Freespace::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Freespace::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Freespace::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Freespace::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Freespace::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Freespace::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Freespace::Reader::hasBitMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Freespace::Builder::hasBitMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader Freespace::Reader::getBitMap() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder Freespace::Builder::getBitMap() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Freespace::Builder::setBitMap( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void Freespace::Builder::setBitMap(::kj::ArrayPtr<const bool> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder Freespace::Builder::initBitMap(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Freespace::Builder::adoptBitMap(
    ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> Freespace::Builder::disownBitMap() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Freespace::Reader::hasConfidence() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Freespace::Builder::hasConfidence() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader Freespace::Reader::getConfidence() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder Freespace::Builder::getConfidence() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Freespace::Builder::setConfidence( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void Freespace::Builder::setConfidence(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder Freespace::Builder::initConfidence(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Freespace::Builder::adoptConfidence(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> Freespace::Builder::disownConfidence() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool LaneLine::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneLine::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader LaneLine::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LaneLine::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneLine::Builder::setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LaneLine::Builder::initImagePoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LaneLine::Builder::adoptImagePoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> LaneLine::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LaneLine::Reader::hasWorldPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LaneLine::Builder::hasWorldPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader LaneLine::Reader::getWorldPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LaneLine::Builder::getWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LaneLine::Builder::setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LaneLine::Builder::initWorldPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LaneLine::Builder::adoptWorldPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> LaneLine::Builder::disownWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LaneLine::Reader::hasWorldPointsReproj() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LaneLine::Builder::hasWorldPointsReproj() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader LaneLine::Reader::getWorldPointsReproj() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LaneLine::Builder::getWorldPointsReproj() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LaneLine::Builder::setWorldPointsReproj( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LaneLine::Builder::initWorldPointsReproj(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LaneLine::Builder::adoptWorldPointsReproj(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> LaneLine::Builder::disownWorldPointsReproj() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline float LaneLine::Reader::getLaneConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float LaneLine::Builder::getLaneConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setLaneConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float LaneLine::Reader::getColorConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float LaneLine::Builder::getColorConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setColorConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float LaneLine::Reader::getLineConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float LaneLine::Builder::getLineConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setLineConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float LaneLine::Reader::getEdgeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float LaneLine::Builder::getEdgeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setEdgeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool LaneLine::Reader::getFittingOnImgPlane() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}

inline bool LaneLine::Builder::getFittingOnImgPlane() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setFittingOnImgPlane(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getTrackAge() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getTrackAge() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setTrackAge( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float LaneLine::Reader::getDistanceToLeftBumper() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float LaneLine::Builder::getDistanceToLeftBumper() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setDistanceToLeftBumper(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float LaneLine::Reader::getDistanceToRightBumper() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float LaneLine::Builder::getDistanceToRightBumper() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setDistanceToRightBumper(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getLaneCategory() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getLaneCategory() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setLaneCategory( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getColorId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getColorId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setColorId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getLineId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getLineId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setLineId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LaneLine::Reader::getEdgeId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LaneLine::Builder::getEdgeId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void LaneLine::Builder::setEdgeId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline bool LidarDangerousZone::Reader::hasPolygon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LidarDangerousZone::Builder::hasPolygon() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader LidarDangerousZone::Reader::getPolygon() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LidarDangerousZone::Builder::getPolygon() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LidarDangerousZone::Builder::setPolygon( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LidarDangerousZone::Builder::initPolygon(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LidarDangerousZone::Builder::adoptPolygon(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> LidarDangerousZone::Builder::disownPolygon() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t LidarDangerousZone::Reader::getDangerousLevel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LidarDangerousZone::Builder::getDangerousLevel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LidarDangerousZone::Builder::setDangerousLevel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t LidarDangerousZone::Reader::getDzoneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t LidarDangerousZone::Builder::getDzoneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LidarDangerousZone::Builder::setDzoneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LidarDangerousZone::Reader::hasPreDzoneIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LidarDangerousZone::Builder::hasPreDzoneIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader LidarDangerousZone::Reader::getPreDzoneIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder LidarDangerousZone::Builder::getPreDzoneIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LidarDangerousZone::Builder::setPreDzoneIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void LidarDangerousZone::Builder::setPreDzoneIds(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder LidarDangerousZone::Builder::initPreDzoneIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LidarDangerousZone::Builder::adoptPreDzoneIds(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> LidarDangerousZone::Builder::disownPreDzoneIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LidarDangerousZone::Reader::hasOccluderIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LidarDangerousZone::Builder::hasOccluderIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader LidarDangerousZone::Reader::getOccluderIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder LidarDangerousZone::Builder::getOccluderIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LidarDangerousZone::Builder::setOccluderIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void LidarDangerousZone::Builder::setOccluderIds(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder LidarDangerousZone::Builder::initOccluderIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LidarDangerousZone::Builder::adoptOccluderIds(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> LidarDangerousZone::Builder::disownOccluderIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LidarDangerousZone::Reader::hasShadowIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LidarDangerousZone::Builder::hasShadowIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader LidarDangerousZone::Reader::getShadowIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder LidarDangerousZone::Builder::getShadowIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LidarDangerousZone::Builder::setShadowIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void LidarDangerousZone::Builder::setShadowIds(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder LidarDangerousZone::Builder::initShadowIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void LidarDangerousZone::Builder::adoptShadowIds(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> LidarDangerousZone::Builder::disownShadowIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline float LidarDangerousZone::Reader::getHeight() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float LidarDangerousZone::Builder::getHeight() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LidarDangerousZone::Builder::setHeight(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LidarDangerousZone::Reader::getType() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LidarDangerousZone::Builder::getType() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void LidarDangerousZone::Builder::setType( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType LMLaneLine::Reader::getClosestSegmentLaneLineType() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType LMLaneLine::Builder::getClosestSegmentLaneLineType() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LMLaneLine::Builder::setClosestSegmentLaneLineType( ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::LMLaneLine::LaneLineType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor LMLaneLine::Reader::getClosestSegmentLaneLineColor() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor LMLaneLine::Builder::getClosestSegmentLaneLineColor() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMLaneLine::Builder::setClosestSegmentLaneLineColor( ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::LMLaneLine::LaneLineColor>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float LMLaneLine::Reader::getClosestSegmentLaneLineColorConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float LMLaneLine::Builder::getClosestSegmentLaneLineColorConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMLaneLine::Builder::setClosestSegmentLaneLineColorConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LMLaneLine::Reader::getPolyFitOrder() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LMLaneLine::Builder::getPolyFitOrder() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LMLaneLine::Builder::setPolyFitOrder( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool LMLaneLine::Reader::hasPolyFitCoefficients() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LMLaneLine::Builder::hasPolyFitCoefficients() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader LMLaneLine::Reader::getPolyFitCoefficients() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder LMLaneLine::Builder::getPolyFitCoefficients() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LMLaneLine::Builder::setPolyFitCoefficients( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void LMLaneLine::Builder::setPolyFitCoefficients(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder LMLaneLine::Builder::initPolyFitCoefficients(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LMLaneLine::Builder::adoptPolyFitCoefficients(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> LMLaneLine::Builder::disownPolyFitCoefficients() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LMLaneLine::Reader::hasStartPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LMLaneLine::Builder::hasStartPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Point2f::Reader LMLaneLine::Reader::getStartPoint() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder LMLaneLine::Builder::getStartPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Point2f::Pipeline LMLaneLine::Pipeline::getStartPoint() {
  return  ::senseAD::msg::avp_perception::Point2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void LMLaneLine::Builder::setStartPoint( ::senseAD::msg::avp_perception::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder LMLaneLine::Builder::initStartPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LMLaneLine::Builder::adoptStartPoint(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> LMLaneLine::Builder::disownStartPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LMLaneLine::Reader::hasEndPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LMLaneLine::Builder::hasEndPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Point2f::Reader LMLaneLine::Reader::getEndPoint() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder LMLaneLine::Builder::getEndPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Point2f::Pipeline LMLaneLine::Pipeline::getEndPoint() {
  return  ::senseAD::msg::avp_perception::Point2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void LMLaneLine::Builder::setEndPoint( ::senseAD::msg::avp_perception::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder LMLaneLine::Builder::initEndPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LMLaneLine::Builder::adoptEndPoint(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> LMLaneLine::Builder::disownEndPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LMLaneLine::Reader::hasJunctionPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LMLaneLine::Builder::hasJunctionPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Reader LMLaneLine::Reader::getJunctionPoint() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Builder LMLaneLine::Builder::getJunctionPoint() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LMLaneLine::Builder::setJunctionPoint( ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>::Builder LMLaneLine::Builder::initJunctionPoint(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void LMLaneLine::Builder::adoptJunctionPoint(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>> LMLaneLine::Builder::disownJunctionPoint() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLanePoint2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline float LMLaneLine::Reader::getLaneLineWidthMeter() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float LMLaneLine::Builder::getLaneLineWidthMeter() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void LMLaneLine::Builder::setLaneLineWidthMeter(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LMLaneLine::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LMLaneLine::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void LMLaneLine::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float LMLanePoint2f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float LMLanePoint2f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LMLanePoint2f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float LMLanePoint2f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float LMLanePoint2f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMLanePoint2f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LMLanePoint2f::Reader::getNextSegmentLaneLineType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LMLanePoint2f::Builder::getNextSegmentLaneLineType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LMLanePoint2f::Builder::setNextSegmentLaneLineType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LMLanePoint2f::Reader::getNextSegmentLaneLineColor() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LMLanePoint2f::Builder::getNextSegmentLaneLineColor() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void LMLanePoint2f::Builder::setNextSegmentLaneLineColor( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LMLanePoint2f::Reader::getNextSegmentLaneLineColorConfidence() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LMLanePoint2f::Builder::getNextSegmentLaneLineColorConfidence() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void LMLanePoint2f::Builder::setNextSegmentLaneLineColorConfidence( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float LMLaneSpeedLimitSign::Reader::getLimitedSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float LMLaneSpeedLimitSign::Builder::getLimitedSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LMLaneSpeedLimitSign::Builder::setLimitedSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LMLaneSpeedLimitSign::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LMLaneSpeedLimitSign::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMLaneSpeedLimitSign::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LMLaneSpeedLimitSign::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LMLaneSpeedLimitSign::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader LMLaneSpeedLimitSign::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder LMLaneSpeedLimitSign::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline LMLaneSpeedLimitSign::Pipeline::getBbox2d() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LMLaneSpeedLimitSign::Builder::setBbox2d( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder LMLaneSpeedLimitSign::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LMLaneSpeedLimitSign::Builder::adoptBbox2d(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> LMLaneSpeedLimitSign::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::senseAD::msg::avp_perception::TurnType LMLaneTurnTypeSign::Reader::getTurnType() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::TurnType LMLaneTurnTypeSign::Builder::getTurnType() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LMLaneTurnTypeSign::Builder::setTurnType( ::senseAD::msg::avp_perception::TurnType value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LMLaneTurnTypeSign::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LMLaneTurnTypeSign::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMLaneTurnTypeSign::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LMLaneTurnTypeSign::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LMLaneTurnTypeSign::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader LMLaneTurnTypeSign::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder LMLaneTurnTypeSign::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline LMLaneTurnTypeSign::Pipeline::getBbox2d() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LMLaneTurnTypeSign::Builder::setBbox2d( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder LMLaneTurnTypeSign::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LMLaneTurnTypeSign::Builder::adoptBbox2d(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> LMLaneTurnTypeSign::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LMPerceptionRoad::Reader::hasLaneLines() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LMPerceptionRoad::Builder::hasLaneLines() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Reader LMPerceptionRoad::Reader::getLaneLines() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::getLaneLines() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LMPerceptionRoad::Builder::setLaneLines( ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::initLaneLines(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LMPerceptionRoad::Builder::adoptLaneLines(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>> LMPerceptionRoad::Builder::disownLaneLines() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneLine,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LMPerceptionRoad::Reader::hasLaneTurntypeSigns() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LMPerceptionRoad::Builder::hasLaneTurntypeSigns() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Reader LMPerceptionRoad::Reader::getLaneTurntypeSigns() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::getLaneTurntypeSigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LMPerceptionRoad::Builder::setLaneTurntypeSigns( ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::initLaneTurntypeSigns(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LMPerceptionRoad::Builder::adoptLaneTurntypeSigns(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>> LMPerceptionRoad::Builder::disownLaneTurntypeSigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneTurnTypeSign,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LMPerceptionRoad::Reader::hasLaneSpeedLimitSigns() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LMPerceptionRoad::Builder::hasLaneSpeedLimitSigns() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader LMPerceptionRoad::Reader::getLaneSpeedLimitSigns() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::getLaneSpeedLimitSigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LMPerceptionRoad::Builder::setLaneSpeedLimitSigns( ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::initLaneSpeedLimitSigns(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LMPerceptionRoad::Builder::adoptLaneSpeedLimitSigns(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>> LMPerceptionRoad::Builder::disownLaneSpeedLimitSigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMLaneSpeedLimitSign,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LMPerceptionRoad::Reader::hasSpeedLimitSigns() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LMPerceptionRoad::Builder::hasSpeedLimitSigns() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader LMPerceptionRoad::Reader::getSpeedLimitSigns() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::getSpeedLimitSigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LMPerceptionRoad::Builder::setSpeedLimitSigns( ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::initSpeedLimitSigns(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void LMPerceptionRoad::Builder::adoptSpeedLimitSigns(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>> LMPerceptionRoad::Builder::disownSpeedLimitSigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMSpeedLimitSign,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool LMPerceptionRoad::Reader::hasRegions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool LMPerceptionRoad::Builder::hasRegions() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Reader LMPerceptionRoad::Reader::getRegions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::getRegions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void LMPerceptionRoad::Builder::setRegions( ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>::Builder LMPerceptionRoad::Builder::initRegions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void LMPerceptionRoad::Builder::adoptRegions(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>> LMPerceptionRoad::Builder::disownRegions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LMRegion,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::senseAD::msg::avp_perception::LMRegion::RegionType LMRegion::Reader::getRegionType() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::LMRegion::RegionType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::LMRegion::RegionType LMRegion::Builder::getRegionType() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::LMRegion::RegionType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LMRegion::Builder::setRegionType( ::senseAD::msg::avp_perception::LMRegion::RegionType value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::LMRegion::RegionType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float LMRegion::Reader::getRegionTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float LMRegion::Builder::getRegionTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMRegion::Builder::setRegionTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LMRegion::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LMRegion::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LMRegion::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool LMRegion::Reader::hasRegionBoundary() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LMRegion::Builder::hasRegionBoundary() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader LMRegion::Reader::getRegionBoundary() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LMRegion::Builder::getRegionBoundary() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LMRegion::Builder::setRegionBoundary( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LMRegion::Builder::initRegionBoundary(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LMRegion::Builder::adoptRegionBoundary(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> LMRegion::Builder::disownRegionBoundary() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LMRegion::Reader::hasJunctionPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LMRegion::Builder::hasJunctionPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader LMRegion::Reader::getJunctionPoint() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LMRegion::Builder::getJunctionPoint() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LMRegion::Builder::setJunctionPoint( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder LMRegion::Builder::initJunctionPoint(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LMRegion::Builder::adoptJunctionPoint(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> LMRegion::Builder::disownJunctionPoint() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float LMSpeedLimitSign::Reader::getLimitedSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float LMSpeedLimitSign::Builder::getLimitedSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LMSpeedLimitSign::Builder::setLimitedSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t LMSpeedLimitSign::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t LMSpeedLimitSign::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LMSpeedLimitSign::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LMSpeedLimitSign::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LMSpeedLimitSign::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader LMSpeedLimitSign::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder LMSpeedLimitSign::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline LMSpeedLimitSign::Pipeline::getBbox2d() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LMSpeedLimitSign::Builder::setBbox2d( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder LMSpeedLimitSign::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LMSpeedLimitSign::Builder::adoptBbox2d(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> LMSpeedLimitSign::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t MatchedSensorObjectInfo::Reader::getSensorId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchedSensorObjectInfo::Builder::getSensorId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MatchedSensorObjectInfo::Builder::setSensorId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MatchedSensorObjectInfo::Reader::getFrameTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MatchedSensorObjectInfo::Builder::getFrameTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MatchedSensorObjectInfo::Builder::setFrameTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MatchedSensorObjectInfo::Reader::getObjectId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MatchedSensorObjectInfo::Builder::getObjectId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MatchedSensorObjectInfo::Builder::setObjectId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool ModelOutputFeature::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ModelOutputFeature::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ModelOutputFeature::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ModelOutputFeature::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ModelOutputFeature::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ModelOutputFeature::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ModelOutputFeature::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ModelOutputFeature::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ModelOutputFeature::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ModelOutputFeature::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Float32List::Reader ModelOutputFeature::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Float32List>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Float32List::Builder ModelOutputFeature::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Float32List>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Float32List::Pipeline ModelOutputFeature::Pipeline::getValue() {
  return  ::senseAD::msg::std_msgs::Float32List::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ModelOutputFeature::Builder::setValue( ::senseAD::msg::std_msgs::Float32List::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Float32List>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Float32List::Builder ModelOutputFeature::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Float32List>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ModelOutputFeature::Builder::adoptValue(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Float32List>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Float32List>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Float32List> ModelOutputFeature::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Float32List>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool MotionInfo::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MotionInfo::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MotionInfo::Reader::getMotionStatus() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MotionInfo::Builder::getMotionStatus() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MotionInfo::Builder::setMotionStatus( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool MotionInfo::Reader::hasCenter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasCenter() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader MotionInfo::Reader::getCenter() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder MotionInfo::Builder::getCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline MotionInfo::Pipeline::getCenter() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setCenter( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder MotionInfo::Builder::initCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptCenter(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> MotionInfo::Builder::disownCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasCenterUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasCenterUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Reader MotionInfo::Reader::getCenterUncertainty() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::getCenterUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline MotionInfo::Pipeline::getCenterUncertainty() {
  return  ::senseAD::msg::avp_perception::Matrix3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setCenterUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::initCenterUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptCenterUncertainty(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> MotionInfo::Builder::disownCenterUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader MotionInfo::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder MotionInfo::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline MotionInfo::Pipeline::getVelocity() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setVelocity( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder MotionInfo::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptVelocity(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> MotionInfo::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasVelocityUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasVelocityUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Reader MotionInfo::Reader::getVelocityUncertainty() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::getVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline MotionInfo::Pipeline::getVelocityUncertainty() {
  return  ::senseAD::msg::avp_perception::Matrix3f::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setVelocityUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::initVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptVelocityUncertainty(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> MotionInfo::Builder::disownVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasAcceleration() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasAcceleration() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader MotionInfo::Reader::getAcceleration() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder MotionInfo::Builder::getAcceleration() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline MotionInfo::Pipeline::getAcceleration() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setAcceleration( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder MotionInfo::Builder::initAcceleration() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptAcceleration(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> MotionInfo::Builder::disownAcceleration() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasAccelerationUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasAccelerationUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Reader MotionInfo::Reader::getAccelerationUncertainty() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::getAccelerationUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline MotionInfo::Pipeline::getAccelerationUncertainty() {
  return  ::senseAD::msg::avp_perception::Matrix3f::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setAccelerationUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::initAccelerationUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptAccelerationUncertainty(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> MotionInfo::Builder::disownAccelerationUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasJerk() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasJerk() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader MotionInfo::Reader::getJerk() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder MotionInfo::Builder::getJerk() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline MotionInfo::Pipeline::getJerk() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setJerk( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder MotionInfo::Builder::initJerk() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptJerk(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> MotionInfo::Builder::disownJerk() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool MotionInfo::Reader::hasJerkUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool MotionInfo::Builder::hasJerkUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Reader MotionInfo::Reader::getJerkUncertainty() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::getJerkUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline MotionInfo::Pipeline::getJerkUncertainty() {
  return  ::senseAD::msg::avp_perception::Matrix3f::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void MotionInfo::Builder::setJerkUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder MotionInfo::Builder::initJerkUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void MotionInfo::Builder::adoptJerkUncertainty(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> MotionInfo::Builder::disownJerkUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline float MotionInfo::Reader::getVelocityHeading() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float MotionInfo::Builder::getVelocityHeading() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MotionInfo::Builder::setVelocityHeading(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float MotionInfo::Reader::getVelocityHeadingUncertainty() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float MotionInfo::Builder::getVelocityHeadingUncertainty() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void MotionInfo::Builder::setVelocityHeadingUncertainty(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float MotionInfo::Reader::getVelocityHeadingRate() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float MotionInfo::Builder::getVelocityHeadingRate() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void MotionInfo::Builder::setVelocityHeadingRate(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float MotionInfo::Reader::getVelocityHeadingRateUncertainty() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float MotionInfo::Builder::getVelocityHeadingRateUncertainty() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void MotionInfo::Builder::setVelocityHeadingRateUncertainty(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Reader::getLeftTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Builder::getLeftTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NonAutomobileVehicleLightStatus::Builder::setLeftTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Reader::getRightTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Builder::getRightTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NonAutomobileVehicleLightStatus::Builder::setRightTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Reader::getBrake() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Builder::getBrake() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NonAutomobileVehicleLightStatus::Builder::setBrake( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PedestrianIntention::Reader::getCrossing() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t PedestrianIntention::Builder::getCrossing() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PedestrianIntention::Builder::setCrossing( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PedestrianIntention::Reader::getAttentionToEgoCar() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t PedestrianIntention::Builder::getAttentionToEgoCar() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PedestrianIntention::Builder::setAttentionToEgoCar( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RoadArea::Reader::hasImage() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RoadArea::Builder::hasImage() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader RoadArea::Reader::getImage() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder RoadArea::Builder::getImage() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RoadArea::Builder::setImage( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder RoadArea::Builder::initImage(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RoadArea::Builder::adoptImage(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> RoadArea::Builder::disownImage() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t RoadArea::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RoadArea::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RoadArea::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t RoadArea::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RoadArea::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RoadArea::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RoadStruct::Reader::hasLanelineResults() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RoadStruct::Builder::hasLanelineResults() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Reader RoadStruct::Reader::getLanelineResults() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::getLanelineResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RoadStruct::Builder::setLanelineResults( ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::initLanelineResults(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RoadStruct::Builder::adoptLanelineResults(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>> RoadStruct::Builder::disownLanelineResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::LaneLine,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RoadStruct::Reader::hasStoplineResults() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool RoadStruct::Builder::hasStoplineResults() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Reader RoadStruct::Reader::getStoplineResults() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::getStoplineResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void RoadStruct::Builder::setStoplineResults( ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::initStoplineResults(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void RoadStruct::Builder::adoptStoplineResults(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>> RoadStruct::Builder::disownStoplineResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::StopLine,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RoadStruct::Reader::hasBoundaryResults() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool RoadStruct::Builder::hasBoundaryResults() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Reader RoadStruct::Reader::getBoundaryResults() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::getBoundaryResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void RoadStruct::Builder::setBoundaryResults( ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::initBoundaryResults(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void RoadStruct::Builder::adoptBoundaryResults(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>> RoadStruct::Builder::disownBoundaryResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Boundary,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool RoadStruct::Reader::hasFreespaceResults() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool RoadStruct::Builder::hasFreespaceResults() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Reader RoadStruct::Reader::getFreespaceResults() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::getFreespaceResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void RoadStruct::Builder::setFreespaceResults( ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>::Builder RoadStruct::Builder::initFreespaceResults(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void RoadStruct::Builder::adoptFreespaceResults(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>> RoadStruct::Builder::disownFreespaceResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Freespace,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool SizeInfo::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool SizeInfo::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SizeInfo::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool SizeInfo::Reader::hasSize() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SizeInfo::Builder::hasSize() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader SizeInfo::Reader::getSize() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder SizeInfo::Builder::getSize() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline SizeInfo::Pipeline::getSize() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SizeInfo::Builder::setSize( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder SizeInfo::Builder::initSize() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SizeInfo::Builder::adoptSize(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> SizeInfo::Builder::disownSize() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SizeInfo::Reader::hasSizeUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SizeInfo::Builder::hasSizeUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Reader SizeInfo::Reader::getSizeUncertainty() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder SizeInfo::Builder::getSizeUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Matrix3f::Pipeline SizeInfo::Pipeline::getSizeUncertainty() {
  return  ::senseAD::msg::avp_perception::Matrix3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SizeInfo::Builder::setSizeUncertainty( ::senseAD::msg::avp_perception::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Matrix3f::Builder SizeInfo::Builder::initSizeUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SizeInfo::Builder::adoptSizeUncertainty(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Matrix3f> SizeInfo::Builder::disownSizeUncertainty() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool StopLine::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StopLine::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader StopLine::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder StopLine::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StopLine::Builder::setImagePoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder StopLine::Builder::initImagePoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StopLine::Builder::adoptImagePoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> StopLine::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool StopLine::Reader::hasWorldPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool StopLine::Builder::hasWorldPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader StopLine::Reader::getWorldPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder StopLine::Builder::getWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void StopLine::Builder::setWorldPoints( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder StopLine::Builder::initWorldPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void StopLine::Builder::adoptWorldPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> StopLine::Builder::disownWorldPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool StopLine::Reader::hasConfidence() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool StopLine::Builder::hasConfidence() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader StopLine::Reader::getConfidence() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder StopLine::Builder::getConfidence() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void StopLine::Builder::setConfidence( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void StopLine::Builder::setConfidence(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder StopLine::Builder::initConfidence(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void StopLine::Builder::adoptConfidence(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> StopLine::Builder::disownConfidence() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::int32_t StopLine::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t StopLine::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StopLine::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TLImage2DInfo::Reader::hasCameraName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TLImage2DInfo::Builder::hasCameraName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TLImage2DInfo::Reader::getCameraName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TLImage2DInfo::Builder::getCameraName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TLImage2DInfo::Builder::setCameraName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TLImage2DInfo::Builder::initCameraName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TLImage2DInfo::Builder::adoptCameraName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TLImage2DInfo::Builder::disownCameraName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TLImage2DInfo::Reader::hasDetectedBbox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TLImage2DInfo::Builder::hasDetectedBbox() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader TLImage2DInfo::Reader::getDetectedBbox() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder TLImage2DInfo::Builder::getDetectedBbox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline TLImage2DInfo::Pipeline::getDetectedBbox() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TLImage2DInfo::Builder::setDetectedBbox( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder TLImage2DInfo::Builder::initDetectedBbox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TLImage2DInfo::Builder::adoptDetectedBbox(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> TLImage2DInfo::Builder::disownDetectedBbox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TLImage2DInfo::Reader::getIsProjectionValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TLImage2DInfo::Builder::getIsProjectionValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TLImage2DInfo::Builder::setIsProjectionValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TLImage2DInfo::Reader::hasProjectedCenterPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TLImage2DInfo::Builder::hasProjectedCenterPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Point2f::Reader TLImage2DInfo::Reader::getProjectedCenterPoint() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder TLImage2DInfo::Builder::getProjectedCenterPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Point2f::Pipeline TLImage2DInfo::Pipeline::getProjectedCenterPoint() {
  return  ::senseAD::msg::avp_perception::Point2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TLImage2DInfo::Builder::setProjectedCenterPoint( ::senseAD::msg::avp_perception::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Point2f::Builder TLImage2DInfo::Builder::initProjectedCenterPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TLImage2DInfo::Builder::adoptProjectedCenterPoint(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Point2f> TLImage2DInfo::Builder::disownProjectedCenterPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint64_t TrafficLight::Reader::getTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TrafficLight::Builder::getTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TrafficLight::Builder::setTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TrafficLight::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TrafficLight::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TrafficLight::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TrafficLight::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TrafficLight::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TrafficLight::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TrafficLight::Reader::hasGroupId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasGroupId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TrafficLight::Reader::getGroupId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TrafficLight::Builder::getGroupId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::setGroupId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TrafficLight::Builder::initGroupId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TrafficLight::Builder::adoptGroupId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TrafficLight::Builder::disownGroupId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::senseAD::msg::avp_perception::TrafficSignal TrafficLight::Reader::getColorLabel() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::TrafficSignal>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::TrafficSignal TrafficLight::Builder::getColorLabel() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::TrafficSignal>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TrafficLight::Builder::setColorLabel( ::senseAD::msg::avp_perception::TrafficSignal value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::TrafficSignal>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::avp_perception::TurnType TrafficLight::Reader::getTurnType() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::TurnType TrafficLight::Builder::getTurnType() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TrafficLight::Builder::setTurnType( ::senseAD::msg::avp_perception::TurnType value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float TrafficLight::Reader::getDuringTime() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float TrafficLight::Builder::getDuringTime() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TrafficLight::Builder::setDuringTime(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool TrafficLight::Reader::hasImage2dInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasImage2dInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Reader TrafficLight::Reader::getImage2dInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Builder TrafficLight::Builder::getImage2dInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::setImage2dInfo( ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>::Builder TrafficLight::Builder::initImage2dInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TrafficLight::Builder::adoptImage2dInfo(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>> TrafficLight::Builder::disownImage2dInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TLImage2DInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TrafficLight::Reader::hasWorldGeometry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasWorldGeometry() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Reader TrafficLight::Reader::getWorldGeometry() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Builder TrafficLight::Builder::getWorldGeometry() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::setWorldGeometry( ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>::Builder TrafficLight::Builder::initWorldGeometry(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TrafficLight::Builder::adoptWorldGeometry(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>> TrafficLight::Builder::disownWorldGeometry() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Vector3f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TrafficLight::Reader::hasLocalGeometry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasLocalGeometry() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader TrafficLight::Reader::getLocalGeometry() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder TrafficLight::Builder::getLocalGeometry() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline TrafficLight::Pipeline::getLocalGeometry() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void TrafficLight::Builder::setLocalGeometry( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder TrafficLight::Builder::initLocalGeometry() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::adoptLocalGeometry(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> TrafficLight::Builder::disownLocalGeometry() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TrafficLightGroup::Reader::hasTrafficLights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLightGroup::Builder::hasTrafficLights() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Reader TrafficLightGroup::Reader::getTrafficLights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Builder TrafficLightGroup::Builder::getTrafficLights() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TrafficLightGroup::Builder::setTrafficLights( ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>::Builder TrafficLightGroup::Builder::initTrafficLights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TrafficLightGroup::Builder::adoptTrafficLights(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>> TrafficLightGroup::Builder::disownTrafficLights() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::TrafficLight,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TrafficLightGroup::Reader::hasGroupId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLightGroup::Builder::hasGroupId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TrafficLightGroup::Reader::getGroupId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TrafficLightGroup::Builder::getGroupId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TrafficLightGroup::Builder::setGroupId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TrafficLightGroup::Builder::initGroupId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TrafficLightGroup::Builder::adoptGroupId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TrafficLightGroup::Builder::disownGroupId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::senseAD::msg::avp_perception::TrafficSignal TrafficLightGroup::Reader::getColorLabel() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::TrafficSignal>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::TrafficSignal TrafficLightGroup::Builder::getColorLabel() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::TrafficSignal>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TrafficLightGroup::Builder::setColorLabel( ::senseAD::msg::avp_perception::TrafficSignal value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::TrafficSignal>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::senseAD::msg::avp_perception::TurnType TrafficLightGroup::Reader::getTurnType() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::TurnType TrafficLightGroup::Builder::getTurnType() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TrafficLightGroup::Builder::setTurnType( ::senseAD::msg::avp_perception::TurnType value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::TurnType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float TrafficLightGroup::Reader::getDuringTime() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float TrafficLightGroup::Builder::getDuringTime() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TrafficLightGroup::Builder::setDuringTime(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

