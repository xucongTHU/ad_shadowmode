// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: perception_result_draw.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <ad_msg_idl/ad_perception/obstacles.capnp.h>
#include <ad_msg_idl/ad_perception/parking_slots.capnp.h>
#include <ad_msg_idl/ad_perception/quad_parking_slots.capnp.h>
#include <ad_msg_idl/std_msgs/raw_data.capnp.h>

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d438b86656684f80);
CAPNP_DECLARE_SCHEMA(a0f2f520f58937d1);
CAPNP_DECLARE_SCHEMA(f2ddbcc127b5913a);
CAPNP_DECLARE_SCHEMA(d59a056d80bd3398);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace avp_perception {

struct Obstacle2DImage {
  Obstacle2DImage() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d438b86656684f80, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Obstacle2DImages {
  Obstacle2DImages() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0f2f520f58937d1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ObstacleImages {
  ObstacleImages() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f2ddbcc127b5913a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RawIpmImage {
  RawIpmImage() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d59a056d80bd3398, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Obstacle2DImage::Reader {
public:
  typedef Obstacle2DImage Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImage() const;
  inline  ::senseAD::msg::std_msgs::Image::Reader getImage() const;

  inline bool hasObstacles() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader getObstacles() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Obstacle2DImage::Builder {
public:
  typedef Obstacle2DImage Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImage();
  inline  ::senseAD::msg::std_msgs::Image::Builder getImage();
  inline void setImage( ::senseAD::msg::std_msgs::Image::Reader value);
  inline  ::senseAD::msg::std_msgs::Image::Builder initImage();
  inline void adoptImage(::capnp::Orphan< ::senseAD::msg::std_msgs::Image>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Image> disownImage();

  inline bool hasObstacles();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder getObstacles();
  inline void setObstacles( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder initObstacles(unsigned int size);
  inline void adoptObstacles(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>> disownObstacles();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Obstacle2DImage::Pipeline {
public:
  typedef Obstacle2DImage Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Image::Pipeline getImage();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Obstacle2DImages::Reader {
public:
  typedef Obstacle2DImages Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObstacleImgs() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Reader getObstacleImgs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Obstacle2DImages::Builder {
public:
  typedef Obstacle2DImages Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObstacleImgs();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Builder getObstacleImgs();
  inline void setObstacleImgs( ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Builder initObstacleImgs(unsigned int size);
  inline void adoptObstacleImgs(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>> disownObstacleImgs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Obstacle2DImages::Pipeline {
public:
  typedef Obstacle2DImages Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ObstacleImages::Reader {
public:
  typedef ObstacleImages Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImages() const;
  inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader getImages() const;

  inline bool hasObstacles() const;
  inline  ::senseAD::msg::avp_perception::Obstacles::Reader getObstacles() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleImages::Builder {
public:
  typedef ObstacleImages Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImages();
  inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder getImages();
  inline void setImages( ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder initImages(unsigned int size);
  inline void adoptImages(::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>> disownImages();

  inline bool hasObstacles();
  inline  ::senseAD::msg::avp_perception::Obstacles::Builder getObstacles();
  inline void setObstacles( ::senseAD::msg::avp_perception::Obstacles::Reader value);
  inline  ::senseAD::msg::avp_perception::Obstacles::Builder initObstacles();
  inline void adoptObstacles(::capnp::Orphan< ::senseAD::msg::avp_perception::Obstacles>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Obstacles> disownObstacles();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleImages::Pipeline {
public:
  typedef ObstacleImages Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Obstacles::Pipeline getObstacles();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RawIpmImage::Reader {
public:
  typedef RawIpmImage Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAvmimg() const;
  inline  ::senseAD::msg::std_msgs::Image::Reader getAvmimg() const;

  inline bool hasIpmimg() const;
  inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader getIpmimg() const;

  inline bool hasSlots() const;
  inline  ::senseAD::msg::avp_perception::ParkingSlots::Reader getSlots() const;

  inline bool hasQuadslots() const;
  inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Reader getQuadslots() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RawIpmImage::Builder {
public:
  typedef RawIpmImage Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAvmimg();
  inline  ::senseAD::msg::std_msgs::Image::Builder getAvmimg();
  inline void setAvmimg( ::senseAD::msg::std_msgs::Image::Reader value);
  inline  ::senseAD::msg::std_msgs::Image::Builder initAvmimg();
  inline void adoptAvmimg(::capnp::Orphan< ::senseAD::msg::std_msgs::Image>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Image> disownAvmimg();

  inline bool hasIpmimg();
  inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder getIpmimg();
  inline void setIpmimg( ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder initIpmimg(unsigned int size);
  inline void adoptIpmimg(::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>> disownIpmimg();

  inline bool hasSlots();
  inline  ::senseAD::msg::avp_perception::ParkingSlots::Builder getSlots();
  inline void setSlots( ::senseAD::msg::avp_perception::ParkingSlots::Reader value);
  inline  ::senseAD::msg::avp_perception::ParkingSlots::Builder initSlots();
  inline void adoptSlots(::capnp::Orphan< ::senseAD::msg::avp_perception::ParkingSlots>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::ParkingSlots> disownSlots();

  inline bool hasQuadslots();
  inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Builder getQuadslots();
  inline void setQuadslots( ::senseAD::msg::avp_perception::QuadParkingSlots::Reader value);
  inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Builder initQuadslots();
  inline void adoptQuadslots(::capnp::Orphan< ::senseAD::msg::avp_perception::QuadParkingSlots>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::QuadParkingSlots> disownQuadslots();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RawIpmImage::Pipeline {
public:
  typedef RawIpmImage Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Image::Pipeline getAvmimg();
  inline  ::senseAD::msg::avp_perception::ParkingSlots::Pipeline getSlots();
  inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Pipeline getQuadslots();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool Obstacle2DImage::Reader::hasImage() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacle2DImage::Builder::hasImage() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Image::Reader Obstacle2DImage::Reader::getImage() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Image::Builder Obstacle2DImage::Builder::getImage() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Image::Pipeline Obstacle2DImage::Pipeline::getImage() {
  return  ::senseAD::msg::std_msgs::Image::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Obstacle2DImage::Builder::setImage( ::senseAD::msg::std_msgs::Image::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Image::Builder Obstacle2DImage::Builder::initImage() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Obstacle2DImage::Builder::adoptImage(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Image>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Image> Obstacle2DImage::Builder::disownImage() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Obstacle2DImage::Reader::hasObstacles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacle2DImage::Builder::hasObstacles() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader Obstacle2DImage::Reader::getObstacles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder Obstacle2DImage::Builder::getObstacles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Obstacle2DImage::Builder::setObstacles( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder Obstacle2DImage::Builder::initObstacles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Obstacle2DImage::Builder::adoptObstacles(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>> Obstacle2DImage::Builder::disownObstacles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Obstacle2DImages::Reader::hasObstacleImgs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacle2DImages::Builder::hasObstacleImgs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Reader Obstacle2DImages::Reader::getObstacleImgs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Builder Obstacle2DImages::Builder::getObstacleImgs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Obstacle2DImages::Builder::setObstacleImgs( ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>::Builder Obstacle2DImages::Builder::initObstacleImgs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Obstacle2DImages::Builder::adoptObstacleImgs(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>> Obstacle2DImages::Builder::disownObstacleImgs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Obstacle2DImage,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ObstacleImages::Reader::hasImages() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleImages::Builder::hasImages() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader ObstacleImages::Reader::getImages() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder ObstacleImages::Builder::getImages() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ObstacleImages::Builder::setImages( ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder ObstacleImages::Builder::initImages(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ObstacleImages::Builder::adoptImages(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>> ObstacleImages::Builder::disownImages() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ObstacleImages::Reader::hasObstacles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleImages::Builder::hasObstacles() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Obstacles::Reader ObstacleImages::Reader::getObstacles() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Obstacles>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Obstacles::Builder ObstacleImages::Builder::getObstacles() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Obstacles>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Obstacles::Pipeline ObstacleImages::Pipeline::getObstacles() {
  return  ::senseAD::msg::avp_perception::Obstacles::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ObstacleImages::Builder::setObstacles( ::senseAD::msg::avp_perception::Obstacles::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Obstacles>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Obstacles::Builder ObstacleImages::Builder::initObstacles() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Obstacles>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ObstacleImages::Builder::adoptObstacles(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Obstacles>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Obstacles>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Obstacles> ObstacleImages::Builder::disownObstacles() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Obstacles>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RawIpmImage::Reader::hasAvmimg() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RawIpmImage::Builder::hasAvmimg() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Image::Reader RawIpmImage::Reader::getAvmimg() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Image::Builder RawIpmImage::Builder::getAvmimg() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Image::Pipeline RawIpmImage::Pipeline::getAvmimg() {
  return  ::senseAD::msg::std_msgs::Image::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RawIpmImage::Builder::setAvmimg( ::senseAD::msg::std_msgs::Image::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Image::Builder RawIpmImage::Builder::initAvmimg() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RawIpmImage::Builder::adoptAvmimg(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Image>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Image> RawIpmImage::Builder::disownAvmimg() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Image>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RawIpmImage::Reader::hasIpmimg() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool RawIpmImage::Builder::hasIpmimg() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader RawIpmImage::Reader::getIpmimg() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder RawIpmImage::Builder::getIpmimg() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void RawIpmImage::Builder::setIpmimg( ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>::Builder RawIpmImage::Builder::initIpmimg(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void RawIpmImage::Builder::adoptIpmimg(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>> RawIpmImage::Builder::disownIpmimg() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::std_msgs::Image,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RawIpmImage::Reader::hasSlots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool RawIpmImage::Builder::hasSlots() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::ParkingSlots::Reader RawIpmImage::Reader::getSlots() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::ParkingSlots>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::ParkingSlots::Builder RawIpmImage::Builder::getSlots() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::ParkingSlots>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::ParkingSlots::Pipeline RawIpmImage::Pipeline::getSlots() {
  return  ::senseAD::msg::avp_perception::ParkingSlots::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void RawIpmImage::Builder::setSlots( ::senseAD::msg::avp_perception::ParkingSlots::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::ParkingSlots>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::ParkingSlots::Builder RawIpmImage::Builder::initSlots() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::ParkingSlots>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void RawIpmImage::Builder::adoptSlots(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::ParkingSlots>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::ParkingSlots>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::ParkingSlots> RawIpmImage::Builder::disownSlots() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::ParkingSlots>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool RawIpmImage::Reader::hasQuadslots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool RawIpmImage::Builder::hasQuadslots() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Reader RawIpmImage::Reader::getQuadslots() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::QuadParkingSlots>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Builder RawIpmImage::Builder::getQuadslots() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::QuadParkingSlots>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Pipeline RawIpmImage::Pipeline::getQuadslots() {
  return  ::senseAD::msg::avp_perception::QuadParkingSlots::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void RawIpmImage::Builder::setQuadslots( ::senseAD::msg::avp_perception::QuadParkingSlots::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::QuadParkingSlots>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::QuadParkingSlots::Builder RawIpmImage::Builder::initQuadslots() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::QuadParkingSlots>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void RawIpmImage::Builder::adoptQuadslots(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::QuadParkingSlots>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::QuadParkingSlots>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::QuadParkingSlots> RawIpmImage::Builder::disownQuadslots() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::QuadParkingSlots>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

