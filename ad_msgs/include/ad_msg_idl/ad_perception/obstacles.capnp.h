// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: obstacles.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <ad_msg_idl/ad_perception/base.capnp.h>
#include <ad_msg_idl/ad_perception/uss_range.capnp.h>
#include <ad_msg_idl/std_msgs/header.capnp.h>

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(935f87b2b82ef8b4);
enum class ObstacleMotionStatus_935f87b2b82ef8b4: uint16_t {
  MOTION_STATUS_UNKNOWN,
  MOTION_STATUS_MOVING,
  MOTION_STATUS_STILL,
};
CAPNP_DECLARE_ENUM(ObstacleMotionStatus, 935f87b2b82ef8b4);
CAPNP_DECLARE_SCHEMA(9eb07ab49cbf41be);
CAPNP_DECLARE_SCHEMA(e76f5c6163a941dd);
CAPNP_DECLARE_SCHEMA(9d0b333b68bcf11c);
CAPNP_DECLARE_SCHEMA(8f5ceb3137399565);
CAPNP_DECLARE_SCHEMA(f237374b64fe5732);
CAPNP_DECLARE_SCHEMA(99fc355aeaf4bd79);
CAPNP_DECLARE_SCHEMA(ec8378b359faa399);
CAPNP_DECLARE_SCHEMA(f85de2d63584fb05);
CAPNP_DECLARE_SCHEMA(f7653d11a9515246);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace avp_perception {

typedef ::capnp::schemas::ObstacleMotionStatus_935f87b2b82ef8b4 ObstacleMotionStatus;

struct ObstacleTrajectoryPoint {
  ObstacleTrajectoryPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9eb07ab49cbf41be, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ObstacleTrajectory {
  ObstacleTrajectory() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e76f5c6163a941dd, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ObstacleCube {
  ObstacleCube() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d0b333b68bcf11c, 2, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ObstacleCylindrical {
  ObstacleCylindrical() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f5ceb3137399565, 4, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ObstacleRaw {
  ObstacleRaw() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f237374b64fe5732, 3, 11)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Obstacles {
  Obstacles() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99fc355aeaf4bd79, 0, 7)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FSLinePt {
  FSLinePt() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec8378b359faa399, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FSLineResult {
  FSLineResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f85de2d63584fb05, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FSLineFrame {
  FSLineFrame() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7653d11a9515246, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class ObstacleTrajectoryPoint::Reader {
public:
  typedef ObstacleTrajectoryPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getDeltaTNs() const;

  inline bool hasCenter() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getCenter() const;

  inline bool hasDirection() const;
  inline  ::senseAD::msg::avp_perception::Vector3f::Reader getDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleTrajectoryPoint::Builder {
public:
  typedef ObstacleTrajectoryPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getDeltaTNs();
  inline void setDeltaTNs( ::uint64_t value);

  inline bool hasCenter();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getCenter();
  inline void setCenter( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initCenter();
  inline void adoptCenter(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownCenter();

  inline bool hasDirection();
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder getDirection();
  inline void setDirection( ::senseAD::msg::avp_perception::Vector3f::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3f::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> disownDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleTrajectoryPoint::Pipeline {
public:
  typedef ObstacleTrajectoryPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getCenter();
  inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline getDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ObstacleTrajectory::Reader {
public:
  typedef ObstacleTrajectory Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::ObstacleMotionStatus getMotionStatus() const;

  inline float getConfidence() const;

  inline bool hasPoints() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Reader getPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleTrajectory::Builder {
public:
  typedef ObstacleTrajectory Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::senseAD::msg::avp_perception::ObstacleMotionStatus getMotionStatus();
  inline void setMotionStatus( ::senseAD::msg::avp_perception::ObstacleMotionStatus value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool hasPoints();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Builder getPoints();
  inline void setPoints( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Builder initPoints(unsigned int size);
  inline void adoptPoints(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>> disownPoints();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleTrajectory::Pipeline {
public:
  typedef ObstacleTrajectory Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ObstacleCube::Reader {
public:
  typedef ObstacleCube Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCamera() const;
  inline  ::capnp::Text::Reader getCamera() const;

  inline  ::int32_t getLabel() const;

  inline float getTypeConfidence() const;

  inline float getExistenceConfidence() const;

  inline  ::int32_t getTrackId() const;

  inline bool hasCenter() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getCenter() const;

  inline bool hasShape() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getShape() const;

  inline bool hasDirection() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getDirection() const;

  inline bool hasMotionInfo() const;
  inline  ::senseAD::msg::avp_perception::MotionInfo::Reader getMotionInfo() const;

  inline bool hasTrajectory() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader getTrajectory() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleCube::Builder {
public:
  typedef ObstacleCube Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCamera();
  inline  ::capnp::Text::Builder getCamera();
  inline void setCamera( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCamera(unsigned int size);
  inline void adoptCamera(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCamera();

  inline  ::int32_t getLabel();
  inline void setLabel( ::int32_t value);

  inline float getTypeConfidence();
  inline void setTypeConfidence(float value);

  inline float getExistenceConfidence();
  inline void setExistenceConfidence(float value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline bool hasCenter();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getCenter();
  inline void setCenter( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initCenter();
  inline void adoptCenter(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownCenter();

  inline bool hasShape();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getShape();
  inline void setShape( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initShape();
  inline void adoptShape(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownShape();

  inline bool hasDirection();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getDirection();
  inline void setDirection( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownDirection();

  inline bool hasMotionInfo();
  inline  ::senseAD::msg::avp_perception::MotionInfo::Builder getMotionInfo();
  inline void setMotionInfo( ::senseAD::msg::avp_perception::MotionInfo::Reader value);
  inline  ::senseAD::msg::avp_perception::MotionInfo::Builder initMotionInfo();
  inline void adoptMotionInfo(::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo> disownMotionInfo();

  inline bool hasTrajectory();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder getTrajectory();
  inline void setTrajectory( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder initTrajectory(unsigned int size);
  inline void adoptTrajectory(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>> disownTrajectory();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleCube::Pipeline {
public:
  typedef ObstacleCube Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getCenter();
  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getShape();
  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getDirection();
  inline  ::senseAD::msg::avp_perception::MotionInfo::Pipeline getMotionInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ObstacleCylindrical::Reader {
public:
  typedef ObstacleCylindrical Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCamera() const;
  inline  ::capnp::Text::Reader getCamera() const;

  inline  ::int32_t getLabel() const;

  inline float getTypeConfidence() const;

  inline float getExistenceConfidence() const;

  inline  ::int32_t getTrackId() const;

  inline bool hasCenter() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getCenter() const;

  inline float getRadius() const;

  inline float getHeight() const;

  inline bool hasDirection() const;
  inline  ::senseAD::msg::avp_perception::Vector3d::Reader getDirection() const;

  inline bool hasMotionInfo() const;
  inline  ::senseAD::msg::avp_perception::MotionInfo::Reader getMotionInfo() const;

  inline bool hasTrajectory() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader getTrajectory() const;

  inline  ::int32_t getStaticState() const;

  inline float getAttrScore() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleCylindrical::Builder {
public:
  typedef ObstacleCylindrical Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCamera();
  inline  ::capnp::Text::Builder getCamera();
  inline void setCamera( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCamera(unsigned int size);
  inline void adoptCamera(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCamera();

  inline  ::int32_t getLabel();
  inline void setLabel( ::int32_t value);

  inline float getTypeConfidence();
  inline void setTypeConfidence(float value);

  inline float getExistenceConfidence();
  inline void setExistenceConfidence(float value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline bool hasCenter();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getCenter();
  inline void setCenter( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initCenter();
  inline void adoptCenter(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownCenter();

  inline float getRadius();
  inline void setRadius(float value);

  inline float getHeight();
  inline void setHeight(float value);

  inline bool hasDirection();
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder getDirection();
  inline void setDirection( ::senseAD::msg::avp_perception::Vector3d::Reader value);
  inline  ::senseAD::msg::avp_perception::Vector3d::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> disownDirection();

  inline bool hasMotionInfo();
  inline  ::senseAD::msg::avp_perception::MotionInfo::Builder getMotionInfo();
  inline void setMotionInfo( ::senseAD::msg::avp_perception::MotionInfo::Reader value);
  inline  ::senseAD::msg::avp_perception::MotionInfo::Builder initMotionInfo();
  inline void adoptMotionInfo(::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo> disownMotionInfo();

  inline bool hasTrajectory();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder getTrajectory();
  inline void setTrajectory( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder initTrajectory(unsigned int size);
  inline void adoptTrajectory(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>> disownTrajectory();

  inline  ::int32_t getStaticState();
  inline void setStaticState( ::int32_t value);

  inline float getAttrScore();
  inline void setAttrScore(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleCylindrical::Pipeline {
public:
  typedef ObstacleCylindrical Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getCenter();
  inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline getDirection();
  inline  ::senseAD::msg::avp_perception::MotionInfo::Pipeline getMotionInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ObstacleRaw::Reader {
public:
  typedef ObstacleRaw Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCamera() const;
  inline  ::capnp::Text::Reader getCamera() const;

  inline  ::int32_t getLabel() const;

  inline float getTypeConfidence() const;

  inline float getExistenceConfidence() const;

  inline bool hasBox() const;
  inline  ::senseAD::msg::avp_perception::Bbox2D::Reader getBox() const;

  inline bool hasDirectionInfo() const;
  inline  ::senseAD::msg::avp_perception::DirectionInfo::Reader getDirectionInfo() const;

  inline bool hasLandmark() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getLandmark() const;

  inline bool hasLandmarkScores() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getLandmarkScores() const;

  inline bool hasLandmark4() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getLandmark4() const;

  inline bool hasLandmark4Scores() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getLandmark4Scores() const;

  inline bool hasLandmark9() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader getLandmark9() const;

  inline bool hasLandmark9Scores() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getLandmark9Scores() const;

  inline bool hasPositionInfo() const;
  inline  ::senseAD::msg::avp_perception::PositionInfo::Reader getPositionInfo() const;

  inline bool hasBox3D() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getBox3D() const;

  inline  ::int32_t getStaticState() const;

  inline float getAttrScore() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleRaw::Builder {
public:
  typedef ObstacleRaw Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCamera();
  inline  ::capnp::Text::Builder getCamera();
  inline void setCamera( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCamera(unsigned int size);
  inline void adoptCamera(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCamera();

  inline  ::int32_t getLabel();
  inline void setLabel( ::int32_t value);

  inline float getTypeConfidence();
  inline void setTypeConfidence(float value);

  inline float getExistenceConfidence();
  inline void setExistenceConfidence(float value);

  inline bool hasBox();
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder getBox();
  inline void setBox( ::senseAD::msg::avp_perception::Bbox2D::Reader value);
  inline  ::senseAD::msg::avp_perception::Bbox2D::Builder initBox();
  inline void adoptBox(::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> disownBox();

  inline bool hasDirectionInfo();
  inline  ::senseAD::msg::avp_perception::DirectionInfo::Builder getDirectionInfo();
  inline void setDirectionInfo( ::senseAD::msg::avp_perception::DirectionInfo::Reader value);
  inline  ::senseAD::msg::avp_perception::DirectionInfo::Builder initDirectionInfo();
  inline void adoptDirectionInfo(::capnp::Orphan< ::senseAD::msg::avp_perception::DirectionInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::DirectionInfo> disownDirectionInfo();

  inline bool hasLandmark();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getLandmark();
  inline void setLandmark( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initLandmark(unsigned int size);
  inline void adoptLandmark(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownLandmark();

  inline bool hasLandmarkScores();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getLandmarkScores();
  inline void setLandmarkScores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setLandmarkScores(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initLandmarkScores(unsigned int size);
  inline void adoptLandmarkScores(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownLandmarkScores();

  inline bool hasLandmark4();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getLandmark4();
  inline void setLandmark4( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initLandmark4(unsigned int size);
  inline void adoptLandmark4(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownLandmark4();

  inline bool hasLandmark4Scores();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getLandmark4Scores();
  inline void setLandmark4Scores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setLandmark4Scores(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initLandmark4Scores(unsigned int size);
  inline void adoptLandmark4Scores(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownLandmark4Scores();

  inline bool hasLandmark9();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder getLandmark9();
  inline void setLandmark9( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder initLandmark9(unsigned int size);
  inline void adoptLandmark9(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> disownLandmark9();

  inline bool hasLandmark9Scores();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getLandmark9Scores();
  inline void setLandmark9Scores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setLandmark9Scores(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initLandmark9Scores(unsigned int size);
  inline void adoptLandmark9Scores(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownLandmark9Scores();

  inline bool hasPositionInfo();
  inline  ::senseAD::msg::avp_perception::PositionInfo::Builder getPositionInfo();
  inline void setPositionInfo( ::senseAD::msg::avp_perception::PositionInfo::Reader value);
  inline  ::senseAD::msg::avp_perception::PositionInfo::Builder initPositionInfo();
  inline void adoptPositionInfo(::capnp::Orphan< ::senseAD::msg::avp_perception::PositionInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::avp_perception::PositionInfo> disownPositionInfo();

  inline bool hasBox3D();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getBox3D();
  inline void setBox3D( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setBox3D(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initBox3D(unsigned int size);
  inline void adoptBox3D(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownBox3D();

  inline  ::int32_t getStaticState();
  inline void setStaticState( ::int32_t value);

  inline float getAttrScore();
  inline void setAttrScore(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleRaw::Pipeline {
public:
  typedef ObstacleRaw Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline getBox();
  inline  ::senseAD::msg::avp_perception::DirectionInfo::Pipeline getDirectionInfo();
  inline  ::senseAD::msg::avp_perception::PositionInfo::Pipeline getPositionInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Obstacles::Reader {
public:
  typedef Obstacles Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasCylindricalObstacles() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Reader getCylindricalObstacles() const;

  inline bool hasCubeObstacles() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Reader getCubeObstacles() const;

  inline bool hasRawObjects() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader getRawObjects() const;

  inline bool hasRangeUnitArray() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Reader getRangeUnitArray() const;

  inline bool hasCameras() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getCameras() const;

  inline bool hasTimestamps() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getTimestamps() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Obstacles::Builder {
public:
  typedef Obstacles Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasCylindricalObstacles();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Builder getCylindricalObstacles();
  inline void setCylindricalObstacles( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Builder initCylindricalObstacles(unsigned int size);
  inline void adoptCylindricalObstacles(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>> disownCylindricalObstacles();

  inline bool hasCubeObstacles();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Builder getCubeObstacles();
  inline void setCubeObstacles( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Builder initCubeObstacles(unsigned int size);
  inline void adoptCubeObstacles(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>> disownCubeObstacles();

  inline bool hasRawObjects();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder getRawObjects();
  inline void setRawObjects( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder initRawObjects(unsigned int size);
  inline void adoptRawObjects(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>> disownRawObjects();

  inline bool hasRangeUnitArray();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Builder getRangeUnitArray();
  inline void setRangeUnitArray( ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Builder initRangeUnitArray(unsigned int size);
  inline void adoptRangeUnitArray(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>> disownRangeUnitArray();

  inline bool hasCameras();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getCameras();
  inline void setCameras( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setCameras(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initCameras(unsigned int size);
  inline void adoptCameras(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownCameras();

  inline bool hasTimestamps();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getTimestamps();
  inline void setTimestamps( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setTimestamps(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initTimestamps(unsigned int size);
  inline void adoptTimestamps(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownTimestamps();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Obstacles::Pipeline {
public:
  typedef Obstacles Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FSLinePt::Reader {
public:
  typedef FSLinePt Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getV() const;

  inline  ::uint8_t getLabel() const;

  inline bool getIsValid() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FSLinePt::Builder {
public:
  typedef FSLinePt Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getV();
  inline void setV( ::int16_t value);

  inline  ::uint8_t getLabel();
  inline void setLabel( ::uint8_t value);

  inline bool getIsValid();
  inline void setIsValid(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FSLinePt::Pipeline {
public:
  typedef FSLinePt Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FSLineResult::Reader {
public:
  typedef FSLineResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFsLinePts() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Reader getFsLinePts() const;

  inline  ::uint64_t getTimestampNs() const;

  inline bool getIsValid() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FSLineResult::Builder {
public:
  typedef FSLineResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFsLinePts();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Builder getFsLinePts();
  inline void setFsLinePts( ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Builder initFsLinePts(unsigned int size);
  inline void adoptFsLinePts(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>> disownFsLinePts();

  inline  ::uint64_t getTimestampNs();
  inline void setTimestampNs( ::uint64_t value);

  inline bool getIsValid();
  inline void setIsValid(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FSLineResult::Pipeline {
public:
  typedef FSLineResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FSLineFrame::Reader {
public:
  typedef FSLineFrame Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasFisheyeFsLineResults() const;
  inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Reader getFisheyeFsLineResults() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FSLineFrame::Builder {
public:
  typedef FSLineFrame Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasFisheyeFsLineResults();
  inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Builder getFisheyeFsLineResults();
  inline void setFisheyeFsLineResults( ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Builder initFisheyeFsLineResults(unsigned int size);
  inline void adoptFisheyeFsLineResults(::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>> disownFisheyeFsLineResults();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FSLineFrame::Pipeline {
public:
  typedef FSLineFrame Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t ObstacleTrajectoryPoint::Reader::getDeltaTNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t ObstacleTrajectoryPoint::Builder::getDeltaTNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ObstacleTrajectoryPoint::Builder::setDeltaTNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleTrajectoryPoint::Reader::hasCenter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleTrajectoryPoint::Builder::hasCenter() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader ObstacleTrajectoryPoint::Reader::getCenter() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder ObstacleTrajectoryPoint::Builder::getCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline ObstacleTrajectoryPoint::Pipeline::getCenter() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ObstacleTrajectoryPoint::Builder::setCenter( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder ObstacleTrajectoryPoint::Builder::initCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ObstacleTrajectoryPoint::Builder::adoptCenter(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> ObstacleTrajectoryPoint::Builder::disownCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ObstacleTrajectoryPoint::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleTrajectoryPoint::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3f::Reader ObstacleTrajectoryPoint::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder ObstacleTrajectoryPoint::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3f::Pipeline ObstacleTrajectoryPoint::Pipeline::getDirection() {
  return  ::senseAD::msg::avp_perception::Vector3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ObstacleTrajectoryPoint::Builder::setDirection( ::senseAD::msg::avp_perception::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3f::Builder ObstacleTrajectoryPoint::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ObstacleTrajectoryPoint::Builder::adoptDirection(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3f> ObstacleTrajectoryPoint::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::senseAD::msg::avp_perception::ObstacleMotionStatus ObstacleTrajectory::Reader::getMotionStatus() const {
  return _reader.getDataField< ::senseAD::msg::avp_perception::ObstacleMotionStatus>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::senseAD::msg::avp_perception::ObstacleMotionStatus ObstacleTrajectory::Builder::getMotionStatus() {
  return _builder.getDataField< ::senseAD::msg::avp_perception::ObstacleMotionStatus>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ObstacleTrajectory::Builder::setMotionStatus( ::senseAD::msg::avp_perception::ObstacleMotionStatus value) {
  _builder.setDataField< ::senseAD::msg::avp_perception::ObstacleMotionStatus>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleTrajectory::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ObstacleTrajectory::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ObstacleTrajectory::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleTrajectory::Reader::hasPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleTrajectory::Builder::hasPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Reader ObstacleTrajectory::Reader::getPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Builder ObstacleTrajectory::Builder::getPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ObstacleTrajectory::Builder::setPoints( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>::Builder ObstacleTrajectory::Builder::initPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ObstacleTrajectory::Builder::adoptPoints(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>> ObstacleTrajectory::Builder::disownPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectoryPoint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ObstacleCube::Reader::hasCamera() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCube::Builder::hasCamera() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ObstacleCube::Reader::getCamera() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ObstacleCube::Builder::getCamera() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ObstacleCube::Builder::setCamera( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ObstacleCube::Builder::initCamera(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ObstacleCube::Builder::adoptCamera(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ObstacleCube::Builder::disownCamera() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t ObstacleCube::Reader::getLabel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleCube::Builder::getLabel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ObstacleCube::Builder::setLabel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleCube::Reader::getTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ObstacleCube::Builder::getTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ObstacleCube::Builder::setTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleCube::Reader::getExistenceConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ObstacleCube::Builder::getExistenceConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ObstacleCube::Builder::setExistenceConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ObstacleCube::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleCube::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ObstacleCube::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleCube::Reader::hasCenter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCube::Builder::hasCenter() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader ObstacleCube::Reader::getCenter() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCube::Builder::getCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline ObstacleCube::Pipeline::getCenter() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ObstacleCube::Builder::setCenter( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCube::Builder::initCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ObstacleCube::Builder::adoptCenter(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> ObstacleCube::Builder::disownCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ObstacleCube::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCube::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader ObstacleCube::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCube::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline ObstacleCube::Pipeline::getShape() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void ObstacleCube::Builder::setShape( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCube::Builder::initShape() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ObstacleCube::Builder::adoptShape(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> ObstacleCube::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool ObstacleCube::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCube::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader ObstacleCube::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCube::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline ObstacleCube::Pipeline::getDirection() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void ObstacleCube::Builder::setDirection( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCube::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void ObstacleCube::Builder::adoptDirection(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> ObstacleCube::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool ObstacleCube::Reader::hasMotionInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCube::Builder::hasMotionInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::MotionInfo::Reader ObstacleCube::Reader::getMotionInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::MotionInfo::Builder ObstacleCube::Builder::getMotionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::MotionInfo::Pipeline ObstacleCube::Pipeline::getMotionInfo() {
  return  ::senseAD::msg::avp_perception::MotionInfo::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void ObstacleCube::Builder::setMotionInfo( ::senseAD::msg::avp_perception::MotionInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::MotionInfo::Builder ObstacleCube::Builder::initMotionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void ObstacleCube::Builder::adoptMotionInfo(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo> ObstacleCube::Builder::disownMotionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool ObstacleCube::Reader::hasTrajectory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCube::Builder::hasTrajectory() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader ObstacleCube::Reader::getTrajectory() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder ObstacleCube::Builder::getTrajectory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void ObstacleCube::Builder::setTrajectory( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder ObstacleCube::Builder::initTrajectory(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void ObstacleCube::Builder::adoptTrajectory(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>> ObstacleCube::Builder::disownTrajectory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool ObstacleCylindrical::Reader::hasCamera() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCylindrical::Builder::hasCamera() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ObstacleCylindrical::Reader::getCamera() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ObstacleCylindrical::Builder::getCamera() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ObstacleCylindrical::Builder::setCamera( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ObstacleCylindrical::Builder::initCamera(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ObstacleCylindrical::Builder::adoptCamera(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ObstacleCylindrical::Builder::disownCamera() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t ObstacleCylindrical::Reader::getLabel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleCylindrical::Builder::getLabel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setLabel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleCylindrical::Reader::getTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ObstacleCylindrical::Builder::getTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleCylindrical::Reader::getExistenceConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ObstacleCylindrical::Builder::getExistenceConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setExistenceConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ObstacleCylindrical::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleCylindrical::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleCylindrical::Reader::hasCenter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCylindrical::Builder::hasCenter() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader ObstacleCylindrical::Reader::getCenter() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCylindrical::Builder::getCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline ObstacleCylindrical::Pipeline::getCenter() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ObstacleCylindrical::Builder::setCenter( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCylindrical::Builder::initCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ObstacleCylindrical::Builder::adoptCenter(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> ObstacleCylindrical::Builder::disownCenter() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float ObstacleCylindrical::Reader::getRadius() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float ObstacleCylindrical::Builder::getRadius() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setRadius(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleCylindrical::Reader::getHeight() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float ObstacleCylindrical::Builder::getHeight() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setHeight(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleCylindrical::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCylindrical::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Vector3d::Reader ObstacleCylindrical::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCylindrical::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Vector3d::Pipeline ObstacleCylindrical::Pipeline::getDirection() {
  return  ::senseAD::msg::avp_perception::Vector3d::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void ObstacleCylindrical::Builder::setDirection( ::senseAD::msg::avp_perception::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Vector3d::Builder ObstacleCylindrical::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ObstacleCylindrical::Builder::adoptDirection(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Vector3d> ObstacleCylindrical::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool ObstacleCylindrical::Reader::hasMotionInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCylindrical::Builder::hasMotionInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::MotionInfo::Reader ObstacleCylindrical::Reader::getMotionInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::MotionInfo::Builder ObstacleCylindrical::Builder::getMotionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::MotionInfo::Pipeline ObstacleCylindrical::Pipeline::getMotionInfo() {
  return  ::senseAD::msg::avp_perception::MotionInfo::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void ObstacleCylindrical::Builder::setMotionInfo( ::senseAD::msg::avp_perception::MotionInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::MotionInfo::Builder ObstacleCylindrical::Builder::initMotionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void ObstacleCylindrical::Builder::adoptMotionInfo(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::MotionInfo> ObstacleCylindrical::Builder::disownMotionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::MotionInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool ObstacleCylindrical::Reader::hasTrajectory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleCylindrical::Builder::hasTrajectory() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader ObstacleCylindrical::Reader::getTrajectory() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder ObstacleCylindrical::Builder::getTrajectory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void ObstacleCylindrical::Builder::setTrajectory( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>::Builder ObstacleCylindrical::Builder::initTrajectory(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void ObstacleCylindrical::Builder::adoptTrajectory(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>> ObstacleCylindrical::Builder::disownTrajectory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleTrajectory,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::int32_t ObstacleCylindrical::Reader::getStaticState() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleCylindrical::Builder::getStaticState() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setStaticState( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleCylindrical::Reader::getAttrScore() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float ObstacleCylindrical::Builder::getAttrScore() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void ObstacleCylindrical::Builder::setAttrScore(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleRaw::Reader::hasCamera() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasCamera() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ObstacleRaw::Reader::getCamera() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ObstacleRaw::Builder::getCamera() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setCamera( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ObstacleRaw::Builder::initCamera(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptCamera(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ObstacleRaw::Builder::disownCamera() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t ObstacleRaw::Reader::getLabel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleRaw::Builder::getLabel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ObstacleRaw::Builder::setLabel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleRaw::Reader::getTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ObstacleRaw::Builder::getTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ObstacleRaw::Builder::setTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleRaw::Reader::getExistenceConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ObstacleRaw::Builder::getExistenceConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ObstacleRaw::Builder::setExistenceConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool ObstacleRaw::Reader::hasBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Reader ObstacleRaw::Reader::getBox() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder ObstacleRaw::Builder::getBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::Bbox2D::Pipeline ObstacleRaw::Pipeline::getBox() {
  return  ::senseAD::msg::avp_perception::Bbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ObstacleRaw::Builder::setBox( ::senseAD::msg::avp_perception::Bbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::Bbox2D::Builder ObstacleRaw::Builder::initBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::adoptBox(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::Bbox2D> ObstacleRaw::Builder::disownBox() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::Bbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasDirectionInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasDirectionInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::DirectionInfo::Reader ObstacleRaw::Reader::getDirectionInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::DirectionInfo>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::DirectionInfo::Builder ObstacleRaw::Builder::getDirectionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::DirectionInfo>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::DirectionInfo::Pipeline ObstacleRaw::Pipeline::getDirectionInfo() {
  return  ::senseAD::msg::avp_perception::DirectionInfo::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void ObstacleRaw::Builder::setDirectionInfo( ::senseAD::msg::avp_perception::DirectionInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::DirectionInfo>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::DirectionInfo::Builder ObstacleRaw::Builder::initDirectionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::DirectionInfo>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::adoptDirectionInfo(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::DirectionInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::DirectionInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::DirectionInfo> ObstacleRaw::Builder::disownDirectionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::DirectionInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasLandmark() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasLandmark() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader ObstacleRaw::Reader::getLandmark() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder ObstacleRaw::Builder::getLandmark() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setLandmark( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder ObstacleRaw::Builder::initLandmark(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptLandmark(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> ObstacleRaw::Builder::disownLandmark() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasLandmarkScores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasLandmarkScores() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader ObstacleRaw::Reader::getLandmarkScores() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::getLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setLandmarkScores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline void ObstacleRaw::Builder::setLandmarkScores(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::initLandmarkScores(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptLandmarkScores(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> ObstacleRaw::Builder::disownLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasLandmark4() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasLandmark4() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader ObstacleRaw::Reader::getLandmark4() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder ObstacleRaw::Builder::getLandmark4() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setLandmark4( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder ObstacleRaw::Builder::initLandmark4(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptLandmark4(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> ObstacleRaw::Builder::disownLandmark4() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasLandmark4Scores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasLandmark4Scores() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader ObstacleRaw::Reader::getLandmark4Scores() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::getLandmark4Scores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setLandmark4Scores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline void ObstacleRaw::Builder::setLandmark4Scores(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::initLandmark4Scores(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptLandmark4Scores(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> ObstacleRaw::Builder::disownLandmark4Scores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasLandmark9() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasLandmark9() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader ObstacleRaw::Reader::getLandmark9() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder ObstacleRaw::Builder::getLandmark9() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setLandmark9( ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>::Builder ObstacleRaw::Builder::initLandmark9(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptLandmark9(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>> ObstacleRaw::Builder::disownLandmark9() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasLandmark9Scores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasLandmark9Scores() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader ObstacleRaw::Reader::getLandmark9Scores() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::getLandmark9Scores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setLandmark9Scores( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline void ObstacleRaw::Builder::setLandmark9Scores(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::initLandmark9Scores(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptLandmark9Scores(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> ObstacleRaw::Builder::disownLandmark9Scores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasPositionInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasPositionInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::avp_perception::PositionInfo::Reader ObstacleRaw::Reader::getPositionInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::PositionInfo>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::avp_perception::PositionInfo::Builder ObstacleRaw::Builder::getPositionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::PositionInfo>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::avp_perception::PositionInfo::Pipeline ObstacleRaw::Pipeline::getPositionInfo() {
  return  ::senseAD::msg::avp_perception::PositionInfo::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void ObstacleRaw::Builder::setPositionInfo( ::senseAD::msg::avp_perception::PositionInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::PositionInfo>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::avp_perception::PositionInfo::Builder ObstacleRaw::Builder::initPositionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::PositionInfo>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::adoptPositionInfo(
    ::capnp::Orphan< ::senseAD::msg::avp_perception::PositionInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::PositionInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::avp_perception::PositionInfo> ObstacleRaw::Builder::disownPositionInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::avp_perception::PositionInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool ObstacleRaw::Reader::hasBox3D() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool ObstacleRaw::Builder::hasBox3D() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader ObstacleRaw::Reader::getBox3D() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::getBox3D() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void ObstacleRaw::Builder::setBox3D( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline void ObstacleRaw::Builder::setBox3D(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder ObstacleRaw::Builder::initBox3D(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), size);
}
inline void ObstacleRaw::Builder::adoptBox3D(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> ObstacleRaw::Builder::disownBox3D() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline  ::int32_t ObstacleRaw::Reader::getStaticState() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ObstacleRaw::Builder::getStaticState() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ObstacleRaw::Builder::setStaticState( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float ObstacleRaw::Reader::getAttrScore() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float ObstacleRaw::Builder::getAttrScore() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void ObstacleRaw::Builder::setAttrScore(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool Obstacles::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader Obstacles::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder Obstacles::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline Obstacles::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Obstacles::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder Obstacles::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> Obstacles::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Obstacles::Reader::hasCylindricalObstacles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasCylindricalObstacles() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Reader Obstacles::Reader::getCylindricalObstacles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::getCylindricalObstacles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::setCylindricalObstacles( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::initCylindricalObstacles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Obstacles::Builder::adoptCylindricalObstacles(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>> Obstacles::Builder::disownCylindricalObstacles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCylindrical,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Obstacles::Reader::hasCubeObstacles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasCubeObstacles() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Reader Obstacles::Reader::getCubeObstacles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::getCubeObstacles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::setCubeObstacles( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::initCubeObstacles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Obstacles::Builder::adoptCubeObstacles(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>> Obstacles::Builder::disownCubeObstacles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleCube,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Obstacles::Reader::hasRawObjects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasRawObjects() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader Obstacles::Reader::getRawObjects() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::getRawObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::setRawObjects( ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::initRawObjects(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Obstacles::Builder::adoptRawObjects(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>> Obstacles::Builder::disownRawObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::ObstacleRaw,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Obstacles::Reader::hasRangeUnitArray() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasRangeUnitArray() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Reader Obstacles::Reader::getRangeUnitArray() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::getRangeUnitArray() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::setRangeUnitArray( ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>::Builder Obstacles::Builder::initRangeUnitArray(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Obstacles::Builder::adoptRangeUnitArray(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>> Obstacles::Builder::disownRangeUnitArray() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::UssRange,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Obstacles::Reader::hasCameras() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasCameras() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Obstacles::Reader::getCameras() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Obstacles::Builder::getCameras() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::setCameras( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline void Obstacles::Builder::setCameras(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Obstacles::Builder::initCameras(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void Obstacles::Builder::adoptCameras(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Obstacles::Builder::disownCameras() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Obstacles::Reader::hasTimestamps() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool Obstacles::Builder::hasTimestamps() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Obstacles::Reader::getTimestamps() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Obstacles::Builder::getTimestamps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void Obstacles::Builder::setTimestamps( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline void Obstacles::Builder::setTimestamps(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Obstacles::Builder::initTimestamps(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void Obstacles::Builder::adoptTimestamps(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Obstacles::Builder::disownTimestamps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline  ::int16_t FSLinePt::Reader::getV() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t FSLinePt::Builder::getV() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FSLinePt::Builder::setV( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t FSLinePt::Reader::getLabel() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t FSLinePt::Builder::getLabel() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FSLinePt::Builder::setLabel( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool FSLinePt::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}

inline bool FSLinePt::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}
inline void FSLinePt::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS, value);
}

inline bool FSLineResult::Reader::hasFsLinePts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FSLineResult::Builder::hasFsLinePts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Reader FSLineResult::Reader::getFsLinePts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Builder FSLineResult::Builder::getFsLinePts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FSLineResult::Builder::setFsLinePts( ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>::Builder FSLineResult::Builder::initFsLinePts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FSLineResult::Builder::adoptFsLinePts(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>> FSLineResult::Builder::disownFsLinePts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLinePt,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t FSLineResult::Reader::getTimestampNs() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t FSLineResult::Builder::getTimestampNs() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FSLineResult::Builder::setTimestampNs( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FSLineResult::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool FSLineResult::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void FSLineResult::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool FSLineFrame::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FSLineFrame::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader FSLineFrame::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder FSLineFrame::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline FSLineFrame::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FSLineFrame::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder FSLineFrame::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FSLineFrame::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> FSLineFrame::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FSLineFrame::Reader::hasFisheyeFsLineResults() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FSLineFrame::Builder::hasFisheyeFsLineResults() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Reader FSLineFrame::Reader::getFisheyeFsLineResults() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Builder FSLineFrame::Builder::getFisheyeFsLineResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FSLineFrame::Builder::setFisheyeFsLineResults( ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>::Builder FSLineFrame::Builder::initFisheyeFsLineResults(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void FSLineFrame::Builder::adoptFisheyeFsLineResults(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>> FSLineFrame::Builder::disownFisheyeFsLineResults() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::avp_perception::FSLineResult,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

