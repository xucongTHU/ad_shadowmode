// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: gac.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(80308e9766ff870a);
CAPNP_DECLARE_SCHEMA(def9ee425dbf7602);
CAPNP_DECLARE_SCHEMA(ccc3a4f7f399f9d7);
CAPNP_DECLARE_SCHEMA(d1b14a9328f494ef);
CAPNP_DECLARE_SCHEMA(eb0946faea7a733f);
CAPNP_DECLARE_SCHEMA(a8aa8dd24af4eaef);
CAPNP_DECLARE_SCHEMA(9cf7a6e827a2d016);
CAPNP_DECLARE_SCHEMA(f82bc8524fff1da4);
CAPNP_DECLARE_SCHEMA(f899f09a09aff949);
CAPNP_DECLARE_SCHEMA(d4526b3edcd19e9d);
CAPNP_DECLARE_SCHEMA(d59ef431d26d9c23);
CAPNP_DECLARE_SCHEMA(c149b66c467dc5cf);
CAPNP_DECLARE_SCHEMA(c3115d40ca835bb8);
CAPNP_DECLARE_SCHEMA(ed22c3b0d2e13f79);
CAPNP_DECLARE_SCHEMA(e4faf87f388f667d);
CAPNP_DECLARE_SCHEMA(ec18644f7c445e11);
CAPNP_DECLARE_SCHEMA(d1bd4667a54f3c2b);
CAPNP_DECLARE_SCHEMA(efd082765304eae9);
CAPNP_DECLARE_SCHEMA(97a54fc69ab348db);
CAPNP_DECLARE_SCHEMA(aeae7f2275ad954b);
CAPNP_DECLARE_SCHEMA(d8e6ad29a2e10af0);
CAPNP_DECLARE_SCHEMA(9cf035f0a1f5edc1);
CAPNP_DECLARE_SCHEMA(8ec64d79eca94104);
CAPNP_DECLARE_SCHEMA(fa26f886ab851156);
CAPNP_DECLARE_SCHEMA(ee37ded5afd574d0);
CAPNP_DECLARE_SCHEMA(e0934e470234f19d);
CAPNP_DECLARE_SCHEMA(e623d8ebbf2d8bc7);
CAPNP_DECLARE_SCHEMA(a22a7b040aeef74b);
CAPNP_DECLARE_SCHEMA(e4ace924e88911fd);
CAPNP_DECLARE_SCHEMA(f94b30dcb3562326);
CAPNP_DECLARE_SCHEMA(de1a7b15239f0995);
CAPNP_DECLARE_SCHEMA(beb93636cd6758ba);
CAPNP_DECLARE_SCHEMA(af1aa86475031d6d);
CAPNP_DECLARE_SCHEMA(db48eb10d9d0d616);
CAPNP_DECLARE_SCHEMA(99ae1491c8d1c2bc);
CAPNP_DECLARE_SCHEMA(a633bb88d064df6c);
CAPNP_DECLARE_SCHEMA(8e8acc742b2e7ece);
CAPNP_DECLARE_SCHEMA(a40b6645b880ddc3);
CAPNP_DECLARE_SCHEMA(aed1eb0827381048);
CAPNP_DECLARE_SCHEMA(bf41711e047578c7);
CAPNP_DECLARE_SCHEMA(ca9035e136841c09);
CAPNP_DECLARE_SCHEMA(88ed6f86a62de0d7);
CAPNP_DECLARE_SCHEMA(97ee458587142e0c);
CAPNP_DECLARE_SCHEMA(e06635b5016fc6e5);
CAPNP_DECLARE_SCHEMA(b16b1051cf159991);
CAPNP_DECLARE_SCHEMA(e2b4b681af085a38);
CAPNP_DECLARE_SCHEMA(86bf31a76542423e);
CAPNP_DECLARE_SCHEMA(e6827b9e76daf86f);
CAPNP_DECLARE_SCHEMA(dbfd68df6d30c625);
CAPNP_DECLARE_SCHEMA(b4ee99fbf546579f);
CAPNP_DECLARE_SCHEMA(ad79b883ea6fe6ec);
CAPNP_DECLARE_SCHEMA(84a1ec043b4939d7);
CAPNP_DECLARE_SCHEMA(eba48fde562dd70f);
CAPNP_DECLARE_SCHEMA(a83d7d64b5e597f3);
CAPNP_DECLARE_SCHEMA(f7bf8952830d1ab3);
CAPNP_DECLARE_SCHEMA(d926482e9991d284);
CAPNP_DECLARE_SCHEMA(99c31df42e5a25a4);
CAPNP_DECLARE_SCHEMA(f986aff0b6eafdf9);
CAPNP_DECLARE_SCHEMA(986412c27c2b5623);
CAPNP_DECLARE_SCHEMA(b67570c2d32742dd);
CAPNP_DECLARE_SCHEMA(b839adb616040995);
CAPNP_DECLARE_SCHEMA(897c5dbd14e3a2fe);
CAPNP_DECLARE_SCHEMA(f7ff8427c7ca075d);
CAPNP_DECLARE_SCHEMA(bd955b3a86dca895);
CAPNP_DECLARE_SCHEMA(e75e37f4e0690efb);
CAPNP_DECLARE_SCHEMA(fbe5d2a7c81c7ff8);
CAPNP_DECLARE_SCHEMA(b722dbc49adaecff);
CAPNP_DECLARE_SCHEMA(9a426f57e544360d);
CAPNP_DECLARE_SCHEMA(a2d054a99b4aebbe);
CAPNP_DECLARE_SCHEMA(8c04f5c4e72f45df);
CAPNP_DECLARE_SCHEMA(fe4e120495aea4ff);
CAPNP_DECLARE_SCHEMA(c92d37fffcaf83b3);
CAPNP_DECLARE_SCHEMA(ec06c166d5a92e27);
CAPNP_DECLARE_SCHEMA(d80c74d5ed3d49ed);
CAPNP_DECLARE_SCHEMA(ab306c60d2061170);
CAPNP_DECLARE_SCHEMA(a1b0eb1cf2f0ee90);
CAPNP_DECLARE_SCHEMA(96a72f7cfcb17ed0);
CAPNP_DECLARE_SCHEMA(de40368fe6504bf7);
CAPNP_DECLARE_SCHEMA(e5d1b5ac33a4977b);
CAPNP_DECLARE_SCHEMA(90fb44908712ca72);
CAPNP_DECLARE_SCHEMA(ea4095ebeddeec3f);
CAPNP_DECLARE_SCHEMA(9f3e2c2cf998a6a8);
CAPNP_DECLARE_SCHEMA(f2384aef1665a0f5);
CAPNP_DECLARE_SCHEMA(83e3837e2bd303cf);
CAPNP_DECLARE_SCHEMA(8ef1467856b1800a);
CAPNP_DECLARE_SCHEMA(891b26df9c352bbf);
CAPNP_DECLARE_SCHEMA(dbe03f02a9e1fb2f);
CAPNP_DECLARE_SCHEMA(c976b407c3e37024);
CAPNP_DECLARE_SCHEMA(ea60396ebe9b785f);
CAPNP_DECLARE_SCHEMA(8a422a48b10386a7);
CAPNP_DECLARE_SCHEMA(f20357c7d3168a58);
CAPNP_DECLARE_SCHEMA(ac11e8cfff9c11a1);
CAPNP_DECLARE_SCHEMA(f1754dda94a7df14);
CAPNP_DECLARE_SCHEMA(8df246cd12359921);
CAPNP_DECLARE_SCHEMA(ab8252d7298bfed9);
CAPNP_DECLARE_SCHEMA(f1b925021f0e89e5);
CAPNP_DECLARE_SCHEMA(c3e172e79c6ebfb7);
CAPNP_DECLARE_SCHEMA(bd3bda41896713dc);
CAPNP_DECLARE_SCHEMA(b1158e1febd463fd);
CAPNP_DECLARE_SCHEMA(b959a00e133f29e1);
CAPNP_DECLARE_SCHEMA(a0a04e5c5488c929);
CAPNP_DECLARE_SCHEMA(9d3f2c5152a7bf54);
CAPNP_DECLARE_SCHEMA(8b40879863317af9);
CAPNP_DECLARE_SCHEMA(b9bb63846992b8e5);
CAPNP_DECLARE_SCHEMA(8c470a713e4338fe);
CAPNP_DECLARE_SCHEMA(dc08ae27bcc6f6a2);
CAPNP_DECLARE_SCHEMA(f154426f0766cff6);
CAPNP_DECLARE_SCHEMA(fd9d80f20e31fbaf);
CAPNP_DECLARE_SCHEMA(bc99e3261ef0abdc);
CAPNP_DECLARE_SCHEMA(d652de3f7279ce04);
CAPNP_DECLARE_SCHEMA(a9566ac3e24d7570);
CAPNP_DECLARE_SCHEMA(f9a658d4fb799ba2);
CAPNP_DECLARE_SCHEMA(d6cd1b111913eeee);
CAPNP_DECLARE_SCHEMA(b6fa8a00f282a492);
CAPNP_DECLARE_SCHEMA(c87348b610c08122);
CAPNP_DECLARE_SCHEMA(bb2a84968cb529d9);
CAPNP_DECLARE_SCHEMA(975cb0eeb65cbd03);
CAPNP_DECLARE_SCHEMA(daa4f79285dad4fd);
CAPNP_DECLARE_SCHEMA(a596d2843a13ec6b);
CAPNP_DECLARE_SCHEMA(946bcb7c51948e8e);
CAPNP_DECLARE_SCHEMA(a50918c17e77ffb1);
CAPNP_DECLARE_SCHEMA(9b267dcb67c42f66);
CAPNP_DECLARE_SCHEMA(b39b50f6ff4ec565);
CAPNP_DECLARE_SCHEMA(b3464cb10084b3ba);
CAPNP_DECLARE_SCHEMA(eb83ffeef4c5043e);
CAPNP_DECLARE_SCHEMA(d890c0b18dcb9080);
CAPNP_DECLARE_SCHEMA(865cd34d81e57b44);
CAPNP_DECLARE_SCHEMA(ad4ea4c0772854d4);
CAPNP_DECLARE_SCHEMA(98034e2ab2cee001);
CAPNP_DECLARE_SCHEMA(c71ee749e07c0538);
CAPNP_DECLARE_SCHEMA(c0c4504ab1197f97);
CAPNP_DECLARE_SCHEMA(befd3cda71b28e98);
CAPNP_DECLARE_SCHEMA(904f90518d1ee799);
CAPNP_DECLARE_SCHEMA(9006218046ccab3d);
CAPNP_DECLARE_SCHEMA(e4188cb6b3303e1e);
CAPNP_DECLARE_SCHEMA(b7723c8dd2e108c8);
CAPNP_DECLARE_SCHEMA(a906e74088544aec);
CAPNP_DECLARE_SCHEMA(df561f1dd4991872);
CAPNP_DECLARE_SCHEMA(d7bf4a0891ff2f44);
CAPNP_DECLARE_SCHEMA(e2bbba14920c76e0);
CAPNP_DECLARE_SCHEMA(cde564f55a13aed9);
CAPNP_DECLARE_SCHEMA(b5fda197475cefea);
CAPNP_DECLARE_SCHEMA(aebcdf3d6f0ee176);
CAPNP_DECLARE_SCHEMA(dd35f65543693122);
CAPNP_DECLARE_SCHEMA(c9b12bf8ad620680);
CAPNP_DECLARE_SCHEMA(c76dc735cfd1c9e2);
CAPNP_DECLARE_SCHEMA(e660537107c4039b);
CAPNP_DECLARE_SCHEMA(fe27c6f8592b8a30);
CAPNP_DECLARE_SCHEMA(b847b78c0cc120b8);
CAPNP_DECLARE_SCHEMA(aa258407a632c06b);
CAPNP_DECLARE_SCHEMA(c6f4d0eed0e58251);
CAPNP_DECLARE_SCHEMA(ee7c21c5db42cd45);
CAPNP_DECLARE_SCHEMA(897553271f942715);
CAPNP_DECLARE_SCHEMA(94c8dd8b673567d9);
CAPNP_DECLARE_SCHEMA(cf1161f4069ac64a);
CAPNP_DECLARE_SCHEMA(8cc362861100221b);
CAPNP_DECLARE_SCHEMA(9da268c6acf785b4);
CAPNP_DECLARE_SCHEMA(d0cbdf1429eb28fc);
CAPNP_DECLARE_SCHEMA(dc5599959fbd1372);
CAPNP_DECLARE_SCHEMA(8f029745b2ab4e55);
CAPNP_DECLARE_SCHEMA(fb9a1616dc3c674a);
CAPNP_DECLARE_SCHEMA(ae7a118feaaa3c7a);

}  // namespace schemas
}  // namespace capnp

namespace gac {
namespace rscl {

struct TimeStamp {
  TimeStamp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80308e9766ff870a, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point3d {
  Point3d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(def9ee425dbf7602, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VISLIGHTSPOT {
  VISLIGHTSPOT() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ccc3a4f7f399f9d7, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorVISLIGHTSPOT {
  VectorVISLIGHTSPOT() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d1b14a9328f494ef, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PilotProcessState {
  PilotProcessState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb0946faea7a733f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PilotProcessStateVector {
  PilotProcessStateVector() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8aa8dd24af4eaef, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PilotProcessStates {
  PilotProcessStates() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9cf7a6e827a2d016, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SensorSWCTimeStamp {
  SensorSWCTimeStamp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f82bc8524fff1da4, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CoordinateSystem {
  CoordinateSystem() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f899f09a09aff949, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SensorId {
  SensorId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4526b3edcd19e9d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HistInfo {
  HistInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d59ef431d26d9c23, 1, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorHistInfo {
  VectorHistInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c149b66c467dc5cf, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ObstacleTypeInfo {
  ObstacleTypeInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3115d40ca835bb8, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RoadMarkerTypeInfo {
  RoadMarkerTypeInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed22c3b0d2e13f79, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrafficSignTypeInfo {
  TrafficSignTypeInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4faf87f388f667d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrafficLightSignal {
  TrafficLightSignal() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec18644f7c445e11, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point2f {
  Point2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d1bd4667a54f3c2b, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneWidth {
  LaneWidth() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(efd082765304eae9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPoint2f {
  VectorPoint2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(97a54fc69ab348db, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point2d {
  Point2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aeae7f2275ad954b, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point3f {
  Point3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8e6ad29a2e10af0, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPoint3f {
  VectorPoint3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9cf035f0a1f5edc1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VEDAttribute {
  VEDAttribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ec64d79eca94104, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPoint3d {
  VectorPoint3d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa26f886ab851156, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector2f {
  Vector2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee37ded5afd574d0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector2d {
  Vector2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0934e470234f19d, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3f {
  Vector3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e623d8ebbf2d8bc7, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3d {
  Vector3d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a22a7b040aeef74b, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Quaterniond {
  Quaterniond() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4ace924e88911fd, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Quaternionf {
  Quaternionf() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f94b30dcb3562326, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pose3f {
  Pose3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de1a7b15239f0995, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pose3d {
  Pose3d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(beb93636cd6758ba, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Matrix3f {
  Matrix3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af1aa86475031d6d, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Matrix2f {
  Matrix2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db48eb10d9d0d616, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PathPoint {
  PathPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99ae1491c8d1c2bc, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPathPoint {
  VectorPathPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a633bb88d064df6c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ImageKeyPoint {
  ImageKeyPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e8acc742b2e7ece, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorImageKeyPoint {
  VectorImageKeyPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a40b6645b880ddc3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ImageBbox2D {
  ImageBbox2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aed1eb0827381048, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BirdViewBbox2D {
  BirdViewBbox2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf41711e047578c7, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Bbox3D {
  Bbox3D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca9035e136841c09, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IntervalInfo {
  IntervalInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(88ed6f86a62de0d7, 5, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorIntervalInfo {
  VectorIntervalInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(97ee458587142e0c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point3dAttribute {
  Point3dAttribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e06635b5016fc6e5, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPoint3dAttribute {
  VectorPoint3dAttribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b16b1051cf159991, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BoundaryIntervalInfo {
  BoundaryIntervalInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2b4b681af085a38, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorBoundaryIntervalInfo {
  VectorBoundaryIntervalInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(86bf31a76542423e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorBirdViewBbox2D {
  VectorBirdViewBbox2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6827b9e76daf86f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SegmentInfo {
  SegmentInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dbfd68df6d30c625, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorSegmentInfo {
  VectorSegmentInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b4ee99fbf546579f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FreespaceInterior {
  FreespaceInterior() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ad79b883ea6fe6ec, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorFreespaceInterior {
  VectorFreespaceInterior() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(84a1ec043b4939d7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FreespaceExterior {
  FreespaceExterior() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eba48fde562dd70f, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorFreespaceExterior {
  VectorFreespaceExterior() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a83d7d64b5e597f3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GeneralFreeSpace {
  GeneralFreeSpace() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7bf8952830d1ab3, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MapCoordinate {
  MapCoordinate() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d926482e9991d284, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LocalLocalization {
  LocalLocalization() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99c31df42e5a25a4, 1, 11)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point3I {
  Point3I() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f986aff0b6eafdf9, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MatchingResult {
  MatchingResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(986412c27c2b5623, 6, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorMatchingResult {
  VectorMatchingResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b67570c2d32742dd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GlobalLocalization {
  GlobalLocalization() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b839adb616040995, 1, 9)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PredictPath {
  PredictPath() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(897c5dbd14e3a2fe, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPredictPath {
  VectorPredictPath() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7ff8427c7ca075d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GeneralObstacle {
  GeneralObstacle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd955b3a86dca895, 7, 12)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorGeneralObstacle {
  VectorGeneralObstacle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e75e37f4e0690efb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FusionObstacle {
  FusionObstacle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fbe5d2a7c81c7ff8, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VisionObstacleUint {
  VisionObstacleUint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b722dbc49adaecff, 6, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorVisionObstacleUint {
  VectorVisionObstacleUint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a426f57e544360d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VisionObstacle {
  VisionObstacle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a2d054a99b4aebbe, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorFloat {
  VectorFloat() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c04f5c4e72f45df, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalBBox2D {
  InternalBBox2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe4e120495aea4ff, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraBBox2DInfo {
  CameraBBox2DInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c92d37fffcaf83b3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ModelOutputFeature {
  ModelOutputFeature() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec06c166d5a92e27, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BaseCameraAttribute {
  BaseCameraAttribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d80c74d5ed3d49ed, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AutomobileLightStatus {
  AutomobileLightStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab306c60d2061170, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NonAutomobileVehicleLightStatus {
  NonAutomobileVehicleLightStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1b0eb1cf2f0ee90, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DepthDetPoint {
  DepthDetPoint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(96a72f7cfcb17ed0, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DerivedType {
  DerivedType() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  static constexpr  ::uint8_t CAMERA_NON_VEHICLE = 0u;
  static constexpr  ::uint8_t CAMERA_PEDESTRIAN = 1u;
  static constexpr  ::uint8_t CAMERA_VEHICLE = 2u;
  static constexpr  ::uint8_t CAMERA_STATIC_OBSTACLE = 3u;
  static constexpr  ::uint8_t LIDAR_OBJECT = 4u;
  static constexpr  ::uint8_t RADAR_OBJECT = 5u;
  static constexpr  ::uint8_t FUSION_OBJECT = 6u;
  static constexpr  ::uint8_t CAMERA_TRAFFICLIGHT = 7u;
  static constexpr  ::uint8_t CAMERA_TRAFFICSIGN = 8u;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de40368fe6504bf7, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BirdViewCorners {
  BirdViewCorners() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c976b407c3e37024, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorModelOutputFeature {
  VectorModelOutputFeature() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea60396ebe9b785f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalObject {
  InternalObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a422a48b10386a7, 9, 27)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalObject {
  VectorInternalObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f20357c7d3168a58, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorSensorSWCTimeStamp {
  VectorSensorSWCTimeStamp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac11e8cfff9c11a1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeStampGap {
  TimeStampGap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1754dda94a7df14, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorVEDAttribute {
  VectorVEDAttribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8df246cd12359921, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LightSpot {
  LightSpot() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab8252d7298bfed9, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VisionOdd {
  VisionOdd() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1b925021f0e89e5, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraTSLRObject {
  CameraTSLRObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3e172e79c6ebfb7, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorCameraTSLRObject {
  VectorCameraTSLRObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd3bda41896713dc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraTSLR {
  CameraTSLR() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b1158e1febd463fd, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneType {
  LaneType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b959a00e133f29e1, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLaneType {
  VectorLaneType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0a04e5c5488c929, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneColor {
  LaneColor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d3f2c5152a7bf54, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLaneColor {
  VectorLaneColor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8b40879863317af9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalLanePoint2f {
  InternalLanePoint2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9bb63846992b8e5, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLaneWidth {
  VectorLaneWidth() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c470a713e4338fe, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneBoundary {
  LaneBoundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc08ae27bcc6f6a2, 5, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLaneBoundary {
  VectorLaneBoundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f154426f0766cff6, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FusionLane {
  FusionLane() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd9d80f20e31fbaf, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorUInt64 {
  VectorUInt64() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc99e3261ef0abdc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Link {
  Link() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d652de3f7279ce04, 4, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Lane {
  Lane() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9566ac3e24d7570, 9, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLane {
  VectorLane() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f9a658d4fb799ba2, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Boundary {
  Boundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6cd1b111913eeee, 4, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorBoundary {
  VectorBoundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6fa8a00f282a492, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stopline {
  Stopline() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c87348b610c08122, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorStopline {
  VectorStopline() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb2a84968cb529d9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Marking {
  Marking() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(975cb0eeb65cbd03, 4, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorMarking {
  VectorMarking() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(daa4f79285dad4fd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Sign {
  Sign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a596d2843a13ec6b, 4, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorSign {
  VectorSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(946bcb7c51948e8e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Signal {
  Signal() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a50918c17e77ffb1, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorSignal {
  VectorSignal() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b267dcb67c42f66, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SafeIsland {
  SafeIsland() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b39b50f6ff4ec565, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorSafeIsland {
  VectorSafeIsland() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3464cb10084b3ba, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PedestrianCrossing {
  PedestrianCrossing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb83ffeef4c5043e, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorPedestrianCrossing {
  VectorPedestrianCrossing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d890c0b18dcb9080, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLink {
  VectorLink() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(865cd34d81e57b44, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SpeedLimitSign {
  SpeedLimitSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ad4ea4c0772854d4, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorSpeedLimitSign {
  VectorSpeedLimitSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98034e2ab2cee001, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FusionTrafficSign {
  FusionTrafficSign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c71ee749e07c0538, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorTrafficLightSignal {
  VectorTrafficLightSignal() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0c4504ab1197f97, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Light {
  Light() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(befd3cda71b28e98, 4, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorLight {
  VectorLight() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(904f90518d1ee799, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BumpLike {
  BumpLike() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9006218046ccab3d, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorBumpLike {
  VectorBumpLike() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4188cb6b3303e1e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalLanePoint2f {
  VectorInternalLanePoint2f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b7723c8dd2e108c8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalLaneLine {
  InternalLaneLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a906e74088544aec, 6, 7)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalLaneLine {
  VectorInternalLaneLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df561f1dd4991872, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalStopLine {
  InternalStopLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d7bf4a0891ff2f44, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalStopLine {
  VectorInternalStopLine() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2bbba14920c76e0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalBoundary {
  InternalBoundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cde564f55a13aed9, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalBoundary {
  VectorInternalBoundary() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b5fda197475cefea, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalTSR {
  InternalTSR() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aebcdf3d6f0ee176, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalTLR {
  InternalTLR() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd35f65543693122, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalTLR {
  VectorInternalTLR() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9b12bf8ad620680, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalRoadMarker {
  InternalRoadMarker() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c76dc735cfd1c9e2, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalRoadMarker {
  VectorInternalRoadMarker() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e660537107c4039b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalRegion {
  InternalRegion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe27c6f8592b8a30, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalRegion {
  VectorInternalRegion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b847b78c0cc120b8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalCrosswalk {
  InternalCrosswalk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa258407a632c06b, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalTSR {
  VectorInternalTSR() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6f4d0eed0e58251, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalTSLR {
  InternalTSLR() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee7c21c5db42cd45, 0, 7)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VEDCheck {
  VEDCheck() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(897553271f942715, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VectorInternalCrosswalk {
  VectorInternalCrosswalk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94c8dd8b673567d9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalRoadStructure {
  InternalRoadStructure() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cf1161f4069ac64a, 0, 11)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FusionMap {
  FusionMap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cc362861100221b, 0, 13)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InternalPerceptionObject {
  InternalPerceptionObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9da268c6acf785b4, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AppStatus {
  AppStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d0cbdf1429eb28fc, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraHeader {
  CameraHeader() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc5599959fbd1372, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraHeaderMbuf {
  CameraHeaderMbuf() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f029745b2ab4e55, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraEncodeMbuf {
  CameraEncodeMbuf() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb9a1616dc3c674a, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DiagReport {
  DiagReport() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ae7a118feaaa3c7a, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class TimeStamp::Reader {
public:
  typedef TimeStamp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsValid() const;

  inline  ::uint32_t getSec() const;

  inline  ::uint32_t getNsec() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeStamp::Builder {
public:
  typedef TimeStamp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsValid();
  inline void setIsValid(bool value);

  inline  ::uint32_t getSec();
  inline void setSec( ::uint32_t value);

  inline  ::uint32_t getNsec();
  inline void setNsec( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeStamp::Pipeline {
public:
  typedef TimeStamp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point3d::Reader {
public:
  typedef Point3d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point3d::Builder {
public:
  typedef Point3d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point3d::Pipeline {
public:
  typedef Point3d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VISLIGHTSPOT::Reader {
public:
  typedef VISLIGHTSPOT Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getLsSpotId() const;

  inline  ::uint8_t getLsSpotCalssification() const;

  inline float getLsSpotLongpos() const;

  inline float getLsSpotLeftangle() const;

  inline float getLsSpotRightangle() const;

  inline float getLsSpotTopangle() const;

  inline float getLsSpotBottomangle() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VISLIGHTSPOT::Builder {
public:
  typedef VISLIGHTSPOT Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getLsSpotId();
  inline void setLsSpotId( ::uint32_t value);

  inline  ::uint8_t getLsSpotCalssification();
  inline void setLsSpotCalssification( ::uint8_t value);

  inline float getLsSpotLongpos();
  inline void setLsSpotLongpos(float value);

  inline float getLsSpotLeftangle();
  inline void setLsSpotLeftangle(float value);

  inline float getLsSpotRightangle();
  inline void setLsSpotRightangle(float value);

  inline float getLsSpotTopangle();
  inline void setLsSpotTopangle(float value);

  inline float getLsSpotBottomangle();
  inline void setLsSpotBottomangle(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VISLIGHTSPOT::Pipeline {
public:
  typedef VISLIGHTSPOT Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorVISLIGHTSPOT::Reader {
public:
  typedef VectorVISLIGHTSPOT Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorVISLIGHTSPOT::Builder {
public:
  typedef VectorVISLIGHTSPOT Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorVISLIGHTSPOT::Pipeline {
public:
  typedef VectorVISLIGHTSPOT Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PilotProcessState::Reader {
public:
  typedef PilotProcessState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getProcessIndex() const;

  inline  ::uint8_t getStatus() const;

  inline  ::uint8_t getVendor() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PilotProcessState::Builder {
public:
  typedef PilotProcessState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getProcessIndex();
  inline void setProcessIndex( ::uint16_t value);

  inline  ::uint8_t getStatus();
  inline void setStatus( ::uint8_t value);

  inline  ::uint8_t getVendor();
  inline void setVendor( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PilotProcessState::Pipeline {
public:
  typedef PilotProcessState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PilotProcessStateVector::Reader {
public:
  typedef PilotProcessStateVector Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PilotProcessStateVector::Builder {
public:
  typedef PilotProcessStateVector Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PilotProcessStateVector::Pipeline {
public:
  typedef PilotProcessStateVector Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PilotProcessStates::Reader {
public:
  typedef PilotProcessStates Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPilotProcessStates() const;
  inline  ::gac::rscl::PilotProcessStateVector::Reader getPilotProcessStates() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PilotProcessStates::Builder {
public:
  typedef PilotProcessStates Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPilotProcessStates();
  inline  ::gac::rscl::PilotProcessStateVector::Builder getPilotProcessStates();
  inline void setPilotProcessStates( ::gac::rscl::PilotProcessStateVector::Reader value);
  inline  ::gac::rscl::PilotProcessStateVector::Builder initPilotProcessStates();
  inline void adoptPilotProcessStates(::capnp::Orphan< ::gac::rscl::PilotProcessStateVector>&& value);
  inline ::capnp::Orphan< ::gac::rscl::PilotProcessStateVector> disownPilotProcessStates();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PilotProcessStates::Pipeline {
public:
  typedef PilotProcessStates Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::PilotProcessStateVector::Pipeline getPilotProcessStates();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SensorSWCTimeStamp::Reader {
public:
  typedef SensorSWCTimeStamp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSensorTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getSensorTimestamp() const;

  inline bool hasSwcTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getSwcTimestamp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SensorSWCTimeStamp::Builder {
public:
  typedef SensorSWCTimeStamp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSensorTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getSensorTimestamp();
  inline void setSensorTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initSensorTimestamp();
  inline void adoptSensorTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownSensorTimestamp();

  inline bool hasSwcTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getSwcTimestamp();
  inline void setSwcTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initSwcTimestamp();
  inline void adoptSwcTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownSwcTimestamp();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SensorSWCTimeStamp::Pipeline {
public:
  typedef SensorSWCTimeStamp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getSensorTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getSwcTimestamp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CoordinateSystem::Reader {
public:
  typedef CoordinateSystem Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getIndex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CoordinateSystem::Builder {
public:
  typedef CoordinateSystem Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getIndex();
  inline void setIndex( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CoordinateSystem::Pipeline {
public:
  typedef CoordinateSystem Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SensorId::Reader {
public:
  typedef SensorId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getIndex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SensorId::Builder {
public:
  typedef SensorId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getIndex();
  inline void setIndex( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SensorId::Pipeline {
public:
  typedef SensorId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HistInfo::Reader {
public:
  typedef HistInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint32_t getObstacleId() const;

  inline bool hasRawSensorCaptureTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getRawSensorCaptureTimestamp() const;

  inline bool hasSensorPerceptionCaptureTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getSensorPerceptionCaptureTimestamp() const;

  inline bool hasSensorPerceptionOutputTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getSensorPerceptionOutputTimestamp() const;

  inline bool hasFusionCaptureTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getFusionCaptureTimestamp() const;

  inline bool hasFusionOutputTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getFusionOutputTimestamp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HistInfo::Builder {
public:
  typedef HistInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint32_t getObstacleId();
  inline void setObstacleId( ::uint32_t value);

  inline bool hasRawSensorCaptureTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getRawSensorCaptureTimestamp();
  inline void setRawSensorCaptureTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initRawSensorCaptureTimestamp();
  inline void adoptRawSensorCaptureTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownRawSensorCaptureTimestamp();

  inline bool hasSensorPerceptionCaptureTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getSensorPerceptionCaptureTimestamp();
  inline void setSensorPerceptionCaptureTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initSensorPerceptionCaptureTimestamp();
  inline void adoptSensorPerceptionCaptureTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownSensorPerceptionCaptureTimestamp();

  inline bool hasSensorPerceptionOutputTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getSensorPerceptionOutputTimestamp();
  inline void setSensorPerceptionOutputTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initSensorPerceptionOutputTimestamp();
  inline void adoptSensorPerceptionOutputTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownSensorPerceptionOutputTimestamp();

  inline bool hasFusionCaptureTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getFusionCaptureTimestamp();
  inline void setFusionCaptureTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initFusionCaptureTimestamp();
  inline void adoptFusionCaptureTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownFusionCaptureTimestamp();

  inline bool hasFusionOutputTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getFusionOutputTimestamp();
  inline void setFusionOutputTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initFusionOutputTimestamp();
  inline void adoptFusionOutputTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownFusionOutputTimestamp();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HistInfo::Pipeline {
public:
  typedef HistInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::TimeStamp::Pipeline getRawSensorCaptureTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getSensorPerceptionCaptureTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getSensorPerceptionOutputTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getFusionCaptureTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getFusionOutputTimestamp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorHistInfo::Reader {
public:
  typedef VectorHistInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorHistInfo::Builder {
public:
  typedef VectorHistInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorHistInfo::Pipeline {
public:
  typedef VectorHistInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ObstacleTypeInfo::Reader {
public:
  typedef ObstacleTypeInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getType() const;

  inline  ::uint16_t getSubType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ObstacleTypeInfo::Builder {
public:
  typedef ObstacleTypeInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getType();
  inline void setType( ::uint16_t value);

  inline  ::uint16_t getSubType();
  inline void setSubType( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ObstacleTypeInfo::Pipeline {
public:
  typedef ObstacleTypeInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RoadMarkerTypeInfo::Reader {
public:
  typedef RoadMarkerTypeInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RoadMarkerTypeInfo::Builder {
public:
  typedef RoadMarkerTypeInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RoadMarkerTypeInfo::Pipeline {
public:
  typedef RoadMarkerTypeInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrafficSignTypeInfo::Reader {
public:
  typedef TrafficSignTypeInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrafficSignTypeInfo::Builder {
public:
  typedef TrafficSignTypeInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrafficSignTypeInfo::Pipeline {
public:
  typedef TrafficSignTypeInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrafficLightSignal::Reader {
public:
  typedef TrafficLightSignal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getStatus() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrafficLightSignal::Builder {
public:
  typedef TrafficLightSignal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getStatus();
  inline void setStatus( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrafficLightSignal::Pipeline {
public:
  typedef TrafficLightSignal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point2f::Reader {
public:
  typedef Point2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point2f::Builder {
public:
  typedef Point2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point2f::Pipeline {
public:
  typedef Point2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneWidth::Reader {
public:
  typedef LaneWidth Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCutPoint() const;
  inline  ::gac::rscl::Point2f::Reader getCutPoint() const;

  inline  ::uint8_t getWidth() const;

  inline  ::uint8_t getWidthLeft() const;

  inline  ::uint8_t getWidthRight() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneWidth::Builder {
public:
  typedef LaneWidth Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCutPoint();
  inline  ::gac::rscl::Point2f::Builder getCutPoint();
  inline void setCutPoint( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initCutPoint();
  inline void adoptCutPoint(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownCutPoint();

  inline  ::uint8_t getWidth();
  inline void setWidth( ::uint8_t value);

  inline  ::uint8_t getWidthLeft();
  inline void setWidthLeft( ::uint8_t value);

  inline  ::uint8_t getWidthRight();
  inline void setWidthRight( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneWidth::Pipeline {
public:
  typedef LaneWidth Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point2f::Pipeline getCutPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPoint2f::Reader {
public:
  typedef VectorPoint2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPoint2f::Builder {
public:
  typedef VectorPoint2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPoint2f::Pipeline {
public:
  typedef VectorPoint2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point2d::Reader {
public:
  typedef Point2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point2d::Builder {
public:
  typedef Point2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point2d::Pipeline {
public:
  typedef Point2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point3f::Reader {
public:
  typedef Point3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point3f::Builder {
public:
  typedef Point3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point3f::Pipeline {
public:
  typedef Point3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPoint3f::Reader {
public:
  typedef VectorPoint3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPoint3f::Builder {
public:
  typedef VectorPoint3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPoint3f::Pipeline {
public:
  typedef VectorPoint3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VEDAttribute::Reader {
public:
  typedef VEDAttribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::SensorSWCTimeStamp::Reader getTimestamp() const;

  inline bool hasEgoCarLinearVelocity() const;
  inline  ::gac::rscl::Point3d::Reader getEgoCarLinearVelocity() const;

  inline bool hasEgoCarAngularVelocity() const;
  inline  ::gac::rscl::Point3d::Reader getEgoCarAngularVelocity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VEDAttribute::Builder {
public:
  typedef VEDAttribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::SensorSWCTimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::SensorSWCTimeStamp::Reader value);
  inline  ::gac::rscl::SensorSWCTimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::SensorSWCTimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorSWCTimeStamp> disownTimestamp();

  inline bool hasEgoCarLinearVelocity();
  inline  ::gac::rscl::Point3d::Builder getEgoCarLinearVelocity();
  inline void setEgoCarLinearVelocity( ::gac::rscl::Point3d::Reader value);
  inline  ::gac::rscl::Point3d::Builder initEgoCarLinearVelocity();
  inline void adoptEgoCarLinearVelocity(::capnp::Orphan< ::gac::rscl::Point3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3d> disownEgoCarLinearVelocity();

  inline bool hasEgoCarAngularVelocity();
  inline  ::gac::rscl::Point3d::Builder getEgoCarAngularVelocity();
  inline void setEgoCarAngularVelocity( ::gac::rscl::Point3d::Reader value);
  inline  ::gac::rscl::Point3d::Builder initEgoCarAngularVelocity();
  inline void adoptEgoCarAngularVelocity(::capnp::Orphan< ::gac::rscl::Point3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3d> disownEgoCarAngularVelocity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VEDAttribute::Pipeline {
public:
  typedef VEDAttribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::SensorSWCTimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::Point3d::Pipeline getEgoCarLinearVelocity();
  inline  ::gac::rscl::Point3d::Pipeline getEgoCarAngularVelocity();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPoint3d::Reader {
public:
  typedef VectorPoint3d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPoint3d::Builder {
public:
  typedef VectorPoint3d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPoint3d::Pipeline {
public:
  typedef VectorPoint3d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector2f::Reader {
public:
  typedef Vector2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector2f::Builder {
public:
  typedef Vector2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector2f::Pipeline {
public:
  typedef Vector2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector2d::Reader {
public:
  typedef Vector2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector2d::Builder {
public:
  typedef Vector2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector2d::Pipeline {
public:
  typedef Vector2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3f::Reader {
public:
  typedef Vector3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3f::Builder {
public:
  typedef Vector3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3f::Pipeline {
public:
  typedef Vector3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3d::Reader {
public:
  typedef Vector3d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3d::Builder {
public:
  typedef Vector3d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3d::Pipeline {
public:
  typedef Vector3d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Quaterniond::Reader {
public:
  typedef Quaterniond Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

  inline double getW() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Quaterniond::Builder {
public:
  typedef Quaterniond Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

  inline double getW();
  inline void setW(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Quaterniond::Pipeline {
public:
  typedef Quaterniond Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Quaternionf::Reader {
public:
  typedef Quaternionf Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getQx() const;

  inline float getQy() const;

  inline float getQz() const;

  inline float getQw() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Quaternionf::Builder {
public:
  typedef Quaternionf Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getQx();
  inline void setQx(float value);

  inline float getQy();
  inline void setQy(float value);

  inline float getQz();
  inline void setQz(float value);

  inline float getQw();
  inline void setQw(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Quaternionf::Pipeline {
public:
  typedef Quaternionf Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pose3f::Reader {
public:
  typedef Pose3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTranslation() const;
  inline  ::gac::rscl::Point3f::Reader getTranslation() const;

  inline bool hasRotation() const;
  inline  ::gac::rscl::Quaternionf::Reader getRotation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pose3f::Builder {
public:
  typedef Pose3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTranslation();
  inline  ::gac::rscl::Point3f::Builder getTranslation();
  inline void setTranslation( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initTranslation();
  inline void adoptTranslation(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownTranslation();

  inline bool hasRotation();
  inline  ::gac::rscl::Quaternionf::Builder getRotation();
  inline void setRotation( ::gac::rscl::Quaternionf::Reader value);
  inline  ::gac::rscl::Quaternionf::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::gac::rscl::Quaternionf>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Quaternionf> disownRotation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pose3f::Pipeline {
public:
  typedef Pose3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point3f::Pipeline getTranslation();
  inline  ::gac::rscl::Quaternionf::Pipeline getRotation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pose3d::Reader {
public:
  typedef Pose3d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTranslation() const;
  inline  ::gac::rscl::Point3d::Reader getTranslation() const;

  inline bool hasRotation() const;
  inline  ::gac::rscl::Quaterniond::Reader getRotation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pose3d::Builder {
public:
  typedef Pose3d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTranslation();
  inline  ::gac::rscl::Point3d::Builder getTranslation();
  inline void setTranslation( ::gac::rscl::Point3d::Reader value);
  inline  ::gac::rscl::Point3d::Builder initTranslation();
  inline void adoptTranslation(::capnp::Orphan< ::gac::rscl::Point3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3d> disownTranslation();

  inline bool hasRotation();
  inline  ::gac::rscl::Quaterniond::Builder getRotation();
  inline void setRotation( ::gac::rscl::Quaterniond::Reader value);
  inline  ::gac::rscl::Quaterniond::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::gac::rscl::Quaterniond>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Quaterniond> disownRotation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pose3d::Pipeline {
public:
  typedef Pose3d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point3d::Pipeline getTranslation();
  inline  ::gac::rscl::Quaterniond::Pipeline getRotation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Matrix3f::Reader {
public:
  typedef Matrix3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasX() const;
  inline  ::gac::rscl::Vector3f::Reader getX() const;

  inline bool hasY() const;
  inline  ::gac::rscl::Vector3f::Reader getY() const;

  inline bool hasZ() const;
  inline  ::gac::rscl::Vector3f::Reader getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Matrix3f::Builder {
public:
  typedef Matrix3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasX();
  inline  ::gac::rscl::Vector3f::Builder getX();
  inline void setX( ::gac::rscl::Vector3f::Reader value);
  inline  ::gac::rscl::Vector3f::Builder initX();
  inline void adoptX(::capnp::Orphan< ::gac::rscl::Vector3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3f> disownX();

  inline bool hasY();
  inline  ::gac::rscl::Vector3f::Builder getY();
  inline void setY( ::gac::rscl::Vector3f::Reader value);
  inline  ::gac::rscl::Vector3f::Builder initY();
  inline void adoptY(::capnp::Orphan< ::gac::rscl::Vector3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3f> disownY();

  inline bool hasZ();
  inline  ::gac::rscl::Vector3f::Builder getZ();
  inline void setZ( ::gac::rscl::Vector3f::Reader value);
  inline  ::gac::rscl::Vector3f::Builder initZ();
  inline void adoptZ(::capnp::Orphan< ::gac::rscl::Vector3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3f> disownZ();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Matrix3f::Pipeline {
public:
  typedef Matrix3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Vector3f::Pipeline getX();
  inline  ::gac::rscl::Vector3f::Pipeline getY();
  inline  ::gac::rscl::Vector3f::Pipeline getZ();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Matrix2f::Reader {
public:
  typedef Matrix2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasX() const;
  inline  ::gac::rscl::Vector2f::Reader getX() const;

  inline bool hasY() const;
  inline  ::gac::rscl::Vector2f::Reader getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Matrix2f::Builder {
public:
  typedef Matrix2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasX();
  inline  ::gac::rscl::Vector2f::Builder getX();
  inline void setX( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initX();
  inline void adoptX(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownX();

  inline bool hasY();
  inline  ::gac::rscl::Vector2f::Builder getY();
  inline void setY( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initY();
  inline void adoptY(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownY();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Matrix2f::Pipeline {
public:
  typedef Matrix2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Vector2f::Pipeline getX();
  inline  ::gac::rscl::Vector2f::Pipeline getY();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PathPoint::Reader {
public:
  typedef PathPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasPosition() const;
  inline  ::gac::rscl::Point2f::Reader getPosition() const;

  inline float getHeadingAngle() const;

  inline bool hasVelocity() const;
  inline  ::gac::rscl::Vector2f::Reader getVelocity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PathPoint::Builder {
public:
  typedef PathPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasPosition();
  inline  ::gac::rscl::Point2f::Builder getPosition();
  inline void setPosition( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownPosition();

  inline float getHeadingAngle();
  inline void setHeadingAngle(float value);

  inline bool hasVelocity();
  inline  ::gac::rscl::Vector2f::Builder getVelocity();
  inline void setVelocity( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownVelocity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PathPoint::Pipeline {
public:
  typedef PathPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::Point2f::Pipeline getPosition();
  inline  ::gac::rscl::Vector2f::Pipeline getVelocity();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPathPoint::Reader {
public:
  typedef VectorPathPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPathPoint::Builder {
public:
  typedef VectorPathPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPathPoint::Pipeline {
public:
  typedef VectorPathPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ImageKeyPoint::Reader {
public:
  typedef ImageKeyPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPoint() const;
  inline  ::gac::rscl::Point2d::Reader getPoint() const;

  inline float getXVar() const;

  inline float getYVar() const;

  inline bool getIsVisable() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ImageKeyPoint::Builder {
public:
  typedef ImageKeyPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPoint();
  inline  ::gac::rscl::Point2d::Builder getPoint();
  inline void setPoint( ::gac::rscl::Point2d::Reader value);
  inline  ::gac::rscl::Point2d::Builder initPoint();
  inline void adoptPoint(::capnp::Orphan< ::gac::rscl::Point2d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2d> disownPoint();

  inline float getXVar();
  inline void setXVar(float value);

  inline float getYVar();
  inline void setYVar(float value);

  inline bool getIsVisable();
  inline void setIsVisable(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ImageKeyPoint::Pipeline {
public:
  typedef ImageKeyPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point2d::Pipeline getPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorImageKeyPoint::Reader {
public:
  typedef VectorImageKeyPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorImageKeyPoint::Builder {
public:
  typedef VectorImageKeyPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorImageKeyPoint::Pipeline {
public:
  typedef VectorImageKeyPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ImageBbox2D::Reader {
public:
  typedef ImageBbox2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getTopLeftX() const;

  inline float getTopLeftY() const;

  inline float getBottomRightX() const;

  inline float getBottomRightY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ImageBbox2D::Builder {
public:
  typedef ImageBbox2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getTopLeftX();
  inline void setTopLeftX(float value);

  inline float getTopLeftY();
  inline void setTopLeftY(float value);

  inline float getBottomRightX();
  inline void setBottomRightX(float value);

  inline float getBottomRightY();
  inline void setBottomRightY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ImageBbox2D::Pipeline {
public:
  typedef ImageBbox2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BirdViewBbox2D::Reader {
public:
  typedef BirdViewBbox2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCenterPosition() const;
  inline  ::gac::rscl::Point2f::Reader getCenterPosition() const;

  inline float getHeading() const;

  inline float getLength() const;

  inline float getWidth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BirdViewBbox2D::Builder {
public:
  typedef BirdViewBbox2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCenterPosition();
  inline  ::gac::rscl::Point2f::Builder getCenterPosition();
  inline void setCenterPosition( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initCenterPosition();
  inline void adoptCenterPosition(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownCenterPosition();

  inline float getHeading();
  inline void setHeading(float value);

  inline float getLength();
  inline void setLength(float value);

  inline float getWidth();
  inline void setWidth(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BirdViewBbox2D::Pipeline {
public:
  typedef BirdViewBbox2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point2f::Pipeline getCenterPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Bbox3D::Reader {
public:
  typedef Bbox3D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPose() const;
  inline  ::gac::rscl::Pose3f::Reader getPose() const;

  inline float getWidth() const;

  inline float getHeight() const;

  inline float getLength() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Bbox3D::Builder {
public:
  typedef Bbox3D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPose();
  inline  ::gac::rscl::Pose3f::Builder getPose();
  inline void setPose( ::gac::rscl::Pose3f::Reader value);
  inline  ::gac::rscl::Pose3f::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::gac::rscl::Pose3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Pose3f> disownPose();

  inline float getWidth();
  inline void setWidth(float value);

  inline float getHeight();
  inline void setHeight(float value);

  inline float getLength();
  inline void setLength(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Bbox3D::Pipeline {
public:
  typedef Bbox3D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Pose3f::Pipeline getPose();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IntervalInfo::Reader {
public:
  typedef IntervalInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getDataId() const;

  inline double getDataValue() const;

  inline  ::uint8_t getDataType() const;

  inline  ::uint8_t getOffsetStyle() const;

  inline double getStartOffset() const;

  inline double getEndOffset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IntervalInfo::Builder {
public:
  typedef IntervalInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getDataId();
  inline void setDataId( ::uint64_t value);

  inline double getDataValue();
  inline void setDataValue(double value);

  inline  ::uint8_t getDataType();
  inline void setDataType( ::uint8_t value);

  inline  ::uint8_t getOffsetStyle();
  inline void setOffsetStyle( ::uint8_t value);

  inline double getStartOffset();
  inline void setStartOffset(double value);

  inline double getEndOffset();
  inline void setEndOffset(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IntervalInfo::Pipeline {
public:
  typedef IntervalInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorIntervalInfo::Reader {
public:
  typedef VectorIntervalInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorIntervalInfo::Builder {
public:
  typedef VectorIntervalInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorIntervalInfo::Pipeline {
public:
  typedef VectorIntervalInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point3dAttribute::Reader {
public:
  typedef Point3dAttribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPoint() const;
  inline  ::gac::rscl::Point3d::Reader getPoint() const;

  inline double getHeading() const;

  inline double getLateralSlope() const;

  inline double getLongitudinalSlope() const;

  inline double getCurvatureRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point3dAttribute::Builder {
public:
  typedef Point3dAttribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPoint();
  inline  ::gac::rscl::Point3d::Builder getPoint();
  inline void setPoint( ::gac::rscl::Point3d::Reader value);
  inline  ::gac::rscl::Point3d::Builder initPoint();
  inline void adoptPoint(::capnp::Orphan< ::gac::rscl::Point3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3d> disownPoint();

  inline double getHeading();
  inline void setHeading(double value);

  inline double getLateralSlope();
  inline void setLateralSlope(double value);

  inline double getLongitudinalSlope();
  inline void setLongitudinalSlope(double value);

  inline double getCurvatureRadius();
  inline void setCurvatureRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point3dAttribute::Pipeline {
public:
  typedef Point3dAttribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point3d::Pipeline getPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPoint3dAttribute::Reader {
public:
  typedef VectorPoint3dAttribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPoint3dAttribute::Builder {
public:
  typedef VectorPoint3dAttribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPoint3dAttribute::Pipeline {
public:
  typedef VectorPoint3dAttribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BoundaryIntervalInfo::Reader {
public:
  typedef BoundaryIntervalInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getStyle() const;

  inline  ::uint8_t getColor() const;

  inline  ::uint16_t getWidth() const;

  inline  ::uint32_t getLength() const;

  inline  ::uint8_t getConfidence() const;

  inline  ::uint8_t getOffsetStyle() const;

  inline double getStartOffset() const;

  inline double getEndOffset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BoundaryIntervalInfo::Builder {
public:
  typedef BoundaryIntervalInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getStyle();
  inline void setStyle( ::uint8_t value);

  inline  ::uint8_t getColor();
  inline void setColor( ::uint8_t value);

  inline  ::uint16_t getWidth();
  inline void setWidth( ::uint16_t value);

  inline  ::uint32_t getLength();
  inline void setLength( ::uint32_t value);

  inline  ::uint8_t getConfidence();
  inline void setConfidence( ::uint8_t value);

  inline  ::uint8_t getOffsetStyle();
  inline void setOffsetStyle( ::uint8_t value);

  inline double getStartOffset();
  inline void setStartOffset(double value);

  inline double getEndOffset();
  inline void setEndOffset(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BoundaryIntervalInfo::Pipeline {
public:
  typedef BoundaryIntervalInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorBoundaryIntervalInfo::Reader {
public:
  typedef VectorBoundaryIntervalInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorBoundaryIntervalInfo::Builder {
public:
  typedef VectorBoundaryIntervalInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorBoundaryIntervalInfo::Pipeline {
public:
  typedef VectorBoundaryIntervalInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorBirdViewBbox2D::Reader {
public:
  typedef VectorBirdViewBbox2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorBirdViewBbox2D::Builder {
public:
  typedef VectorBirdViewBbox2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorBirdViewBbox2D::Pipeline {
public:
  typedef VectorBirdViewBbox2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SegmentInfo::Reader {
public:
  typedef SegmentInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getStartPointIndex() const;

  inline  ::uint32_t getEndPointIndex() const;

  inline  ::uint32_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SegmentInfo::Builder {
public:
  typedef SegmentInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getStartPointIndex();
  inline void setStartPointIndex( ::uint32_t value);

  inline  ::uint32_t getEndPointIndex();
  inline void setEndPointIndex( ::uint32_t value);

  inline  ::uint32_t getType();
  inline void setType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SegmentInfo::Pipeline {
public:
  typedef SegmentInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorSegmentInfo::Reader {
public:
  typedef VectorSegmentInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorSegmentInfo::Builder {
public:
  typedef VectorSegmentInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorSegmentInfo::Pipeline {
public:
  typedef VectorSegmentInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FreespaceInterior::Reader {
public:
  typedef FreespaceInterior Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInteriorPolygon() const;
  inline  ::gac::rscl::VectorPoint3d::Reader getInteriorPolygon() const;

  inline bool hasSegments() const;
  inline  ::gac::rscl::VectorSegmentInfo::Reader getSegments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FreespaceInterior::Builder {
public:
  typedef FreespaceInterior Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInteriorPolygon();
  inline  ::gac::rscl::VectorPoint3d::Builder getInteriorPolygon();
  inline void setInteriorPolygon( ::gac::rscl::VectorPoint3d::Reader value);
  inline  ::gac::rscl::VectorPoint3d::Builder initInteriorPolygon();
  inline void adoptInteriorPolygon(::capnp::Orphan< ::gac::rscl::VectorPoint3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint3d> disownInteriorPolygon();

  inline bool hasSegments();
  inline  ::gac::rscl::VectorSegmentInfo::Builder getSegments();
  inline void setSegments( ::gac::rscl::VectorSegmentInfo::Reader value);
  inline  ::gac::rscl::VectorSegmentInfo::Builder initSegments();
  inline void adoptSegments(::capnp::Orphan< ::gac::rscl::VectorSegmentInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSegmentInfo> disownSegments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FreespaceInterior::Pipeline {
public:
  typedef FreespaceInterior Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint3d::Pipeline getInteriorPolygon();
  inline  ::gac::rscl::VectorSegmentInfo::Pipeline getSegments();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorFreespaceInterior::Reader {
public:
  typedef VectorFreespaceInterior Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorFreespaceInterior::Builder {
public:
  typedef VectorFreespaceInterior Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorFreespaceInterior::Pipeline {
public:
  typedef VectorFreespaceInterior Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FreespaceExterior::Reader {
public:
  typedef FreespaceExterior Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasExteriorPolygon() const;
  inline  ::gac::rscl::VectorPoint3f::Reader getExteriorPolygon() const;

  inline bool hasSegments() const;
  inline  ::gac::rscl::VectorSegmentInfo::Reader getSegments() const;

  inline bool hasInteriorVector() const;
  inline  ::gac::rscl::VectorFreespaceInterior::Reader getInteriorVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FreespaceExterior::Builder {
public:
  typedef FreespaceExterior Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasExteriorPolygon();
  inline  ::gac::rscl::VectorPoint3f::Builder getExteriorPolygon();
  inline void setExteriorPolygon( ::gac::rscl::VectorPoint3f::Reader value);
  inline  ::gac::rscl::VectorPoint3f::Builder initExteriorPolygon();
  inline void adoptExteriorPolygon(::capnp::Orphan< ::gac::rscl::VectorPoint3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint3f> disownExteriorPolygon();

  inline bool hasSegments();
  inline  ::gac::rscl::VectorSegmentInfo::Builder getSegments();
  inline void setSegments( ::gac::rscl::VectorSegmentInfo::Reader value);
  inline  ::gac::rscl::VectorSegmentInfo::Builder initSegments();
  inline void adoptSegments(::capnp::Orphan< ::gac::rscl::VectorSegmentInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSegmentInfo> disownSegments();

  inline bool hasInteriorVector();
  inline  ::gac::rscl::VectorFreespaceInterior::Builder getInteriorVector();
  inline void setInteriorVector( ::gac::rscl::VectorFreespaceInterior::Reader value);
  inline  ::gac::rscl::VectorFreespaceInterior::Builder initInteriorVector();
  inline void adoptInteriorVector(::capnp::Orphan< ::gac::rscl::VectorFreespaceInterior>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorFreespaceInterior> disownInteriorVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FreespaceExterior::Pipeline {
public:
  typedef FreespaceExterior Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint3f::Pipeline getExteriorPolygon();
  inline  ::gac::rscl::VectorSegmentInfo::Pipeline getSegments();
  inline  ::gac::rscl::VectorFreespaceInterior::Pipeline getInteriorVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorFreespaceExterior::Reader {
public:
  typedef VectorFreespaceExterior Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorFreespaceExterior::Builder {
public:
  typedef VectorFreespaceExterior Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorFreespaceExterior::Pipeline {
public:
  typedef VectorFreespaceExterior Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GeneralFreeSpace::Reader {
public:
  typedef GeneralFreeSpace Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline bool hasFreespaceVector() const;
  inline  ::gac::rscl::VectorFreespaceExterior::Reader getFreespaceVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeneralFreeSpace::Builder {
public:
  typedef GeneralFreeSpace Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline bool hasFreespaceVector();
  inline  ::gac::rscl::VectorFreespaceExterior::Builder getFreespaceVector();
  inline void setFreespaceVector( ::gac::rscl::VectorFreespaceExterior::Reader value);
  inline  ::gac::rscl::VectorFreespaceExterior::Builder initFreespaceVector();
  inline void adoptFreespaceVector(::capnp::Orphan< ::gac::rscl::VectorFreespaceExterior>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorFreespaceExterior> disownFreespaceVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeneralFreeSpace::Pipeline {
public:
  typedef GeneralFreeSpace Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorFreespaceExterior::Pipeline getFreespaceVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapCoordinate::Reader {
public:
  typedef MapCoordinate Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getZoneId() const;

  inline  ::uint8_t getSouthFlag() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapCoordinate::Builder {
public:
  typedef MapCoordinate Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getZoneId();
  inline void setZoneId( ::uint8_t value);

  inline  ::uint8_t getSouthFlag();
  inline void setSouthFlag( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapCoordinate::Pipeline {
public:
  typedef MapCoordinate Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LocalLocalization::Reader {
public:
  typedef LocalLocalization Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasOutputTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getOutputTimestamp() const;

  inline bool hasParent() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getParent() const;

  inline bool hasChild() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getChild() const;

  inline  ::uint32_t getAccuracyLevel() const;

  inline bool hasLocalPose() const;
  inline  ::gac::rscl::Pose3d::Reader getLocalPose() const;

  inline bool hasEgoCarAngularVelocity() const;
  inline  ::gac::rscl::Vector3d::Reader getEgoCarAngularVelocity() const;

  inline bool hasEgoCarLinearVelocity() const;
  inline  ::gac::rscl::Vector3d::Reader getEgoCarLinearVelocity() const;

  inline bool hasEgoCarLinearAcceleration() const;
  inline  ::gac::rscl::Vector3d::Reader getEgoCarLinearAcceleration() const;

  inline bool hasEgoCarToGroundRotation() const;
  inline  ::gac::rscl::Quaterniond::Reader getEgoCarToGroundRotation() const;

  inline bool hasLocalTranslationCovariance() const;
  inline  ::gac::rscl::Vector3d::Reader getLocalTranslationCovariance() const;

  inline bool hasLocalRotationCovariance() const;
  inline  ::gac::rscl::Vector3d::Reader getLocalRotationCovariance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LocalLocalization::Builder {
public:
  typedef LocalLocalization Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasOutputTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getOutputTimestamp();
  inline void setOutputTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initOutputTimestamp();
  inline void adoptOutputTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownOutputTimestamp();

  inline bool hasParent();
  inline  ::gac::rscl::CoordinateSystem::Builder getParent();
  inline void setParent( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initParent();
  inline void adoptParent(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownParent();

  inline bool hasChild();
  inline  ::gac::rscl::CoordinateSystem::Builder getChild();
  inline void setChild( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initChild();
  inline void adoptChild(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownChild();

  inline  ::uint32_t getAccuracyLevel();
  inline void setAccuracyLevel( ::uint32_t value);

  inline bool hasLocalPose();
  inline  ::gac::rscl::Pose3d::Builder getLocalPose();
  inline void setLocalPose( ::gac::rscl::Pose3d::Reader value);
  inline  ::gac::rscl::Pose3d::Builder initLocalPose();
  inline void adoptLocalPose(::capnp::Orphan< ::gac::rscl::Pose3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Pose3d> disownLocalPose();

  inline bool hasEgoCarAngularVelocity();
  inline  ::gac::rscl::Vector3d::Builder getEgoCarAngularVelocity();
  inline void setEgoCarAngularVelocity( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initEgoCarAngularVelocity();
  inline void adoptEgoCarAngularVelocity(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownEgoCarAngularVelocity();

  inline bool hasEgoCarLinearVelocity();
  inline  ::gac::rscl::Vector3d::Builder getEgoCarLinearVelocity();
  inline void setEgoCarLinearVelocity( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initEgoCarLinearVelocity();
  inline void adoptEgoCarLinearVelocity(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownEgoCarLinearVelocity();

  inline bool hasEgoCarLinearAcceleration();
  inline  ::gac::rscl::Vector3d::Builder getEgoCarLinearAcceleration();
  inline void setEgoCarLinearAcceleration( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initEgoCarLinearAcceleration();
  inline void adoptEgoCarLinearAcceleration(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownEgoCarLinearAcceleration();

  inline bool hasEgoCarToGroundRotation();
  inline  ::gac::rscl::Quaterniond::Builder getEgoCarToGroundRotation();
  inline void setEgoCarToGroundRotation( ::gac::rscl::Quaterniond::Reader value);
  inline  ::gac::rscl::Quaterniond::Builder initEgoCarToGroundRotation();
  inline void adoptEgoCarToGroundRotation(::capnp::Orphan< ::gac::rscl::Quaterniond>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Quaterniond> disownEgoCarToGroundRotation();

  inline bool hasLocalTranslationCovariance();
  inline  ::gac::rscl::Vector3d::Builder getLocalTranslationCovariance();
  inline void setLocalTranslationCovariance( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initLocalTranslationCovariance();
  inline void adoptLocalTranslationCovariance(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownLocalTranslationCovariance();

  inline bool hasLocalRotationCovariance();
  inline  ::gac::rscl::Vector3d::Builder getLocalRotationCovariance();
  inline void setLocalRotationCovariance( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initLocalRotationCovariance();
  inline void adoptLocalRotationCovariance(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownLocalRotationCovariance();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LocalLocalization::Pipeline {
public:
  typedef LocalLocalization Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getOutputTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getParent();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getChild();
  inline  ::gac::rscl::Pose3d::Pipeline getLocalPose();
  inline  ::gac::rscl::Vector3d::Pipeline getEgoCarAngularVelocity();
  inline  ::gac::rscl::Vector3d::Pipeline getEgoCarLinearVelocity();
  inline  ::gac::rscl::Vector3d::Pipeline getEgoCarLinearAcceleration();
  inline  ::gac::rscl::Quaterniond::Pipeline getEgoCarToGroundRotation();
  inline  ::gac::rscl::Vector3d::Pipeline getLocalTranslationCovariance();
  inline  ::gac::rscl::Vector3d::Pipeline getLocalRotationCovariance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point3I::Reader {
public:
  typedef Point3I Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

  inline  ::int32_t getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point3I::Builder {
public:
  typedef Point3I Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

  inline  ::int32_t getZ();
  inline void setZ( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point3I::Pipeline {
public:
  typedef Point3I Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MatchingResult::Reader {
public:
  typedef MatchingResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLinkId() const;

  inline  ::uint64_t getLaneId() const;

  inline  ::int32_t getLongitudinalOffStart() const;

  inline  ::int32_t getLongitudinalOffEnd() const;

  inline float getAccuracy() const;

  inline  ::int32_t getRelativeHeading() const;

  inline  ::int32_t getLateralOffLeft() const;

  inline  ::int32_t getLateralOffRight() const;

  inline  ::int32_t getLateralOffMiddle() const;

  inline  ::uint8_t getProbobility() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MatchingResult::Builder {
public:
  typedef MatchingResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLinkId();
  inline void setLinkId( ::uint64_t value);

  inline  ::uint64_t getLaneId();
  inline void setLaneId( ::uint64_t value);

  inline  ::int32_t getLongitudinalOffStart();
  inline void setLongitudinalOffStart( ::int32_t value);

  inline  ::int32_t getLongitudinalOffEnd();
  inline void setLongitudinalOffEnd( ::int32_t value);

  inline float getAccuracy();
  inline void setAccuracy(float value);

  inline  ::int32_t getRelativeHeading();
  inline void setRelativeHeading( ::int32_t value);

  inline  ::int32_t getLateralOffLeft();
  inline void setLateralOffLeft( ::int32_t value);

  inline  ::int32_t getLateralOffRight();
  inline void setLateralOffRight( ::int32_t value);

  inline  ::int32_t getLateralOffMiddle();
  inline void setLateralOffMiddle( ::int32_t value);

  inline  ::uint8_t getProbobility();
  inline void setProbobility( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MatchingResult::Pipeline {
public:
  typedef MatchingResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorMatchingResult::Reader {
public:
  typedef VectorMatchingResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorMatchingResult::Builder {
public:
  typedef VectorMatchingResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorMatchingResult::Pipeline {
public:
  typedef VectorMatchingResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GlobalLocalization::Reader {
public:
  typedef GlobalLocalization Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasOutputTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getOutputTimestamp() const;

  inline bool hasParent() const;
  inline  ::gac::rscl::MapCoordinate::Reader getParent() const;

  inline bool hasChild() const;
  inline  ::gac::rscl::MapCoordinate::Reader getChild() const;

  inline bool hasPosition() const;
  inline  ::gac::rscl::Point3I::Reader getPosition() const;

  inline bool hasRotation() const;
  inline  ::gac::rscl::Quaterniond::Reader getRotation() const;

  inline bool hasLocCovariance() const;
  inline  ::gac::rscl::Vector3d::Reader getLocCovariance() const;

  inline bool hasPoseCovariance() const;
  inline  ::gac::rscl::Vector3d::Reader getPoseCovariance() const;

  inline  ::uint8_t getStatus() const;

  inline  ::int16_t getVehicleSpeed() const;

  inline  ::int32_t getHeading() const;

  inline bool getActived() const;

  inline bool hasMatchingResults() const;
  inline  ::gac::rscl::VectorMatchingResult::Reader getMatchingResults() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GlobalLocalization::Builder {
public:
  typedef GlobalLocalization Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasOutputTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getOutputTimestamp();
  inline void setOutputTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initOutputTimestamp();
  inline void adoptOutputTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownOutputTimestamp();

  inline bool hasParent();
  inline  ::gac::rscl::MapCoordinate::Builder getParent();
  inline void setParent( ::gac::rscl::MapCoordinate::Reader value);
  inline  ::gac::rscl::MapCoordinate::Builder initParent();
  inline void adoptParent(::capnp::Orphan< ::gac::rscl::MapCoordinate>&& value);
  inline ::capnp::Orphan< ::gac::rscl::MapCoordinate> disownParent();

  inline bool hasChild();
  inline  ::gac::rscl::MapCoordinate::Builder getChild();
  inline void setChild( ::gac::rscl::MapCoordinate::Reader value);
  inline  ::gac::rscl::MapCoordinate::Builder initChild();
  inline void adoptChild(::capnp::Orphan< ::gac::rscl::MapCoordinate>&& value);
  inline ::capnp::Orphan< ::gac::rscl::MapCoordinate> disownChild();

  inline bool hasPosition();
  inline  ::gac::rscl::Point3I::Builder getPosition();
  inline void setPosition( ::gac::rscl::Point3I::Reader value);
  inline  ::gac::rscl::Point3I::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::gac::rscl::Point3I>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3I> disownPosition();

  inline bool hasRotation();
  inline  ::gac::rscl::Quaterniond::Builder getRotation();
  inline void setRotation( ::gac::rscl::Quaterniond::Reader value);
  inline  ::gac::rscl::Quaterniond::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::gac::rscl::Quaterniond>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Quaterniond> disownRotation();

  inline bool hasLocCovariance();
  inline  ::gac::rscl::Vector3d::Builder getLocCovariance();
  inline void setLocCovariance( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initLocCovariance();
  inline void adoptLocCovariance(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownLocCovariance();

  inline bool hasPoseCovariance();
  inline  ::gac::rscl::Vector3d::Builder getPoseCovariance();
  inline void setPoseCovariance( ::gac::rscl::Vector3d::Reader value);
  inline  ::gac::rscl::Vector3d::Builder initPoseCovariance();
  inline void adoptPoseCovariance(::capnp::Orphan< ::gac::rscl::Vector3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3d> disownPoseCovariance();

  inline  ::uint8_t getStatus();
  inline void setStatus( ::uint8_t value);

  inline  ::int16_t getVehicleSpeed();
  inline void setVehicleSpeed( ::int16_t value);

  inline  ::int32_t getHeading();
  inline void setHeading( ::int32_t value);

  inline bool getActived();
  inline void setActived(bool value);

  inline bool hasMatchingResults();
  inline  ::gac::rscl::VectorMatchingResult::Builder getMatchingResults();
  inline void setMatchingResults( ::gac::rscl::VectorMatchingResult::Reader value);
  inline  ::gac::rscl::VectorMatchingResult::Builder initMatchingResults();
  inline void adoptMatchingResults(::capnp::Orphan< ::gac::rscl::VectorMatchingResult>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorMatchingResult> disownMatchingResults();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GlobalLocalization::Pipeline {
public:
  typedef GlobalLocalization Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::TimeStamp::Pipeline getOutputTimestamp();
  inline  ::gac::rscl::MapCoordinate::Pipeline getParent();
  inline  ::gac::rscl::MapCoordinate::Pipeline getChild();
  inline  ::gac::rscl::Point3I::Pipeline getPosition();
  inline  ::gac::rscl::Quaterniond::Pipeline getRotation();
  inline  ::gac::rscl::Vector3d::Pipeline getLocCovariance();
  inline  ::gac::rscl::Vector3d::Pipeline getPoseCovariance();
  inline  ::gac::rscl::VectorMatchingResult::Pipeline getMatchingResults();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PredictPath::Reader {
public:
  typedef PredictPath Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getConfidence() const;

  inline bool hasPathPointVector() const;
  inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader getPathPointVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PredictPath::Builder {
public:
  typedef PredictPath Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool hasPathPointVector();
  inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder getPathPointVector();
  inline void setPathPointVector( ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder initPathPointVector(unsigned int size);
  inline void adoptPathPointVector(::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>> disownPathPointVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PredictPath::Pipeline {
public:
  typedef PredictPath Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPredictPath::Reader {
public:
  typedef VectorPredictPath Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPredictPath::Builder {
public:
  typedef VectorPredictPath Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPredictPath::Pipeline {
public:
  typedef VectorPredictPath Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GeneralObstacle::Reader {
public:
  typedef GeneralObstacle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader getHistInfoVector() const;

  inline  ::uint32_t getObstacleId() const;

  inline bool hasObstacleTypeInfo() const;
  inline  ::gac::rscl::ObstacleTypeInfo::Reader getObstacleTypeInfo() const;

  inline float getConfidence() const;

  inline float getExistenceConfidence() const;

  inline float getClassConfidence() const;

  inline bool hasCenterPosition() const;
  inline  ::gac::rscl::Point2f::Reader getCenterPosition() const;

  inline bool hasAbsoluteVelocity() const;
  inline  ::gac::rscl::Vector2f::Reader getAbsoluteVelocity() const;

  inline bool hasRelativeVelocity() const;
  inline  ::gac::rscl::Vector2f::Reader getRelativeVelocity() const;

  inline bool hasAbsoluteAccelaration() const;
  inline  ::gac::rscl::Vector2f::Reader getAbsoluteAccelaration() const;

  inline float getHeadingAngle() const;

  inline float getHeadingAngularVelocity() const;

  inline  ::uint8_t getMovingStatus() const;

  inline float getBbox3dWidth() const;

  inline float getBbox3dHeight() const;

  inline float getBbox3dLength() const;

  inline bool hasCenterPositionCov() const;
  inline  ::gac::rscl::Matrix2f::Reader getCenterPositionCov() const;

  inline bool hasVelocityCov() const;
  inline  ::gac::rscl::Matrix2f::Reader getVelocityCov() const;

  inline bool hasAccelarationCov() const;
  inline  ::gac::rscl::Matrix2f::Reader getAccelarationCov() const;

  inline bool hasSizeCov() const;
  inline  ::gac::rscl::Matrix3f::Reader getSizeCov() const;

  inline float getHeadingAngleStd() const;

  inline float getTrackingPeriod() const;

  inline bool getIsMovable() const;

  inline bool getIsHeadingToEgoCar() const;

  inline bool getIsEverHeadingToEgoCar() const;

  inline  ::uint8_t getLampStatus() const;

  inline  ::uint8_t getTrackingStatus() const;

  inline  ::uint8_t getCutInStatus() const;

  inline  ::uint8_t getCutOutStatus() const;

  inline bool hasPredictPathVector() const;
  inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader getPredictPathVector() const;

  inline bool hasPolygon() const;
  inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader getPolygon() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeneralObstacle::Builder {
public:
  typedef GeneralObstacle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder getHistInfoVector();
  inline void setHistInfoVector( ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder initHistInfoVector(unsigned int size);
  inline void adoptHistInfoVector(::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>> disownHistInfoVector();

  inline  ::uint32_t getObstacleId();
  inline void setObstacleId( ::uint32_t value);

  inline bool hasObstacleTypeInfo();
  inline  ::gac::rscl::ObstacleTypeInfo::Builder getObstacleTypeInfo();
  inline void setObstacleTypeInfo( ::gac::rscl::ObstacleTypeInfo::Reader value);
  inline  ::gac::rscl::ObstacleTypeInfo::Builder initObstacleTypeInfo();
  inline void adoptObstacleTypeInfo(::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo> disownObstacleTypeInfo();

  inline float getConfidence();
  inline void setConfidence(float value);

  inline float getExistenceConfidence();
  inline void setExistenceConfidence(float value);

  inline float getClassConfidence();
  inline void setClassConfidence(float value);

  inline bool hasCenterPosition();
  inline  ::gac::rscl::Point2f::Builder getCenterPosition();
  inline void setCenterPosition( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initCenterPosition();
  inline void adoptCenterPosition(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownCenterPosition();

  inline bool hasAbsoluteVelocity();
  inline  ::gac::rscl::Vector2f::Builder getAbsoluteVelocity();
  inline void setAbsoluteVelocity( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initAbsoluteVelocity();
  inline void adoptAbsoluteVelocity(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownAbsoluteVelocity();

  inline bool hasRelativeVelocity();
  inline  ::gac::rscl::Vector2f::Builder getRelativeVelocity();
  inline void setRelativeVelocity( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initRelativeVelocity();
  inline void adoptRelativeVelocity(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownRelativeVelocity();

  inline bool hasAbsoluteAccelaration();
  inline  ::gac::rscl::Vector2f::Builder getAbsoluteAccelaration();
  inline void setAbsoluteAccelaration( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initAbsoluteAccelaration();
  inline void adoptAbsoluteAccelaration(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownAbsoluteAccelaration();

  inline float getHeadingAngle();
  inline void setHeadingAngle(float value);

  inline float getHeadingAngularVelocity();
  inline void setHeadingAngularVelocity(float value);

  inline  ::uint8_t getMovingStatus();
  inline void setMovingStatus( ::uint8_t value);

  inline float getBbox3dWidth();
  inline void setBbox3dWidth(float value);

  inline float getBbox3dHeight();
  inline void setBbox3dHeight(float value);

  inline float getBbox3dLength();
  inline void setBbox3dLength(float value);

  inline bool hasCenterPositionCov();
  inline  ::gac::rscl::Matrix2f::Builder getCenterPositionCov();
  inline void setCenterPositionCov( ::gac::rscl::Matrix2f::Reader value);
  inline  ::gac::rscl::Matrix2f::Builder initCenterPositionCov();
  inline void adoptCenterPositionCov(::capnp::Orphan< ::gac::rscl::Matrix2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix2f> disownCenterPositionCov();

  inline bool hasVelocityCov();
  inline  ::gac::rscl::Matrix2f::Builder getVelocityCov();
  inline void setVelocityCov( ::gac::rscl::Matrix2f::Reader value);
  inline  ::gac::rscl::Matrix2f::Builder initVelocityCov();
  inline void adoptVelocityCov(::capnp::Orphan< ::gac::rscl::Matrix2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix2f> disownVelocityCov();

  inline bool hasAccelarationCov();
  inline  ::gac::rscl::Matrix2f::Builder getAccelarationCov();
  inline void setAccelarationCov( ::gac::rscl::Matrix2f::Reader value);
  inline  ::gac::rscl::Matrix2f::Builder initAccelarationCov();
  inline void adoptAccelarationCov(::capnp::Orphan< ::gac::rscl::Matrix2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix2f> disownAccelarationCov();

  inline bool hasSizeCov();
  inline  ::gac::rscl::Matrix3f::Builder getSizeCov();
  inline void setSizeCov( ::gac::rscl::Matrix3f::Reader value);
  inline  ::gac::rscl::Matrix3f::Builder initSizeCov();
  inline void adoptSizeCov(::capnp::Orphan< ::gac::rscl::Matrix3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix3f> disownSizeCov();

  inline float getHeadingAngleStd();
  inline void setHeadingAngleStd(float value);

  inline float getTrackingPeriod();
  inline void setTrackingPeriod(float value);

  inline bool getIsMovable();
  inline void setIsMovable(bool value);

  inline bool getIsHeadingToEgoCar();
  inline void setIsHeadingToEgoCar(bool value);

  inline bool getIsEverHeadingToEgoCar();
  inline void setIsEverHeadingToEgoCar(bool value);

  inline  ::uint8_t getLampStatus();
  inline void setLampStatus( ::uint8_t value);

  inline  ::uint8_t getTrackingStatus();
  inline void setTrackingStatus( ::uint8_t value);

  inline  ::uint8_t getCutInStatus();
  inline void setCutInStatus( ::uint8_t value);

  inline  ::uint8_t getCutOutStatus();
  inline void setCutOutStatus( ::uint8_t value);

  inline bool hasPredictPathVector();
  inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder getPredictPathVector();
  inline void setPredictPathVector( ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder initPredictPathVector(unsigned int size);
  inline void adoptPredictPathVector(::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>> disownPredictPathVector();

  inline bool hasPolygon();
  inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder getPolygon();
  inline void setPolygon( ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder initPolygon(unsigned int size);
  inline void adoptPolygon(::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>> disownPolygon();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeneralObstacle::Pipeline {
public:
  typedef GeneralObstacle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::ObstacleTypeInfo::Pipeline getObstacleTypeInfo();
  inline  ::gac::rscl::Point2f::Pipeline getCenterPosition();
  inline  ::gac::rscl::Vector2f::Pipeline getAbsoluteVelocity();
  inline  ::gac::rscl::Vector2f::Pipeline getRelativeVelocity();
  inline  ::gac::rscl::Vector2f::Pipeline getAbsoluteAccelaration();
  inline  ::gac::rscl::Matrix2f::Pipeline getCenterPositionCov();
  inline  ::gac::rscl::Matrix2f::Pipeline getVelocityCov();
  inline  ::gac::rscl::Matrix2f::Pipeline getAccelarationCov();
  inline  ::gac::rscl::Matrix3f::Pipeline getSizeCov();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorGeneralObstacle::Reader {
public:
  typedef VectorGeneralObstacle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorGeneralObstacle::Builder {
public:
  typedef VectorGeneralObstacle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorGeneralObstacle::Pipeline {
public:
  typedef VectorGeneralObstacle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FusionObstacle::Reader {
public:
  typedef FusionObstacle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint32_t getObstacleNum() const;

  inline bool hasGeneralObstacleVector() const;
  inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader getGeneralObstacleVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FusionObstacle::Builder {
public:
  typedef FusionObstacle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint32_t getObstacleNum();
  inline void setObstacleNum( ::uint32_t value);

  inline bool hasGeneralObstacleVector();
  inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder getGeneralObstacleVector();
  inline void setGeneralObstacleVector( ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder initGeneralObstacleVector(unsigned int size);
  inline void adoptGeneralObstacleVector(::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>> disownGeneralObstacleVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FusionObstacle::Pipeline {
public:
  typedef FusionObstacle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VisionObstacleUint::Reader {
public:
  typedef VisionObstacleUint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint32_t getId() const;

  inline bool hasType() const;
  inline  ::gac::rscl::ObstacleTypeInfo::Reader getType() const;

  inline float getConfidence() const;

  inline  ::uint8_t getMovingStatus() const;

  inline float getTrackingPeriod() const;

  inline  ::uint8_t getTrackingStatus() const;

  inline bool hasSize() const;
  inline  ::gac::rscl::Vector3f::Reader getSize() const;

  inline float getLongitudinalPosition() const;

  inline float getLateralPosition() const;

  inline float getLongitudinalVelocity() const;

  inline float getLateralVelocity() const;

  inline float getLongitudinalAcceleration() const;

  inline float getLateralAcceleration() const;

  inline float getHeadingAngle() const;

  inline bool hasCenterPositionCov() const;
  inline  ::gac::rscl::Matrix2f::Reader getCenterPositionCov() const;

  inline bool hasVelocityCov() const;
  inline  ::gac::rscl::Matrix2f::Reader getVelocityCov() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VisionObstacleUint::Builder {
public:
  typedef VisionObstacleUint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline bool hasType();
  inline  ::gac::rscl::ObstacleTypeInfo::Builder getType();
  inline void setType( ::gac::rscl::ObstacleTypeInfo::Reader value);
  inline  ::gac::rscl::ObstacleTypeInfo::Builder initType();
  inline void adoptType(::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo> disownType();

  inline float getConfidence();
  inline void setConfidence(float value);

  inline  ::uint8_t getMovingStatus();
  inline void setMovingStatus( ::uint8_t value);

  inline float getTrackingPeriod();
  inline void setTrackingPeriod(float value);

  inline  ::uint8_t getTrackingStatus();
  inline void setTrackingStatus( ::uint8_t value);

  inline bool hasSize();
  inline  ::gac::rscl::Vector3f::Builder getSize();
  inline void setSize( ::gac::rscl::Vector3f::Reader value);
  inline  ::gac::rscl::Vector3f::Builder initSize();
  inline void adoptSize(::capnp::Orphan< ::gac::rscl::Vector3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3f> disownSize();

  inline float getLongitudinalPosition();
  inline void setLongitudinalPosition(float value);

  inline float getLateralPosition();
  inline void setLateralPosition(float value);

  inline float getLongitudinalVelocity();
  inline void setLongitudinalVelocity(float value);

  inline float getLateralVelocity();
  inline void setLateralVelocity(float value);

  inline float getLongitudinalAcceleration();
  inline void setLongitudinalAcceleration(float value);

  inline float getLateralAcceleration();
  inline void setLateralAcceleration(float value);

  inline float getHeadingAngle();
  inline void setHeadingAngle(float value);

  inline bool hasCenterPositionCov();
  inline  ::gac::rscl::Matrix2f::Builder getCenterPositionCov();
  inline void setCenterPositionCov( ::gac::rscl::Matrix2f::Reader value);
  inline  ::gac::rscl::Matrix2f::Builder initCenterPositionCov();
  inline void adoptCenterPositionCov(::capnp::Orphan< ::gac::rscl::Matrix2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix2f> disownCenterPositionCov();

  inline bool hasVelocityCov();
  inline  ::gac::rscl::Matrix2f::Builder getVelocityCov();
  inline void setVelocityCov( ::gac::rscl::Matrix2f::Reader value);
  inline  ::gac::rscl::Matrix2f::Builder initVelocityCov();
  inline void adoptVelocityCov(::capnp::Orphan< ::gac::rscl::Matrix2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix2f> disownVelocityCov();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VisionObstacleUint::Pipeline {
public:
  typedef VisionObstacleUint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::ObstacleTypeInfo::Pipeline getType();
  inline  ::gac::rscl::Vector3f::Pipeline getSize();
  inline  ::gac::rscl::Matrix2f::Pipeline getCenterPositionCov();
  inline  ::gac::rscl::Matrix2f::Pipeline getVelocityCov();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorVisionObstacleUint::Reader {
public:
  typedef VectorVisionObstacleUint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorVisionObstacleUint::Builder {
public:
  typedef VectorVisionObstacleUint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorVisionObstacleUint::Pipeline {
public:
  typedef VectorVisionObstacleUint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VisionObstacle::Reader {
public:
  typedef VisionObstacle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint32_t getObstacleNum() const;

  inline bool hasVisionObstacleVector() const;
  inline  ::gac::rscl::VectorVisionObstacleUint::Reader getVisionObstacleVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VisionObstacle::Builder {
public:
  typedef VisionObstacle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint32_t getObstacleNum();
  inline void setObstacleNum( ::uint32_t value);

  inline bool hasVisionObstacleVector();
  inline  ::gac::rscl::VectorVisionObstacleUint::Builder getVisionObstacleVector();
  inline void setVisionObstacleVector( ::gac::rscl::VectorVisionObstacleUint::Reader value);
  inline  ::gac::rscl::VectorVisionObstacleUint::Builder initVisionObstacleVector();
  inline void adoptVisionObstacleVector(::capnp::Orphan< ::gac::rscl::VectorVisionObstacleUint>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorVisionObstacleUint> disownVisionObstacleVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VisionObstacle::Pipeline {
public:
  typedef VisionObstacle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorVisionObstacleUint::Pipeline getVisionObstacleVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorFloat::Reader {
public:
  typedef VectorFloat Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorFloat::Builder {
public:
  typedef VectorFloat Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorFloat::Pipeline {
public:
  typedef VectorFloat Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalBBox2D::Reader {
public:
  typedef InternalBBox2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTopLeft() const;
  inline  ::gac::rscl::Point2f::Reader getTopLeft() const;

  inline bool hasBottomRight() const;
  inline  ::gac::rscl::Point2f::Reader getBottomRight() const;

  inline float getConfidence() const;

  inline bool getIsLeftSideTruncated() const;

  inline bool getIsRightSideTruncated() const;

  inline bool getIsTopSideTruncated() const;

  inline bool getIsBottomSideTruncated() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalBBox2D::Builder {
public:
  typedef InternalBBox2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTopLeft();
  inline  ::gac::rscl::Point2f::Builder getTopLeft();
  inline void setTopLeft( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initTopLeft();
  inline void adoptTopLeft(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownTopLeft();

  inline bool hasBottomRight();
  inline  ::gac::rscl::Point2f::Builder getBottomRight();
  inline void setBottomRight( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initBottomRight();
  inline void adoptBottomRight(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownBottomRight();

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool getIsLeftSideTruncated();
  inline void setIsLeftSideTruncated(bool value);

  inline bool getIsRightSideTruncated();
  inline void setIsRightSideTruncated(bool value);

  inline bool getIsTopSideTruncated();
  inline void setIsTopSideTruncated(bool value);

  inline bool getIsBottomSideTruncated();
  inline void setIsBottomSideTruncated(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalBBox2D::Pipeline {
public:
  typedef InternalBBox2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point2f::Pipeline getTopLeft();
  inline  ::gac::rscl::Point2f::Pipeline getBottomRight();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraBBox2DInfo::Reader {
public:
  typedef CameraBBox2DInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRawDetectionBox() const;
  inline  ::gac::rscl::InternalBBox2D::Reader getRawDetectionBox() const;

  inline bool hasTrackedBox() const;
  inline  ::gac::rscl::InternalBBox2D::Reader getTrackedBox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraBBox2DInfo::Builder {
public:
  typedef CameraBBox2DInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRawDetectionBox();
  inline  ::gac::rscl::InternalBBox2D::Builder getRawDetectionBox();
  inline void setRawDetectionBox( ::gac::rscl::InternalBBox2D::Reader value);
  inline  ::gac::rscl::InternalBBox2D::Builder initRawDetectionBox();
  inline void adoptRawDetectionBox(::capnp::Orphan< ::gac::rscl::InternalBBox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::InternalBBox2D> disownRawDetectionBox();

  inline bool hasTrackedBox();
  inline  ::gac::rscl::InternalBBox2D::Builder getTrackedBox();
  inline void setTrackedBox( ::gac::rscl::InternalBBox2D::Reader value);
  inline  ::gac::rscl::InternalBBox2D::Builder initTrackedBox();
  inline void adoptTrackedBox(::capnp::Orphan< ::gac::rscl::InternalBBox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::InternalBBox2D> disownTrackedBox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraBBox2DInfo::Pipeline {
public:
  typedef CameraBBox2DInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::InternalBBox2D::Pipeline getRawDetectionBox();
  inline  ::gac::rscl::InternalBBox2D::Pipeline getTrackedBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ModelOutputFeature::Reader {
public:
  typedef ModelOutputFeature Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasValue() const;
  inline  ::gac::rscl::VectorFloat::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ModelOutputFeature::Builder {
public:
  typedef ModelOutputFeature Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasValue();
  inline  ::gac::rscl::VectorFloat::Builder getValue();
  inline void setValue( ::gac::rscl::VectorFloat::Reader value);
  inline  ::gac::rscl::VectorFloat::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::gac::rscl::VectorFloat>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorFloat> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ModelOutputFeature::Pipeline {
public:
  typedef ModelOutputFeature Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorFloat::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BaseCameraAttribute::Reader {
public:
  typedef BaseCameraAttribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getIsLandmarkValid() const;

  inline bool hasLandmark() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getLandmark() const;

  inline bool hasLandmarkScores() const;
  inline  ::gac::rscl::VectorFloat::Reader getLandmarkScores() const;

  inline bool getIsDirectionValid() const;

  inline bool hasViewportDirection() const;
  inline  ::gac::rscl::Vector2f::Reader getViewportDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BaseCameraAttribute::Builder {
public:
  typedef BaseCameraAttribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getIsLandmarkValid();
  inline void setIsLandmarkValid(bool value);

  inline bool hasLandmark();
  inline  ::gac::rscl::VectorPoint2f::Builder getLandmark();
  inline void setLandmark( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initLandmark();
  inline void adoptLandmark(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownLandmark();

  inline bool hasLandmarkScores();
  inline  ::gac::rscl::VectorFloat::Builder getLandmarkScores();
  inline void setLandmarkScores( ::gac::rscl::VectorFloat::Reader value);
  inline  ::gac::rscl::VectorFloat::Builder initLandmarkScores();
  inline void adoptLandmarkScores(::capnp::Orphan< ::gac::rscl::VectorFloat>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorFloat> disownLandmarkScores();

  inline bool getIsDirectionValid();
  inline void setIsDirectionValid(bool value);

  inline bool hasViewportDirection();
  inline  ::gac::rscl::Vector2f::Builder getViewportDirection();
  inline void setViewportDirection( ::gac::rscl::Vector2f::Reader value);
  inline  ::gac::rscl::Vector2f::Builder initViewportDirection();
  inline void adoptViewportDirection(::capnp::Orphan< ::gac::rscl::Vector2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector2f> disownViewportDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BaseCameraAttribute::Pipeline {
public:
  typedef BaseCameraAttribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint2f::Pipeline getLandmark();
  inline  ::gac::rscl::VectorFloat::Pipeline getLandmarkScores();
  inline  ::gac::rscl::Vector2f::Pipeline getViewportDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AutomobileLightStatus::Reader {
public:
  typedef AutomobileLightStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn() const;

  inline  ::int32_t getRightTurn() const;

  inline  ::int32_t getHazard() const;

  inline  ::int32_t getBrake() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AutomobileLightStatus::Builder {
public:
  typedef AutomobileLightStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn();
  inline void setLeftTurn( ::int32_t value);

  inline  ::int32_t getRightTurn();
  inline void setRightTurn( ::int32_t value);

  inline  ::int32_t getHazard();
  inline void setHazard( ::int32_t value);

  inline  ::int32_t getBrake();
  inline void setBrake( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AutomobileLightStatus::Pipeline {
public:
  typedef AutomobileLightStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NonAutomobileVehicleLightStatus::Reader {
public:
  typedef NonAutomobileVehicleLightStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn() const;

  inline  ::int32_t getRightTurn() const;

  inline  ::int32_t getBrake() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NonAutomobileVehicleLightStatus::Builder {
public:
  typedef NonAutomobileVehicleLightStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLeftTurn();
  inline void setLeftTurn( ::int32_t value);

  inline  ::int32_t getRightTurn();
  inline void setRightTurn( ::int32_t value);

  inline  ::int32_t getBrake();
  inline void setBrake( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NonAutomobileVehicleLightStatus::Pipeline {
public:
  typedef NonAutomobileVehicleLightStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DepthDetPoint::Reader {
public:
  typedef DepthDetPoint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getNearestPointX() const;

  inline float getDepthPointX() const;

  inline float getDepthPointY() const;

  inline  ::int32_t getOrientation() const;

  inline  ::int32_t getLabel() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DepthDetPoint::Builder {
public:
  typedef DepthDetPoint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getNearestPointX();
  inline void setNearestPointX(float value);

  inline float getDepthPointX();
  inline void setDepthPointX(float value);

  inline float getDepthPointY();
  inline void setDepthPointY(float value);

  inline  ::int32_t getOrientation();
  inline void setOrientation( ::int32_t value);

  inline  ::int32_t getLabel();
  inline void setLabel( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DepthDetPoint::Pipeline {
public:
  typedef DepthDetPoint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DerivedType::Reader {
public:
  typedef DerivedType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DerivedType::Builder {
public:
  typedef DerivedType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DerivedType::Pipeline {
public:
  typedef DerivedType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BirdViewCorners::Reader {
public:
  typedef BirdViewCorners Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBvCorners() const;
  inline  ::gac::rscl::VectorPoint3f::Reader getBvCorners() const;

  inline bool hasCornerConf() const;
  inline  ::gac::rscl::VectorFloat::Reader getCornerConf() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BirdViewCorners::Builder {
public:
  typedef BirdViewCorners Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBvCorners();
  inline  ::gac::rscl::VectorPoint3f::Builder getBvCorners();
  inline void setBvCorners( ::gac::rscl::VectorPoint3f::Reader value);
  inline  ::gac::rscl::VectorPoint3f::Builder initBvCorners();
  inline void adoptBvCorners(::capnp::Orphan< ::gac::rscl::VectorPoint3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint3f> disownBvCorners();

  inline bool hasCornerConf();
  inline  ::gac::rscl::VectorFloat::Builder getCornerConf();
  inline void setCornerConf( ::gac::rscl::VectorFloat::Reader value);
  inline  ::gac::rscl::VectorFloat::Builder initCornerConf();
  inline void adoptCornerConf(::capnp::Orphan< ::gac::rscl::VectorFloat>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorFloat> disownCornerConf();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BirdViewCorners::Pipeline {
public:
  typedef BirdViewCorners Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint3f::Pipeline getBvCorners();
  inline  ::gac::rscl::VectorFloat::Pipeline getCornerConf();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorModelOutputFeature::Reader {
public:
  typedef VectorModelOutputFeature Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorModelOutputFeature::Builder {
public:
  typedef VectorModelOutputFeature Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorModelOutputFeature::Pipeline {
public:
  typedef VectorModelOutputFeature Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalObject::Reader {
public:
  typedef InternalObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeStamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimeStamp() const;

  inline bool hasType() const;
  inline  ::gac::rscl::ObstacleTypeInfo::Reader getType() const;

  inline float getTypeConfidence() const;

  inline float getExistenceConfidence() const;

  inline float getConfidence() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint32_t getTrackId() const;

  inline  ::uint32_t getTrackAgeS() const;

  inline bool hasDerivedType() const;
  inline  ::gac::rscl::DerivedType::Reader getDerivedType() const;

  inline bool hasPosition() const;
  inline  ::gac::rscl::Point3f::Reader getPosition() const;

  inline bool hasPositionUncertainty() const;
  inline  ::gac::rscl::Matrix3f::Reader getPositionUncertainty() const;

  inline bool hasRelativeVelocity() const;
  inline  ::gac::rscl::Point3f::Reader getRelativeVelocity() const;

  inline bool hasRelativeVelocityUncertainty() const;
  inline  ::gac::rscl::Matrix3f::Reader getRelativeVelocityUncertainty() const;

  inline bool hasAcceleration() const;
  inline  ::gac::rscl::Point3f::Reader getAcceleration() const;

  inline bool hasAccelerationUncertainty() const;
  inline  ::gac::rscl::Point3f::Reader getAccelerationUncertainty() const;

  inline bool hasAbsoluteVelocity() const;
  inline  ::gac::rscl::Point3f::Reader getAbsoluteVelocity() const;

  inline bool hasAbsoluteVelocityUncertainty() const;
  inline  ::gac::rscl::Point3f::Reader getAbsoluteVelocityUncertainty() const;

  inline bool hasCoutourPosition() const;
  inline  ::gac::rscl::Point2f::Reader getCoutourPosition() const;

  inline bool hasCoutourPoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getCoutourPoints() const;

  inline float getHeightLowerSurface() const;

  inline float getHeightUpperSurface() const;

  inline bool hasShape() const;
  inline  ::gac::rscl::Vector3f::Reader getShape() const;

  inline bool hasShapeUncertainty() const;
  inline  ::gac::rscl::Matrix3f::Reader getShapeUncertainty() const;

  inline float getHeading() const;

  inline float getHeadingUncertainty() const;

  inline  ::uint8_t getMaintenanceStatus() const;

  inline  ::uint8_t getOcclusionStatus() const;

  inline bool hasBirdviewCorners() const;
  inline  ::gac::rscl::BirdViewCorners::Reader getBirdviewCorners() const;

  inline bool hasFeature() const;
  inline  ::gac::rscl::VectorModelOutputFeature::Reader getFeature() const;

  inline bool hasCameraBboxInfo() const;
  inline  ::gac::rscl::CameraBBox2DInfo::Reader getCameraBboxInfo() const;

  inline bool hasBaseCameraAttribute() const;
  inline  ::gac::rscl::BaseCameraAttribute::Reader getBaseCameraAttribute() const;

  inline bool hasAutomobileLightStatus() const;
  inline  ::gac::rscl::AutomobileLightStatus::Reader getAutomobileLightStatus() const;

  inline bool hasNonAutomobileLightStatus() const;
  inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Reader getNonAutomobileLightStatus() const;

  inline bool getIsWithPed() const;

  inline bool hasUpperBodyDirection() const;
  inline  ::gac::rscl::Point2f::Reader getUpperBodyDirection() const;

  inline bool hasLowerBodyDirection() const;
  inline  ::gac::rscl::Point2f::Reader getLowerBodyDirection() const;

  inline bool hasFaceDirection() const;
  inline  ::gac::rscl::Point2f::Reader getFaceDirection() const;

  inline bool getIsOnBike() const;

  inline bool hasDepthPoint() const;
  inline  ::gac::rscl::DepthDetPoint::Reader getDepthPoint() const;

  inline float getTrackRange() const;

  inline float getTrackRangeRate() const;

  inline float getTrackRangeAccelRate() const;

  inline float getTrackRangeLatRate() const;

  inline float getTrackLatRate() const;

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline float getTrackingPeriod() const;

  inline bool getIsMovable() const;

  inline bool getIsHeadingToEgoCar() const;

  inline bool getIsEverHeadingToEgoCar() const;

  inline  ::uint8_t getLampStatus() const;

  inline  ::uint8_t getTrackingStatus() const;

  inline  ::int8_t getMotionStatus() const;

  inline  ::int8_t getLaneAssignments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalObject::Builder {
public:
  typedef InternalObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeStamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimeStamp();
  inline void setTimeStamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimeStamp();
  inline void adoptTimeStamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimeStamp();

  inline bool hasType();
  inline  ::gac::rscl::ObstacleTypeInfo::Builder getType();
  inline void setType( ::gac::rscl::ObstacleTypeInfo::Reader value);
  inline  ::gac::rscl::ObstacleTypeInfo::Builder initType();
  inline void adoptType(::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo> disownType();

  inline float getTypeConfidence();
  inline void setTypeConfidence(float value);

  inline float getExistenceConfidence();
  inline void setExistenceConfidence(float value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint32_t getTrackId();
  inline void setTrackId( ::uint32_t value);

  inline  ::uint32_t getTrackAgeS();
  inline void setTrackAgeS( ::uint32_t value);

  inline bool hasDerivedType();
  inline  ::gac::rscl::DerivedType::Builder getDerivedType();
  inline void setDerivedType( ::gac::rscl::DerivedType::Reader value);
  inline  ::gac::rscl::DerivedType::Builder initDerivedType();
  inline void adoptDerivedType(::capnp::Orphan< ::gac::rscl::DerivedType>&& value);
  inline ::capnp::Orphan< ::gac::rscl::DerivedType> disownDerivedType();

  inline bool hasPosition();
  inline  ::gac::rscl::Point3f::Builder getPosition();
  inline void setPosition( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownPosition();

  inline bool hasPositionUncertainty();
  inline  ::gac::rscl::Matrix3f::Builder getPositionUncertainty();
  inline void setPositionUncertainty( ::gac::rscl::Matrix3f::Reader value);
  inline  ::gac::rscl::Matrix3f::Builder initPositionUncertainty();
  inline void adoptPositionUncertainty(::capnp::Orphan< ::gac::rscl::Matrix3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix3f> disownPositionUncertainty();

  inline bool hasRelativeVelocity();
  inline  ::gac::rscl::Point3f::Builder getRelativeVelocity();
  inline void setRelativeVelocity( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initRelativeVelocity();
  inline void adoptRelativeVelocity(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownRelativeVelocity();

  inline bool hasRelativeVelocityUncertainty();
  inline  ::gac::rscl::Matrix3f::Builder getRelativeVelocityUncertainty();
  inline void setRelativeVelocityUncertainty( ::gac::rscl::Matrix3f::Reader value);
  inline  ::gac::rscl::Matrix3f::Builder initRelativeVelocityUncertainty();
  inline void adoptRelativeVelocityUncertainty(::capnp::Orphan< ::gac::rscl::Matrix3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix3f> disownRelativeVelocityUncertainty();

  inline bool hasAcceleration();
  inline  ::gac::rscl::Point3f::Builder getAcceleration();
  inline void setAcceleration( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initAcceleration();
  inline void adoptAcceleration(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownAcceleration();

  inline bool hasAccelerationUncertainty();
  inline  ::gac::rscl::Point3f::Builder getAccelerationUncertainty();
  inline void setAccelerationUncertainty( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initAccelerationUncertainty();
  inline void adoptAccelerationUncertainty(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownAccelerationUncertainty();

  inline bool hasAbsoluteVelocity();
  inline  ::gac::rscl::Point3f::Builder getAbsoluteVelocity();
  inline void setAbsoluteVelocity( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initAbsoluteVelocity();
  inline void adoptAbsoluteVelocity(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownAbsoluteVelocity();

  inline bool hasAbsoluteVelocityUncertainty();
  inline  ::gac::rscl::Point3f::Builder getAbsoluteVelocityUncertainty();
  inline void setAbsoluteVelocityUncertainty( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initAbsoluteVelocityUncertainty();
  inline void adoptAbsoluteVelocityUncertainty(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownAbsoluteVelocityUncertainty();

  inline bool hasCoutourPosition();
  inline  ::gac::rscl::Point2f::Builder getCoutourPosition();
  inline void setCoutourPosition( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initCoutourPosition();
  inline void adoptCoutourPosition(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownCoutourPosition();

  inline bool hasCoutourPoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getCoutourPoints();
  inline void setCoutourPoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initCoutourPoints();
  inline void adoptCoutourPoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownCoutourPoints();

  inline float getHeightLowerSurface();
  inline void setHeightLowerSurface(float value);

  inline float getHeightUpperSurface();
  inline void setHeightUpperSurface(float value);

  inline bool hasShape();
  inline  ::gac::rscl::Vector3f::Builder getShape();
  inline void setShape( ::gac::rscl::Vector3f::Reader value);
  inline  ::gac::rscl::Vector3f::Builder initShape();
  inline void adoptShape(::capnp::Orphan< ::gac::rscl::Vector3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Vector3f> disownShape();

  inline bool hasShapeUncertainty();
  inline  ::gac::rscl::Matrix3f::Builder getShapeUncertainty();
  inline void setShapeUncertainty( ::gac::rscl::Matrix3f::Reader value);
  inline  ::gac::rscl::Matrix3f::Builder initShapeUncertainty();
  inline void adoptShapeUncertainty(::capnp::Orphan< ::gac::rscl::Matrix3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Matrix3f> disownShapeUncertainty();

  inline float getHeading();
  inline void setHeading(float value);

  inline float getHeadingUncertainty();
  inline void setHeadingUncertainty(float value);

  inline  ::uint8_t getMaintenanceStatus();
  inline void setMaintenanceStatus( ::uint8_t value);

  inline  ::uint8_t getOcclusionStatus();
  inline void setOcclusionStatus( ::uint8_t value);

  inline bool hasBirdviewCorners();
  inline  ::gac::rscl::BirdViewCorners::Builder getBirdviewCorners();
  inline void setBirdviewCorners( ::gac::rscl::BirdViewCorners::Reader value);
  inline  ::gac::rscl::BirdViewCorners::Builder initBirdviewCorners();
  inline void adoptBirdviewCorners(::capnp::Orphan< ::gac::rscl::BirdViewCorners>&& value);
  inline ::capnp::Orphan< ::gac::rscl::BirdViewCorners> disownBirdviewCorners();

  inline bool hasFeature();
  inline  ::gac::rscl::VectorModelOutputFeature::Builder getFeature();
  inline void setFeature( ::gac::rscl::VectorModelOutputFeature::Reader value);
  inline  ::gac::rscl::VectorModelOutputFeature::Builder initFeature();
  inline void adoptFeature(::capnp::Orphan< ::gac::rscl::VectorModelOutputFeature>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorModelOutputFeature> disownFeature();

  inline bool hasCameraBboxInfo();
  inline  ::gac::rscl::CameraBBox2DInfo::Builder getCameraBboxInfo();
  inline void setCameraBboxInfo( ::gac::rscl::CameraBBox2DInfo::Reader value);
  inline  ::gac::rscl::CameraBBox2DInfo::Builder initCameraBboxInfo();
  inline void adoptCameraBboxInfo(::capnp::Orphan< ::gac::rscl::CameraBBox2DInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CameraBBox2DInfo> disownCameraBboxInfo();

  inline bool hasBaseCameraAttribute();
  inline  ::gac::rscl::BaseCameraAttribute::Builder getBaseCameraAttribute();
  inline void setBaseCameraAttribute( ::gac::rscl::BaseCameraAttribute::Reader value);
  inline  ::gac::rscl::BaseCameraAttribute::Builder initBaseCameraAttribute();
  inline void adoptBaseCameraAttribute(::capnp::Orphan< ::gac::rscl::BaseCameraAttribute>&& value);
  inline ::capnp::Orphan< ::gac::rscl::BaseCameraAttribute> disownBaseCameraAttribute();

  inline bool hasAutomobileLightStatus();
  inline  ::gac::rscl::AutomobileLightStatus::Builder getAutomobileLightStatus();
  inline void setAutomobileLightStatus( ::gac::rscl::AutomobileLightStatus::Reader value);
  inline  ::gac::rscl::AutomobileLightStatus::Builder initAutomobileLightStatus();
  inline void adoptAutomobileLightStatus(::capnp::Orphan< ::gac::rscl::AutomobileLightStatus>&& value);
  inline ::capnp::Orphan< ::gac::rscl::AutomobileLightStatus> disownAutomobileLightStatus();

  inline bool hasNonAutomobileLightStatus();
  inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Builder getNonAutomobileLightStatus();
  inline void setNonAutomobileLightStatus( ::gac::rscl::NonAutomobileVehicleLightStatus::Reader value);
  inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Builder initNonAutomobileLightStatus();
  inline void adoptNonAutomobileLightStatus(::capnp::Orphan< ::gac::rscl::NonAutomobileVehicleLightStatus>&& value);
  inline ::capnp::Orphan< ::gac::rscl::NonAutomobileVehicleLightStatus> disownNonAutomobileLightStatus();

  inline bool getIsWithPed();
  inline void setIsWithPed(bool value);

  inline bool hasUpperBodyDirection();
  inline  ::gac::rscl::Point2f::Builder getUpperBodyDirection();
  inline void setUpperBodyDirection( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initUpperBodyDirection();
  inline void adoptUpperBodyDirection(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownUpperBodyDirection();

  inline bool hasLowerBodyDirection();
  inline  ::gac::rscl::Point2f::Builder getLowerBodyDirection();
  inline void setLowerBodyDirection( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initLowerBodyDirection();
  inline void adoptLowerBodyDirection(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownLowerBodyDirection();

  inline bool hasFaceDirection();
  inline  ::gac::rscl::Point2f::Builder getFaceDirection();
  inline void setFaceDirection( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initFaceDirection();
  inline void adoptFaceDirection(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownFaceDirection();

  inline bool getIsOnBike();
  inline void setIsOnBike(bool value);

  inline bool hasDepthPoint();
  inline  ::gac::rscl::DepthDetPoint::Builder getDepthPoint();
  inline void setDepthPoint( ::gac::rscl::DepthDetPoint::Reader value);
  inline  ::gac::rscl::DepthDetPoint::Builder initDepthPoint();
  inline void adoptDepthPoint(::capnp::Orphan< ::gac::rscl::DepthDetPoint>&& value);
  inline ::capnp::Orphan< ::gac::rscl::DepthDetPoint> disownDepthPoint();

  inline float getTrackRange();
  inline void setTrackRange(float value);

  inline float getTrackRangeRate();
  inline void setTrackRangeRate(float value);

  inline float getTrackRangeAccelRate();
  inline void setTrackRangeAccelRate(float value);

  inline float getTrackRangeLatRate();
  inline void setTrackRangeLatRate(float value);

  inline float getTrackLatRate();
  inline void setTrackLatRate(float value);

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline float getTrackingPeriod();
  inline void setTrackingPeriod(float value);

  inline bool getIsMovable();
  inline void setIsMovable(bool value);

  inline bool getIsHeadingToEgoCar();
  inline void setIsHeadingToEgoCar(bool value);

  inline bool getIsEverHeadingToEgoCar();
  inline void setIsEverHeadingToEgoCar(bool value);

  inline  ::uint8_t getLampStatus();
  inline void setLampStatus( ::uint8_t value);

  inline  ::uint8_t getTrackingStatus();
  inline void setTrackingStatus( ::uint8_t value);

  inline  ::int8_t getMotionStatus();
  inline void setMotionStatus( ::int8_t value);

  inline  ::int8_t getLaneAssignments();
  inline void setLaneAssignments( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalObject::Pipeline {
public:
  typedef InternalObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimeStamp();
  inline  ::gac::rscl::ObstacleTypeInfo::Pipeline getType();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::DerivedType::Pipeline getDerivedType();
  inline  ::gac::rscl::Point3f::Pipeline getPosition();
  inline  ::gac::rscl::Matrix3f::Pipeline getPositionUncertainty();
  inline  ::gac::rscl::Point3f::Pipeline getRelativeVelocity();
  inline  ::gac::rscl::Matrix3f::Pipeline getRelativeVelocityUncertainty();
  inline  ::gac::rscl::Point3f::Pipeline getAcceleration();
  inline  ::gac::rscl::Point3f::Pipeline getAccelerationUncertainty();
  inline  ::gac::rscl::Point3f::Pipeline getAbsoluteVelocity();
  inline  ::gac::rscl::Point3f::Pipeline getAbsoluteVelocityUncertainty();
  inline  ::gac::rscl::Point2f::Pipeline getCoutourPosition();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getCoutourPoints();
  inline  ::gac::rscl::Vector3f::Pipeline getShape();
  inline  ::gac::rscl::Matrix3f::Pipeline getShapeUncertainty();
  inline  ::gac::rscl::BirdViewCorners::Pipeline getBirdviewCorners();
  inline  ::gac::rscl::VectorModelOutputFeature::Pipeline getFeature();
  inline  ::gac::rscl::CameraBBox2DInfo::Pipeline getCameraBboxInfo();
  inline  ::gac::rscl::BaseCameraAttribute::Pipeline getBaseCameraAttribute();
  inline  ::gac::rscl::AutomobileLightStatus::Pipeline getAutomobileLightStatus();
  inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Pipeline getNonAutomobileLightStatus();
  inline  ::gac::rscl::Point2f::Pipeline getUpperBodyDirection();
  inline  ::gac::rscl::Point2f::Pipeline getLowerBodyDirection();
  inline  ::gac::rscl::Point2f::Pipeline getFaceDirection();
  inline  ::gac::rscl::DepthDetPoint::Pipeline getDepthPoint();
  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalObject::Reader {
public:
  typedef VectorInternalObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalObject::Builder {
public:
  typedef VectorInternalObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalObject::Pipeline {
public:
  typedef VectorInternalObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorSensorSWCTimeStamp::Reader {
public:
  typedef VectorSensorSWCTimeStamp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorSensorSWCTimeStamp::Builder {
public:
  typedef VectorSensorSWCTimeStamp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorSensorSWCTimeStamp::Pipeline {
public:
  typedef VectorSensorSWCTimeStamp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeStampGap::Reader {
public:
  typedef TimeStampGap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getType() const;

  inline bool hasSensorTimestampVector() const;
  inline  ::gac::rscl::VectorSensorSWCTimeStamp::Reader getSensorTimestampVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeStampGap::Builder {
public:
  typedef TimeStampGap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getType();
  inline void setType( ::uint32_t value);

  inline bool hasSensorTimestampVector();
  inline  ::gac::rscl::VectorSensorSWCTimeStamp::Builder getSensorTimestampVector();
  inline void setSensorTimestampVector( ::gac::rscl::VectorSensorSWCTimeStamp::Reader value);
  inline  ::gac::rscl::VectorSensorSWCTimeStamp::Builder initSensorTimestampVector();
  inline void adoptSensorTimestampVector(::capnp::Orphan< ::gac::rscl::VectorSensorSWCTimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSensorSWCTimeStamp> disownSensorTimestampVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeStampGap::Pipeline {
public:
  typedef TimeStampGap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorSensorSWCTimeStamp::Pipeline getSensorTimestampVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorVEDAttribute::Reader {
public:
  typedef VectorVEDAttribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorVEDAttribute::Builder {
public:
  typedef VectorVEDAttribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorVEDAttribute::Pipeline {
public:
  typedef VectorVEDAttribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LightSpot::Reader {
public:
  typedef LightSpot Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline  ::uint8_t getLsDayTimeStatus() const;

  inline  ::uint8_t getLsTunnelAreaDetection() const;

  inline  ::uint32_t getLsSpotsNumber() const;

  inline bool hasLightSpotVector() const;
  inline  ::gac::rscl::VectorVISLIGHTSPOT::Reader getLightSpotVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LightSpot::Builder {
public:
  typedef LightSpot Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline  ::uint8_t getLsDayTimeStatus();
  inline void setLsDayTimeStatus( ::uint8_t value);

  inline  ::uint8_t getLsTunnelAreaDetection();
  inline void setLsTunnelAreaDetection( ::uint8_t value);

  inline  ::uint32_t getLsSpotsNumber();
  inline void setLsSpotsNumber( ::uint32_t value);

  inline bool hasLightSpotVector();
  inline  ::gac::rscl::VectorVISLIGHTSPOT::Builder getLightSpotVector();
  inline void setLightSpotVector( ::gac::rscl::VectorVISLIGHTSPOT::Reader value);
  inline  ::gac::rscl::VectorVISLIGHTSPOT::Builder initLightSpotVector();
  inline void adoptLightSpotVector(::capnp::Orphan< ::gac::rscl::VectorVISLIGHTSPOT>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorVISLIGHTSPOT> disownLightSpotVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LightSpot::Pipeline {
public:
  typedef LightSpot Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::VectorVISLIGHTSPOT::Pipeline getLightSpotVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VisionOdd::Reader {
public:
  typedef VisionOdd Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint8_t getWeatherInfo() const;

  inline  ::uint8_t getVisibleDistance() const;

  inline  ::uint8_t getEnvironmentLightStatus() const;

  inline  ::uint8_t getRainfallInfo() const;

  inline  ::uint8_t getTollgateStatus() const;

  inline  ::uint8_t getRoadCondition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VisionOdd::Builder {
public:
  typedef VisionOdd Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint8_t getWeatherInfo();
  inline void setWeatherInfo( ::uint8_t value);

  inline  ::uint8_t getVisibleDistance();
  inline void setVisibleDistance( ::uint8_t value);

  inline  ::uint8_t getEnvironmentLightStatus();
  inline void setEnvironmentLightStatus( ::uint8_t value);

  inline  ::uint8_t getRainfallInfo();
  inline void setRainfallInfo( ::uint8_t value);

  inline  ::uint8_t getTollgateStatus();
  inline void setTollgateStatus( ::uint8_t value);

  inline  ::uint8_t getRoadCondition();
  inline void setRoadCondition( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VisionOdd::Pipeline {
public:
  typedef VisionOdd Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraTSLRObject::Reader {
public:
  typedef CameraTSLRObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKeypoints() const;
  inline  ::gac::rscl::VectorImageKeyPoint::Reader getKeypoints() const;

  inline  ::uint8_t getType() const;

  inline float getClassConfidence() const;

  inline bool hasBbox2d() const;
  inline  ::gac::rscl::ImageBbox2D::Reader getBbox2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraTSLRObject::Builder {
public:
  typedef CameraTSLRObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKeypoints();
  inline  ::gac::rscl::VectorImageKeyPoint::Builder getKeypoints();
  inline void setKeypoints( ::gac::rscl::VectorImageKeyPoint::Reader value);
  inline  ::gac::rscl::VectorImageKeyPoint::Builder initKeypoints();
  inline void adoptKeypoints(::capnp::Orphan< ::gac::rscl::VectorImageKeyPoint>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorImageKeyPoint> disownKeypoints();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline float getClassConfidence();
  inline void setClassConfidence(float value);

  inline bool hasBbox2d();
  inline  ::gac::rscl::ImageBbox2D::Builder getBbox2d();
  inline void setBbox2d( ::gac::rscl::ImageBbox2D::Reader value);
  inline  ::gac::rscl::ImageBbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> disownBbox2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraTSLRObject::Pipeline {
public:
  typedef CameraTSLRObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorImageKeyPoint::Pipeline getKeypoints();
  inline  ::gac::rscl::ImageBbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorCameraTSLRObject::Reader {
public:
  typedef VectorCameraTSLRObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorCameraTSLRObject::Builder {
public:
  typedef VectorCameraTSLRObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorCameraTSLRObject::Pipeline {
public:
  typedef VectorCameraTSLRObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraTSLR::Reader {
public:
  typedef CameraTSLR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline bool hasObjects() const;
  inline  ::gac::rscl::VectorCameraTSLRObject::Reader getObjects() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraTSLR::Builder {
public:
  typedef CameraTSLR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline bool hasObjects();
  inline  ::gac::rscl::VectorCameraTSLRObject::Builder getObjects();
  inline void setObjects( ::gac::rscl::VectorCameraTSLRObject::Reader value);
  inline  ::gac::rscl::VectorCameraTSLRObject::Builder initObjects();
  inline void adoptObjects(::capnp::Orphan< ::gac::rscl::VectorCameraTSLRObject>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorCameraTSLRObject> disownObjects();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraTSLR::Pipeline {
public:
  typedef CameraTSLR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorCameraTSLRObject::Pipeline getObjects();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneType::Reader {
public:
  typedef LaneType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCutPoint() const;
  inline  ::gac::rscl::Point2f::Reader getCutPoint() const;

  inline  ::uint8_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneType::Builder {
public:
  typedef LaneType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCutPoint();
  inline  ::gac::rscl::Point2f::Builder getCutPoint();
  inline void setCutPoint( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initCutPoint();
  inline void adoptCutPoint(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownCutPoint();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneType::Pipeline {
public:
  typedef LaneType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point2f::Pipeline getCutPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLaneType::Reader {
public:
  typedef VectorLaneType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLaneType::Builder {
public:
  typedef VectorLaneType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLaneType::Pipeline {
public:
  typedef VectorLaneType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneColor::Reader {
public:
  typedef LaneColor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCutPoint() const;
  inline  ::gac::rscl::Point2f::Reader getCutPoint() const;

  inline  ::uint8_t getColor() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneColor::Builder {
public:
  typedef LaneColor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCutPoint();
  inline  ::gac::rscl::Point2f::Builder getCutPoint();
  inline void setCutPoint( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initCutPoint();
  inline void adoptCutPoint(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownCutPoint();

  inline  ::uint8_t getColor();
  inline void setColor( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneColor::Pipeline {
public:
  typedef LaneColor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Point2f::Pipeline getCutPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLaneColor::Reader {
public:
  typedef VectorLaneColor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLaneColor::Builder {
public:
  typedef VectorLaneColor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLaneColor::Pipeline {
public:
  typedef VectorLaneColor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalLanePoint2f::Reader {
public:
  typedef InternalLanePoint2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline  ::uint8_t getNextSegmentLaneLineType() const;

  inline  ::uint8_t getNextSegmentLaneLineColor() const;

  inline bool hasNextSegmentLaneLineWidth() const;
  inline  ::gac::rscl::LaneWidth::Reader getNextSegmentLaneLineWidth() const;

  inline float getNextSegmentLaneLineColorConfidence() const;

  inline float getNextSegmentLaneLineTypeConfidence() const;

  inline float getNextSegmentLaneLineWidthConfidence() const;

  inline  ::uint8_t getPointType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalLanePoint2f::Builder {
public:
  typedef InternalLanePoint2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline  ::uint8_t getNextSegmentLaneLineType();
  inline void setNextSegmentLaneLineType( ::uint8_t value);

  inline  ::uint8_t getNextSegmentLaneLineColor();
  inline void setNextSegmentLaneLineColor( ::uint8_t value);

  inline bool hasNextSegmentLaneLineWidth();
  inline  ::gac::rscl::LaneWidth::Builder getNextSegmentLaneLineWidth();
  inline void setNextSegmentLaneLineWidth( ::gac::rscl::LaneWidth::Reader value);
  inline  ::gac::rscl::LaneWidth::Builder initNextSegmentLaneLineWidth();
  inline void adoptNextSegmentLaneLineWidth(::capnp::Orphan< ::gac::rscl::LaneWidth>&& value);
  inline ::capnp::Orphan< ::gac::rscl::LaneWidth> disownNextSegmentLaneLineWidth();

  inline float getNextSegmentLaneLineColorConfidence();
  inline void setNextSegmentLaneLineColorConfidence(float value);

  inline float getNextSegmentLaneLineTypeConfidence();
  inline void setNextSegmentLaneLineTypeConfidence(float value);

  inline float getNextSegmentLaneLineWidthConfidence();
  inline void setNextSegmentLaneLineWidthConfidence(float value);

  inline  ::uint8_t getPointType();
  inline void setPointType( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalLanePoint2f::Pipeline {
public:
  typedef InternalLanePoint2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::LaneWidth::Pipeline getNextSegmentLaneLineWidth();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLaneWidth::Reader {
public:
  typedef VectorLaneWidth Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLaneWidth::Builder {
public:
  typedef VectorLaneWidth Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLaneWidth::Pipeline {
public:
  typedef VectorLaneWidth Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneBoundary::Reader {
public:
  typedef LaneBoundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfo() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfo() const;

  inline  ::uint32_t getLaneId() const;

  inline  ::uint8_t getLanePositionIndex() const;

  inline float getConfidence() const;

  inline  ::uint8_t getAvailability() const;

  inline float getC0() const;

  inline float getC1() const;

  inline float getC2() const;

  inline float getC3() const;

  inline float getRangeStart() const;

  inline float getRangeEnd() const;

  inline bool hasLaneTypeVector() const;
  inline  ::gac::rscl::VectorLaneType::Reader getLaneTypeVector() const;

  inline bool hasLaneColorVector() const;
  inline  ::gac::rscl::VectorLaneColor::Reader getLaneColorVector() const;

  inline bool hasLaneWidthVector() const;
  inline  ::gac::rscl::VectorLaneWidth::Reader getLaneWidthVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneBoundary::Builder {
public:
  typedef LaneBoundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfo();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfo();
  inline void setHistInfo( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfo();
  inline void adoptHistInfo(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfo();

  inline  ::uint32_t getLaneId();
  inline void setLaneId( ::uint32_t value);

  inline  ::uint8_t getLanePositionIndex();
  inline void setLanePositionIndex( ::uint8_t value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline  ::uint8_t getAvailability();
  inline void setAvailability( ::uint8_t value);

  inline float getC0();
  inline void setC0(float value);

  inline float getC1();
  inline void setC1(float value);

  inline float getC2();
  inline void setC2(float value);

  inline float getC3();
  inline void setC3(float value);

  inline float getRangeStart();
  inline void setRangeStart(float value);

  inline float getRangeEnd();
  inline void setRangeEnd(float value);

  inline bool hasLaneTypeVector();
  inline  ::gac::rscl::VectorLaneType::Builder getLaneTypeVector();
  inline void setLaneTypeVector( ::gac::rscl::VectorLaneType::Reader value);
  inline  ::gac::rscl::VectorLaneType::Builder initLaneTypeVector();
  inline void adoptLaneTypeVector(::capnp::Orphan< ::gac::rscl::VectorLaneType>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLaneType> disownLaneTypeVector();

  inline bool hasLaneColorVector();
  inline  ::gac::rscl::VectorLaneColor::Builder getLaneColorVector();
  inline void setLaneColorVector( ::gac::rscl::VectorLaneColor::Reader value);
  inline  ::gac::rscl::VectorLaneColor::Builder initLaneColorVector();
  inline void adoptLaneColorVector(::capnp::Orphan< ::gac::rscl::VectorLaneColor>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLaneColor> disownLaneColorVector();

  inline bool hasLaneWidthVector();
  inline  ::gac::rscl::VectorLaneWidth::Builder getLaneWidthVector();
  inline void setLaneWidthVector( ::gac::rscl::VectorLaneWidth::Reader value);
  inline  ::gac::rscl::VectorLaneWidth::Builder initLaneWidthVector();
  inline void adoptLaneWidthVector(::capnp::Orphan< ::gac::rscl::VectorLaneWidth>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLaneWidth> disownLaneWidthVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneBoundary::Pipeline {
public:
  typedef LaneBoundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfo();
  inline  ::gac::rscl::VectorLaneType::Pipeline getLaneTypeVector();
  inline  ::gac::rscl::VectorLaneColor::Pipeline getLaneColorVector();
  inline  ::gac::rscl::VectorLaneWidth::Pipeline getLaneWidthVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLaneBoundary::Reader {
public:
  typedef VectorLaneBoundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLaneBoundary::Builder {
public:
  typedef VectorLaneBoundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLaneBoundary::Pipeline {
public:
  typedef VectorLaneBoundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FusionLane::Reader {
public:
  typedef FusionLane Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline bool hasLaneBoundaryVector() const;
  inline  ::gac::rscl::VectorLaneBoundary::Reader getLaneBoundaryVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FusionLane::Builder {
public:
  typedef FusionLane Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline bool hasLaneBoundaryVector();
  inline  ::gac::rscl::VectorLaneBoundary::Builder getLaneBoundaryVector();
  inline void setLaneBoundaryVector( ::gac::rscl::VectorLaneBoundary::Reader value);
  inline  ::gac::rscl::VectorLaneBoundary::Builder initLaneBoundaryVector();
  inline void adoptLaneBoundaryVector(::capnp::Orphan< ::gac::rscl::VectorLaneBoundary>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLaneBoundary> disownLaneBoundaryVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FusionLane::Pipeline {
public:
  typedef FusionLane Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorLaneBoundary::Pipeline getLaneBoundaryVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorUInt64::Reader {
public:
  typedef VectorUInt64 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorUInt64::Builder {
public:
  typedef VectorUInt64 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorUInt64::Pipeline {
public:
  typedef VectorUInt64 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Link::Reader {
public:
  typedef Link Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLinkId() const;

  inline  ::uint8_t getLinkType() const;

  inline  ::uint8_t getLinkAttribute() const;

  inline double getLength() const;

  inline  ::uint64_t getIntersectionId() const;

  inline bool hasLaneIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLaneIds() const;

  inline bool hasLeftBoundaryIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLeftBoundaryIds() const;

  inline bool hasRightBoundaryIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getRightBoundaryIds() const;

  inline bool hasPrecedingLinkIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getPrecedingLinkIds() const;

  inline bool hasSucceedingLinkIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getSucceedingLinkIds() const;

  inline  ::uint8_t getLinkClass() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Link::Builder {
public:
  typedef Link Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLinkId();
  inline void setLinkId( ::uint64_t value);

  inline  ::uint8_t getLinkType();
  inline void setLinkType( ::uint8_t value);

  inline  ::uint8_t getLinkAttribute();
  inline void setLinkAttribute( ::uint8_t value);

  inline double getLength();
  inline void setLength(double value);

  inline  ::uint64_t getIntersectionId();
  inline void setIntersectionId( ::uint64_t value);

  inline bool hasLaneIds();
  inline  ::gac::rscl::VectorUInt64::Builder getLaneIds();
  inline void setLaneIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLaneIds();
  inline void adoptLaneIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLaneIds();

  inline bool hasLeftBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Builder getLeftBoundaryIds();
  inline void setLeftBoundaryIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLeftBoundaryIds();
  inline void adoptLeftBoundaryIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLeftBoundaryIds();

  inline bool hasRightBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Builder getRightBoundaryIds();
  inline void setRightBoundaryIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initRightBoundaryIds();
  inline void adoptRightBoundaryIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownRightBoundaryIds();

  inline bool hasPrecedingLinkIds();
  inline  ::gac::rscl::VectorUInt64::Builder getPrecedingLinkIds();
  inline void setPrecedingLinkIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initPrecedingLinkIds();
  inline void adoptPrecedingLinkIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownPrecedingLinkIds();

  inline bool hasSucceedingLinkIds();
  inline  ::gac::rscl::VectorUInt64::Builder getSucceedingLinkIds();
  inline void setSucceedingLinkIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initSucceedingLinkIds();
  inline void adoptSucceedingLinkIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownSucceedingLinkIds();

  inline  ::uint8_t getLinkClass();
  inline void setLinkClass( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Link::Pipeline {
public:
  typedef Link Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorUInt64::Pipeline getLaneIds();
  inline  ::gac::rscl::VectorUInt64::Pipeline getLeftBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Pipeline getRightBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Pipeline getPrecedingLinkIds();
  inline  ::gac::rscl::VectorUInt64::Pipeline getSucceedingLinkIds();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Lane::Reader {
public:
  typedef Lane Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLaneId() const;

  inline  ::uint64_t getLinkId() const;

  inline  ::uint8_t getLaneType() const;

  inline  ::uint8_t getTurnType() const;

  inline  ::uint8_t getTransType() const;

  inline  ::uint8_t getSequence() const;

  inline  ::uint64_t getIntersectionId() const;

  inline  ::uint64_t getLeftLaneId() const;

  inline  ::uint64_t getRightLaneId() const;

  inline  ::uint64_t getLeftBoundaryId() const;

  inline  ::uint64_t getRightBoundaryId() const;

  inline bool hasPrecedingLaneIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getPrecedingLaneIds() const;

  inline bool hasSucceedingLaneIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getSucceedingLaneIds() const;

  inline double getLength() const;

  inline bool hasWidthVector() const;
  inline  ::gac::rscl::VectorIntervalInfo::Reader getWidthVector() const;

  inline bool hasSpeedLimitVector() const;
  inline  ::gac::rscl::VectorIntervalInfo::Reader getSpeedLimitVector() const;

  inline bool hasObjectIds() const;
  inline  ::gac::rscl::VectorIntervalInfo::Reader getObjectIds() const;

  inline bool hasCenterLine() const;
  inline  ::gac::rscl::VectorPoint3dAttribute::Reader getCenterLine() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Lane::Builder {
public:
  typedef Lane Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLaneId();
  inline void setLaneId( ::uint64_t value);

  inline  ::uint64_t getLinkId();
  inline void setLinkId( ::uint64_t value);

  inline  ::uint8_t getLaneType();
  inline void setLaneType( ::uint8_t value);

  inline  ::uint8_t getTurnType();
  inline void setTurnType( ::uint8_t value);

  inline  ::uint8_t getTransType();
  inline void setTransType( ::uint8_t value);

  inline  ::uint8_t getSequence();
  inline void setSequence( ::uint8_t value);

  inline  ::uint64_t getIntersectionId();
  inline void setIntersectionId( ::uint64_t value);

  inline  ::uint64_t getLeftLaneId();
  inline void setLeftLaneId( ::uint64_t value);

  inline  ::uint64_t getRightLaneId();
  inline void setRightLaneId( ::uint64_t value);

  inline  ::uint64_t getLeftBoundaryId();
  inline void setLeftBoundaryId( ::uint64_t value);

  inline  ::uint64_t getRightBoundaryId();
  inline void setRightBoundaryId( ::uint64_t value);

  inline bool hasPrecedingLaneIds();
  inline  ::gac::rscl::VectorUInt64::Builder getPrecedingLaneIds();
  inline void setPrecedingLaneIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initPrecedingLaneIds();
  inline void adoptPrecedingLaneIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownPrecedingLaneIds();

  inline bool hasSucceedingLaneIds();
  inline  ::gac::rscl::VectorUInt64::Builder getSucceedingLaneIds();
  inline void setSucceedingLaneIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initSucceedingLaneIds();
  inline void adoptSucceedingLaneIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownSucceedingLaneIds();

  inline double getLength();
  inline void setLength(double value);

  inline bool hasWidthVector();
  inline  ::gac::rscl::VectorIntervalInfo::Builder getWidthVector();
  inline void setWidthVector( ::gac::rscl::VectorIntervalInfo::Reader value);
  inline  ::gac::rscl::VectorIntervalInfo::Builder initWidthVector();
  inline void adoptWidthVector(::capnp::Orphan< ::gac::rscl::VectorIntervalInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo> disownWidthVector();

  inline bool hasSpeedLimitVector();
  inline  ::gac::rscl::VectorIntervalInfo::Builder getSpeedLimitVector();
  inline void setSpeedLimitVector( ::gac::rscl::VectorIntervalInfo::Reader value);
  inline  ::gac::rscl::VectorIntervalInfo::Builder initSpeedLimitVector();
  inline void adoptSpeedLimitVector(::capnp::Orphan< ::gac::rscl::VectorIntervalInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo> disownSpeedLimitVector();

  inline bool hasObjectIds();
  inline  ::gac::rscl::VectorIntervalInfo::Builder getObjectIds();
  inline void setObjectIds( ::gac::rscl::VectorIntervalInfo::Reader value);
  inline  ::gac::rscl::VectorIntervalInfo::Builder initObjectIds();
  inline void adoptObjectIds(::capnp::Orphan< ::gac::rscl::VectorIntervalInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo> disownObjectIds();

  inline bool hasCenterLine();
  inline  ::gac::rscl::VectorPoint3dAttribute::Builder getCenterLine();
  inline void setCenterLine( ::gac::rscl::VectorPoint3dAttribute::Reader value);
  inline  ::gac::rscl::VectorPoint3dAttribute::Builder initCenterLine();
  inline void adoptCenterLine(::capnp::Orphan< ::gac::rscl::VectorPoint3dAttribute>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint3dAttribute> disownCenterLine();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Lane::Pipeline {
public:
  typedef Lane Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorUInt64::Pipeline getPrecedingLaneIds();
  inline  ::gac::rscl::VectorUInt64::Pipeline getSucceedingLaneIds();
  inline  ::gac::rscl::VectorIntervalInfo::Pipeline getWidthVector();
  inline  ::gac::rscl::VectorIntervalInfo::Pipeline getSpeedLimitVector();
  inline  ::gac::rscl::VectorIntervalInfo::Pipeline getObjectIds();
  inline  ::gac::rscl::VectorPoint3dAttribute::Pipeline getCenterLine();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLane::Reader {
public:
  typedef VectorLane Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLane::Builder {
public:
  typedef VectorLane Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLane::Pipeline {
public:
  typedef VectorLane Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Boundary::Reader {
public:
  typedef Boundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getBoundaryId() const;

  inline  ::uint64_t getLinkId() const;

  inline  ::uint64_t getLeftLaneId() const;

  inline  ::uint64_t getRightLaneId() const;

  inline bool hasPrecedingBoundaryIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getPrecedingBoundaryIds() const;

  inline bool hasSucceedingBoundaryIds() const;
  inline  ::gac::rscl::VectorUInt64::Reader getSucceedingBoundaryIds() const;

  inline bool hasSegments() const;
  inline  ::gac::rscl::VectorBoundaryIntervalInfo::Reader getSegments() const;

  inline bool hasCenterLine() const;
  inline  ::gac::rscl::VectorPoint3d::Reader getCenterLine() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Boundary::Builder {
public:
  typedef Boundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getBoundaryId();
  inline void setBoundaryId( ::uint64_t value);

  inline  ::uint64_t getLinkId();
  inline void setLinkId( ::uint64_t value);

  inline  ::uint64_t getLeftLaneId();
  inline void setLeftLaneId( ::uint64_t value);

  inline  ::uint64_t getRightLaneId();
  inline void setRightLaneId( ::uint64_t value);

  inline bool hasPrecedingBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Builder getPrecedingBoundaryIds();
  inline void setPrecedingBoundaryIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initPrecedingBoundaryIds();
  inline void adoptPrecedingBoundaryIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownPrecedingBoundaryIds();

  inline bool hasSucceedingBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Builder getSucceedingBoundaryIds();
  inline void setSucceedingBoundaryIds( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initSucceedingBoundaryIds();
  inline void adoptSucceedingBoundaryIds(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownSucceedingBoundaryIds();

  inline bool hasSegments();
  inline  ::gac::rscl::VectorBoundaryIntervalInfo::Builder getSegments();
  inline void setSegments( ::gac::rscl::VectorBoundaryIntervalInfo::Reader value);
  inline  ::gac::rscl::VectorBoundaryIntervalInfo::Builder initSegments();
  inline void adoptSegments(::capnp::Orphan< ::gac::rscl::VectorBoundaryIntervalInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorBoundaryIntervalInfo> disownSegments();

  inline bool hasCenterLine();
  inline  ::gac::rscl::VectorPoint3d::Builder getCenterLine();
  inline void setCenterLine( ::gac::rscl::VectorPoint3d::Reader value);
  inline  ::gac::rscl::VectorPoint3d::Builder initCenterLine();
  inline void adoptCenterLine(::capnp::Orphan< ::gac::rscl::VectorPoint3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint3d> disownCenterLine();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Boundary::Pipeline {
public:
  typedef Boundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorUInt64::Pipeline getPrecedingBoundaryIds();
  inline  ::gac::rscl::VectorUInt64::Pipeline getSucceedingBoundaryIds();
  inline  ::gac::rscl::VectorBoundaryIntervalInfo::Pipeline getSegments();
  inline  ::gac::rscl::VectorPoint3d::Pipeline getCenterLine();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorBoundary::Reader {
public:
  typedef VectorBoundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorBoundary::Builder {
public:
  typedef VectorBoundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorBoundary::Pipeline {
public:
  typedef VectorBoundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stopline::Reader {
public:
  typedef Stopline Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline bool hasLaneId() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLaneId() const;

  inline bool hasStopLine() const;
  inline  ::gac::rscl::VectorPoint3d::Reader getStopLine() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stopline::Builder {
public:
  typedef Stopline Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasLaneId();
  inline  ::gac::rscl::VectorUInt64::Builder getLaneId();
  inline void setLaneId( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLaneId();
  inline void adoptLaneId(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLaneId();

  inline bool hasStopLine();
  inline  ::gac::rscl::VectorPoint3d::Builder getStopLine();
  inline void setStopLine( ::gac::rscl::VectorPoint3d::Reader value);
  inline  ::gac::rscl::VectorPoint3d::Builder initStopLine();
  inline void adoptStopLine(::capnp::Orphan< ::gac::rscl::VectorPoint3d>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint3d> disownStopLine();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stopline::Pipeline {
public:
  typedef Stopline Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::VectorUInt64::Pipeline getLaneId();
  inline  ::gac::rscl::VectorPoint3d::Pipeline getStopLine();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorStopline::Reader {
public:
  typedef VectorStopline Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorStopline::Builder {
public:
  typedef VectorStopline Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorStopline::Pipeline {
public:
  typedef VectorStopline Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Marking::Reader {
public:
  typedef Marking Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline  ::uint64_t getLaneId() const;

  inline bool hasPosition() const;
  inline  ::gac::rscl::Point3f::Reader getPosition() const;

  inline bool hasBbox3d() const;
  inline  ::gac::rscl::Bbox3D::Reader getBbox3d() const;

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getColor() const;

  inline bool hasSemanticInfo() const;
  inline  ::capnp::Text::Reader getSemanticInfo() const;

  inline float getConfidence() const;

  inline  ::int32_t getLaneVectorIndex() const;

  inline  ::uint8_t getDetectionStatus() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Marking::Builder {
public:
  typedef Marking Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline  ::uint64_t getLaneId();
  inline void setLaneId( ::uint64_t value);

  inline bool hasPosition();
  inline  ::gac::rscl::Point3f::Builder getPosition();
  inline void setPosition( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownPosition();

  inline bool hasBbox3d();
  inline  ::gac::rscl::Bbox3D::Builder getBbox3d();
  inline void setBbox3d( ::gac::rscl::Bbox3D::Reader value);
  inline  ::gac::rscl::Bbox3D::Builder initBbox3d();
  inline void adoptBbox3d(::capnp::Orphan< ::gac::rscl::Bbox3D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Bbox3D> disownBbox3d();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getColor();
  inline void setColor( ::uint8_t value);

  inline bool hasSemanticInfo();
  inline  ::capnp::Text::Builder getSemanticInfo();
  inline void setSemanticInfo( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSemanticInfo(unsigned int size);
  inline void adoptSemanticInfo(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSemanticInfo();

  inline float getConfidence();
  inline void setConfidence(float value);

  inline  ::int32_t getLaneVectorIndex();
  inline void setLaneVectorIndex( ::int32_t value);

  inline  ::uint8_t getDetectionStatus();
  inline void setDetectionStatus( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Marking::Pipeline {
public:
  typedef Marking Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::Point3f::Pipeline getPosition();
  inline  ::gac::rscl::Bbox3D::Pipeline getBbox3d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorMarking::Reader {
public:
  typedef VectorMarking Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorMarking::Builder {
public:
  typedef VectorMarking Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorMarking::Pipeline {
public:
  typedef VectorMarking Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Sign::Reader {
public:
  typedef Sign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline  ::uint64_t getLaneId() const;

  inline  ::uint32_t getType() const;

  inline bool hasPosition() const;
  inline  ::gac::rscl::Point3f::Reader getPosition() const;

  inline  ::int32_t getLaneVectorIndex() const;

  inline  ::uint8_t getDetectionStatus() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Sign::Builder {
public:
  typedef Sign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline  ::uint64_t getLaneId();
  inline void setLaneId( ::uint64_t value);

  inline  ::uint32_t getType();
  inline void setType( ::uint32_t value);

  inline bool hasPosition();
  inline  ::gac::rscl::Point3f::Builder getPosition();
  inline void setPosition( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownPosition();

  inline  ::int32_t getLaneVectorIndex();
  inline void setLaneVectorIndex( ::int32_t value);

  inline  ::uint8_t getDetectionStatus();
  inline void setDetectionStatus( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Sign::Pipeline {
public:
  typedef Sign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::Point3f::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorSign::Reader {
public:
  typedef VectorSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorSign::Builder {
public:
  typedef VectorSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorSign::Pipeline {
public:
  typedef VectorSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Signal::Reader {
public:
  typedef Signal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getStatus() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Signal::Builder {
public:
  typedef Signal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getStatus();
  inline void setStatus( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Signal::Pipeline {
public:
  typedef Signal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorSignal::Reader {
public:
  typedef VectorSignal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorSignal::Builder {
public:
  typedef VectorSignal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorSignal::Pipeline {
public:
  typedef VectorSignal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SafeIsland::Reader {
public:
  typedef SafeIsland Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline bool hasLaneIdVector() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLaneIdVector() const;

  inline bool hasBvBbox2d() const;
  inline  ::gac::rscl::BirdViewBbox2D::Reader getBvBbox2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SafeIsland::Builder {
public:
  typedef SafeIsland Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasLaneIdVector();
  inline  ::gac::rscl::VectorUInt64::Builder getLaneIdVector();
  inline void setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLaneIdVector();
  inline void adoptLaneIdVector(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLaneIdVector();

  inline bool hasBvBbox2d();
  inline  ::gac::rscl::BirdViewBbox2D::Builder getBvBbox2d();
  inline void setBvBbox2d( ::gac::rscl::BirdViewBbox2D::Reader value);
  inline  ::gac::rscl::BirdViewBbox2D::Builder initBvBbox2d();
  inline void adoptBvBbox2d(::capnp::Orphan< ::gac::rscl::BirdViewBbox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::BirdViewBbox2D> disownBvBbox2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SafeIsland::Pipeline {
public:
  typedef SafeIsland Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::VectorUInt64::Pipeline getLaneIdVector();
  inline  ::gac::rscl::BirdViewBbox2D::Pipeline getBvBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorSafeIsland::Reader {
public:
  typedef VectorSafeIsland Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorSafeIsland::Builder {
public:
  typedef VectorSafeIsland Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorSafeIsland::Pipeline {
public:
  typedef VectorSafeIsland Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PedestrianCrossing::Reader {
public:
  typedef PedestrianCrossing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline bool hasLaneIdVector() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLaneIdVector() const;

  inline bool hasBvBbox2d() const;
  inline  ::gac::rscl::BirdViewBbox2D::Reader getBvBbox2d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PedestrianCrossing::Builder {
public:
  typedef PedestrianCrossing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasLaneIdVector();
  inline  ::gac::rscl::VectorUInt64::Builder getLaneIdVector();
  inline void setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLaneIdVector();
  inline void adoptLaneIdVector(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLaneIdVector();

  inline bool hasBvBbox2d();
  inline  ::gac::rscl::BirdViewBbox2D::Builder getBvBbox2d();
  inline void setBvBbox2d( ::gac::rscl::BirdViewBbox2D::Reader value);
  inline  ::gac::rscl::BirdViewBbox2D::Builder initBvBbox2d();
  inline void adoptBvBbox2d(::capnp::Orphan< ::gac::rscl::BirdViewBbox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::BirdViewBbox2D> disownBvBbox2d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PedestrianCrossing::Pipeline {
public:
  typedef PedestrianCrossing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::VectorUInt64::Pipeline getLaneIdVector();
  inline  ::gac::rscl::BirdViewBbox2D::Pipeline getBvBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorPedestrianCrossing::Reader {
public:
  typedef VectorPedestrianCrossing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorPedestrianCrossing::Builder {
public:
  typedef VectorPedestrianCrossing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorPedestrianCrossing::Pipeline {
public:
  typedef VectorPedestrianCrossing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLink::Reader {
public:
  typedef VectorLink Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLink::Builder {
public:
  typedef VectorLink Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLink::Pipeline {
public:
  typedef VectorLink Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SpeedLimitSign::Reader {
public:
  typedef SpeedLimitSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint8_t getId() const;

  inline float getConfidence() const;

  inline  ::uint8_t getTrackingStatus() const;

  inline  ::uint32_t getType() const;

  inline bool hasCenterPosition() const;
  inline  ::gac::rscl::Point3f::Reader getCenterPosition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SpeedLimitSign::Builder {
public:
  typedef SpeedLimitSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint8_t getId();
  inline void setId( ::uint8_t value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline  ::uint8_t getTrackingStatus();
  inline void setTrackingStatus( ::uint8_t value);

  inline  ::uint32_t getType();
  inline void setType( ::uint32_t value);

  inline bool hasCenterPosition();
  inline  ::gac::rscl::Point3f::Builder getCenterPosition();
  inline void setCenterPosition( ::gac::rscl::Point3f::Reader value);
  inline  ::gac::rscl::Point3f::Builder initCenterPosition();
  inline void adoptCenterPosition(::capnp::Orphan< ::gac::rscl::Point3f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point3f> disownCenterPosition();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SpeedLimitSign::Pipeline {
public:
  typedef SpeedLimitSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::Point3f::Pipeline getCenterPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorSpeedLimitSign::Reader {
public:
  typedef VectorSpeedLimitSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorSpeedLimitSign::Builder {
public:
  typedef VectorSpeedLimitSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorSpeedLimitSign::Pipeline {
public:
  typedef VectorSpeedLimitSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FusionTrafficSign::Reader {
public:
  typedef FusionTrafficSign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint32_t getTrafficSignNum() const;

  inline bool hasSignVector() const;
  inline  ::gac::rscl::VectorSpeedLimitSign::Reader getSignVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FusionTrafficSign::Builder {
public:
  typedef FusionTrafficSign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint32_t getTrafficSignNum();
  inline void setTrafficSignNum( ::uint32_t value);

  inline bool hasSignVector();
  inline  ::gac::rscl::VectorSpeedLimitSign::Builder getSignVector();
  inline void setSignVector( ::gac::rscl::VectorSpeedLimitSign::Reader value);
  inline  ::gac::rscl::VectorSpeedLimitSign::Builder initSignVector();
  inline void adoptSignVector(::capnp::Orphan< ::gac::rscl::VectorSpeedLimitSign>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSpeedLimitSign> disownSignVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FusionTrafficSign::Pipeline {
public:
  typedef FusionTrafficSign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorSpeedLimitSign::Pipeline getSignVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorTrafficLightSignal::Reader {
public:
  typedef VectorTrafficLightSignal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorTrafficLightSignal::Builder {
public:
  typedef VectorTrafficLightSignal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorTrafficLightSignal::Pipeline {
public:
  typedef VectorTrafficLightSignal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Light::Reader {
public:
  typedef Light Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline  ::uint64_t getLaneId() const;

  inline bool getIsDetectedByCamera() const;

  inline bool getIsGotOnlyByCamera() const;

  inline  ::int32_t getCountDownSecond() const;

  inline float getConfidence() const;

  inline bool hasBbox3d() const;
  inline  ::gac::rscl::Bbox3D::Reader getBbox3d() const;

  inline bool hasLaneIdVector() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLaneIdVector() const;

  inline bool hasSignalVector() const;
  inline  ::gac::rscl::VectorSignal::Reader getSignalVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Light::Builder {
public:
  typedef Light Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline  ::uint64_t getLaneId();
  inline void setLaneId( ::uint64_t value);

  inline bool getIsDetectedByCamera();
  inline void setIsDetectedByCamera(bool value);

  inline bool getIsGotOnlyByCamera();
  inline void setIsGotOnlyByCamera(bool value);

  inline  ::int32_t getCountDownSecond();
  inline void setCountDownSecond( ::int32_t value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool hasBbox3d();
  inline  ::gac::rscl::Bbox3D::Builder getBbox3d();
  inline void setBbox3d( ::gac::rscl::Bbox3D::Reader value);
  inline  ::gac::rscl::Bbox3D::Builder initBbox3d();
  inline void adoptBbox3d(::capnp::Orphan< ::gac::rscl::Bbox3D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Bbox3D> disownBbox3d();

  inline bool hasLaneIdVector();
  inline  ::gac::rscl::VectorUInt64::Builder getLaneIdVector();
  inline void setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLaneIdVector();
  inline void adoptLaneIdVector(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLaneIdVector();

  inline bool hasSignalVector();
  inline  ::gac::rscl::VectorSignal::Builder getSignalVector();
  inline void setSignalVector( ::gac::rscl::VectorSignal::Reader value);
  inline  ::gac::rscl::VectorSignal::Builder initSignalVector();
  inline void adoptSignalVector(::capnp::Orphan< ::gac::rscl::VectorSignal>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSignal> disownSignalVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Light::Pipeline {
public:
  typedef Light Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::Bbox3D::Pipeline getBbox3d();
  inline  ::gac::rscl::VectorUInt64::Pipeline getLaneIdVector();
  inline  ::gac::rscl::VectorSignal::Pipeline getSignalVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorLight::Reader {
public:
  typedef VectorLight Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorLight::Builder {
public:
  typedef VectorLight Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorLight::Pipeline {
public:
  typedef VectorLight Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BumpLike::Reader {
public:
  typedef BumpLike Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector() const;
  inline  ::gac::rscl::VectorHistInfo::Reader getHistInfoVector() const;

  inline  ::uint64_t getId() const;

  inline bool hasLaneIdVector() const;
  inline  ::gac::rscl::VectorUInt64::Reader getLaneIdVector() const;

  inline  ::uint8_t getType() const;

  inline bool hasBumplikeBbox() const;
  inline  ::gac::rscl::VectorLaneBoundary::Reader getBumplikeBbox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BumpLike::Builder {
public:
  typedef BumpLike Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfoVector();
  inline  ::gac::rscl::VectorHistInfo::Builder getHistInfoVector();
  inline void setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value);
  inline  ::gac::rscl::VectorHistInfo::Builder initHistInfoVector();
  inline void adoptHistInfoVector(::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> disownHistInfoVector();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasLaneIdVector();
  inline  ::gac::rscl::VectorUInt64::Builder getLaneIdVector();
  inline void setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value);
  inline  ::gac::rscl::VectorUInt64::Builder initLaneIdVector();
  inline void adoptLaneIdVector(::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> disownLaneIdVector();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline bool hasBumplikeBbox();
  inline  ::gac::rscl::VectorLaneBoundary::Builder getBumplikeBbox();
  inline void setBumplikeBbox( ::gac::rscl::VectorLaneBoundary::Reader value);
  inline  ::gac::rscl::VectorLaneBoundary::Builder initBumplikeBbox();
  inline void adoptBumplikeBbox(::capnp::Orphan< ::gac::rscl::VectorLaneBoundary>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLaneBoundary> disownBumplikeBbox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BumpLike::Pipeline {
public:
  typedef BumpLike Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorHistInfo::Pipeline getHistInfoVector();
  inline  ::gac::rscl::VectorUInt64::Pipeline getLaneIdVector();
  inline  ::gac::rscl::VectorLaneBoundary::Pipeline getBumplikeBbox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorBumpLike::Reader {
public:
  typedef VectorBumpLike Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorBumpLike::Builder {
public:
  typedef VectorBumpLike Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorBumpLike::Pipeline {
public:
  typedef VectorBumpLike Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalLanePoint2f::Reader {
public:
  typedef VectorInternalLanePoint2f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalLanePoint2f::Builder {
public:
  typedef VectorInternalLanePoint2f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalLanePoint2f::Pipeline {
public:
  typedef VectorInternalLanePoint2f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalLaneLine::Reader {
public:
  typedef InternalLaneLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLaneIndex() const;

  inline  ::int32_t getTrackId() const;

  inline  ::int32_t getTrackAge() const;

  inline float getDistanceToLeftBumper() const;

  inline float getDistanceToRightBumper() const;

  inline bool hasLanelineWidth() const;
  inline  ::gac::rscl::LaneWidth::Reader getLanelineWidth() const;

  inline  ::uint8_t getColor() const;

  inline  ::uint8_t getLaneType() const;

  inline float getConfidence() const;

  inline float getColorConfidence() const;

  inline float getTypeConfidence() const;

  inline float getWidthConfidence() const;

  inline bool hasStartPoint() const;
  inline  ::gac::rscl::Point2f::Reader getStartPoint() const;

  inline bool hasEndPoint() const;
  inline  ::gac::rscl::Point2f::Reader getEndPoint() const;

  inline bool hasImagePoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getImagePoints() const;

  inline bool hasBvPoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getBvPoints() const;

  inline  ::int32_t getFittingType() const;

  inline  ::int32_t getFittingOrder() const;

  inline bool hasFittingCoefficients() const;
  inline  ::gac::rscl::VectorFloat::Reader getFittingCoefficients() const;

  inline bool hasCutPointVector() const;
  inline  ::gac::rscl::VectorInternalLanePoint2f::Reader getCutPointVector() const;

  inline bool getIsLineJunctionValid() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalLaneLine::Builder {
public:
  typedef InternalLaneLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getLaneIndex();
  inline void setLaneIndex( ::int32_t value);

  inline  ::int32_t getTrackId();
  inline void setTrackId( ::int32_t value);

  inline  ::int32_t getTrackAge();
  inline void setTrackAge( ::int32_t value);

  inline float getDistanceToLeftBumper();
  inline void setDistanceToLeftBumper(float value);

  inline float getDistanceToRightBumper();
  inline void setDistanceToRightBumper(float value);

  inline bool hasLanelineWidth();
  inline  ::gac::rscl::LaneWidth::Builder getLanelineWidth();
  inline void setLanelineWidth( ::gac::rscl::LaneWidth::Reader value);
  inline  ::gac::rscl::LaneWidth::Builder initLanelineWidth();
  inline void adoptLanelineWidth(::capnp::Orphan< ::gac::rscl::LaneWidth>&& value);
  inline ::capnp::Orphan< ::gac::rscl::LaneWidth> disownLanelineWidth();

  inline  ::uint8_t getColor();
  inline void setColor( ::uint8_t value);

  inline  ::uint8_t getLaneType();
  inline void setLaneType( ::uint8_t value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline float getColorConfidence();
  inline void setColorConfidence(float value);

  inline float getTypeConfidence();
  inline void setTypeConfidence(float value);

  inline float getWidthConfidence();
  inline void setWidthConfidence(float value);

  inline bool hasStartPoint();
  inline  ::gac::rscl::Point2f::Builder getStartPoint();
  inline void setStartPoint( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initStartPoint();
  inline void adoptStartPoint(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownStartPoint();

  inline bool hasEndPoint();
  inline  ::gac::rscl::Point2f::Builder getEndPoint();
  inline void setEndPoint( ::gac::rscl::Point2f::Reader value);
  inline  ::gac::rscl::Point2f::Builder initEndPoint();
  inline void adoptEndPoint(::capnp::Orphan< ::gac::rscl::Point2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Point2f> disownEndPoint();

  inline bool hasImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getImagePoints();
  inline void setImagePoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initImagePoints();
  inline void adoptImagePoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownImagePoints();

  inline bool hasBvPoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getBvPoints();
  inline void setBvPoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initBvPoints();
  inline void adoptBvPoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownBvPoints();

  inline  ::int32_t getFittingType();
  inline void setFittingType( ::int32_t value);

  inline  ::int32_t getFittingOrder();
  inline void setFittingOrder( ::int32_t value);

  inline bool hasFittingCoefficients();
  inline  ::gac::rscl::VectorFloat::Builder getFittingCoefficients();
  inline void setFittingCoefficients( ::gac::rscl::VectorFloat::Reader value);
  inline  ::gac::rscl::VectorFloat::Builder initFittingCoefficients();
  inline void adoptFittingCoefficients(::capnp::Orphan< ::gac::rscl::VectorFloat>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorFloat> disownFittingCoefficients();

  inline bool hasCutPointVector();
  inline  ::gac::rscl::VectorInternalLanePoint2f::Builder getCutPointVector();
  inline void setCutPointVector( ::gac::rscl::VectorInternalLanePoint2f::Reader value);
  inline  ::gac::rscl::VectorInternalLanePoint2f::Builder initCutPointVector();
  inline void adoptCutPointVector(::capnp::Orphan< ::gac::rscl::VectorInternalLanePoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalLanePoint2f> disownCutPointVector();

  inline bool getIsLineJunctionValid();
  inline void setIsLineJunctionValid(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalLaneLine::Pipeline {
public:
  typedef InternalLaneLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::LaneWidth::Pipeline getLanelineWidth();
  inline  ::gac::rscl::Point2f::Pipeline getStartPoint();
  inline  ::gac::rscl::Point2f::Pipeline getEndPoint();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getBvPoints();
  inline  ::gac::rscl::VectorFloat::Pipeline getFittingCoefficients();
  inline  ::gac::rscl::VectorInternalLanePoint2f::Pipeline getCutPointVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalLaneLine::Reader {
public:
  typedef VectorInternalLaneLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalLaneLine::Builder {
public:
  typedef VectorInternalLaneLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalLaneLine::Pipeline {
public:
  typedef VectorInternalLaneLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalStopLine::Reader {
public:
  typedef InternalStopLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getImagePoints() const;

  inline bool hasBirdviewPoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getBirdviewPoints() const;

  inline float getConfidence() const;

  inline  ::uint32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalStopLine::Builder {
public:
  typedef InternalStopLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getImagePoints();
  inline void setImagePoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initImagePoints();
  inline void adoptImagePoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownImagePoints();

  inline bool hasBirdviewPoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getBirdviewPoints();
  inline void setBirdviewPoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initBirdviewPoints();
  inline void adoptBirdviewPoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownBirdviewPoints();

  inline float getConfidence();
  inline void setConfidence(float value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalStopLine::Pipeline {
public:
  typedef InternalStopLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint2f::Pipeline getImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getBirdviewPoints();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalStopLine::Reader {
public:
  typedef VectorInternalStopLine Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalStopLine::Builder {
public:
  typedef VectorInternalStopLine Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalStopLine::Pipeline {
public:
  typedef VectorInternalStopLine Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalBoundary::Reader {
public:
  typedef InternalBoundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getImagePoints() const;

  inline bool hasBirdviewPoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getBirdviewPoints() const;

  inline float getDirectionX() const;

  inline float getDirectionY() const;

  inline float getConfidence() const;

  inline bool getIsLine() const;

  inline  ::uint32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalBoundary::Builder {
public:
  typedef InternalBoundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getImagePoints();
  inline void setImagePoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initImagePoints();
  inline void adoptImagePoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownImagePoints();

  inline bool hasBirdviewPoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getBirdviewPoints();
  inline void setBirdviewPoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initBirdviewPoints();
  inline void adoptBirdviewPoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownBirdviewPoints();

  inline float getDirectionX();
  inline void setDirectionX(float value);

  inline float getDirectionY();
  inline void setDirectionY(float value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline bool getIsLine();
  inline void setIsLine(bool value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalBoundary::Pipeline {
public:
  typedef InternalBoundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint2f::Pipeline getImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getBirdviewPoints();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalBoundary::Reader {
public:
  typedef VectorInternalBoundary Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalBoundary::Builder {
public:
  typedef VectorInternalBoundary Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalBoundary::Pipeline {
public:
  typedef VectorInternalBoundary Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalTSR::Reader {
public:
  typedef InternalTSR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLabel() const;
  inline  ::gac::rscl::TrafficSignTypeInfo::Reader getLabel() const;

  inline bool hasBbox2d() const;
  inline  ::gac::rscl::ImageBbox2D::Reader getBbox2d() const;

  inline  ::uint32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalTSR::Builder {
public:
  typedef InternalTSR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLabel();
  inline  ::gac::rscl::TrafficSignTypeInfo::Builder getLabel();
  inline void setLabel( ::gac::rscl::TrafficSignTypeInfo::Reader value);
  inline  ::gac::rscl::TrafficSignTypeInfo::Builder initLabel();
  inline void adoptLabel(::capnp::Orphan< ::gac::rscl::TrafficSignTypeInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TrafficSignTypeInfo> disownLabel();

  inline bool hasBbox2d();
  inline  ::gac::rscl::ImageBbox2D::Builder getBbox2d();
  inline void setBbox2d( ::gac::rscl::ImageBbox2D::Reader value);
  inline  ::gac::rscl::ImageBbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> disownBbox2d();

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalTSR::Pipeline {
public:
  typedef InternalTSR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TrafficSignTypeInfo::Pipeline getLabel();
  inline  ::gac::rscl::ImageBbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalTLR::Reader {
public:
  typedef InternalTLR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLabel() const;
  inline  ::gac::rscl::TrafficLightSignal::Reader getLabel() const;

  inline bool hasBbox2d() const;
  inline  ::gac::rscl::ImageBbox2D::Reader getBbox2d() const;

  inline  ::uint32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalTLR::Builder {
public:
  typedef InternalTLR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLabel();
  inline  ::gac::rscl::TrafficLightSignal::Builder getLabel();
  inline void setLabel( ::gac::rscl::TrafficLightSignal::Reader value);
  inline  ::gac::rscl::TrafficLightSignal::Builder initLabel();
  inline void adoptLabel(::capnp::Orphan< ::gac::rscl::TrafficLightSignal>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TrafficLightSignal> disownLabel();

  inline bool hasBbox2d();
  inline  ::gac::rscl::ImageBbox2D::Builder getBbox2d();
  inline void setBbox2d( ::gac::rscl::ImageBbox2D::Reader value);
  inline  ::gac::rscl::ImageBbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> disownBbox2d();

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalTLR::Pipeline {
public:
  typedef InternalTLR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TrafficLightSignal::Pipeline getLabel();
  inline  ::gac::rscl::ImageBbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalTLR::Reader {
public:
  typedef VectorInternalTLR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalTLR::Builder {
public:
  typedef VectorInternalTLR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalTLR::Pipeline {
public:
  typedef VectorInternalTLR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalRoadMarker::Reader {
public:
  typedef InternalRoadMarker Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLabel() const;
  inline  ::gac::rscl::RoadMarkerTypeInfo::Reader getLabel() const;

  inline bool hasBbox2d() const;
  inline  ::gac::rscl::ImageBbox2D::Reader getBbox2d() const;

  inline  ::uint32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalRoadMarker::Builder {
public:
  typedef InternalRoadMarker Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLabel();
  inline  ::gac::rscl::RoadMarkerTypeInfo::Builder getLabel();
  inline void setLabel( ::gac::rscl::RoadMarkerTypeInfo::Reader value);
  inline  ::gac::rscl::RoadMarkerTypeInfo::Builder initLabel();
  inline void adoptLabel(::capnp::Orphan< ::gac::rscl::RoadMarkerTypeInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::RoadMarkerTypeInfo> disownLabel();

  inline bool hasBbox2d();
  inline  ::gac::rscl::ImageBbox2D::Builder getBbox2d();
  inline void setBbox2d( ::gac::rscl::ImageBbox2D::Reader value);
  inline  ::gac::rscl::ImageBbox2D::Builder initBbox2d();
  inline void adoptBbox2d(::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value);
  inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> disownBbox2d();

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalRoadMarker::Pipeline {
public:
  typedef InternalRoadMarker Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::RoadMarkerTypeInfo::Pipeline getLabel();
  inline  ::gac::rscl::ImageBbox2D::Pipeline getBbox2d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalRoadMarker::Reader {
public:
  typedef VectorInternalRoadMarker Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalRoadMarker::Builder {
public:
  typedef VectorInternalRoadMarker Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalRoadMarker::Pipeline {
public:
  typedef VectorInternalRoadMarker Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalRegion::Reader {
public:
  typedef InternalRegion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getRegionType() const;

  inline float getRegionTypeConfidence() const;

  inline  ::uint32_t getTrackId() const;

  inline bool hasRegionBoundary() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getRegionBoundary() const;

  inline bool hasJunctionPointVector() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getJunctionPointVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalRegion::Builder {
public:
  typedef InternalRegion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getRegionType();
  inline void setRegionType( ::uint8_t value);

  inline float getRegionTypeConfidence();
  inline void setRegionTypeConfidence(float value);

  inline  ::uint32_t getTrackId();
  inline void setTrackId( ::uint32_t value);

  inline bool hasRegionBoundary();
  inline  ::gac::rscl::VectorPoint2f::Builder getRegionBoundary();
  inline void setRegionBoundary( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initRegionBoundary();
  inline void adoptRegionBoundary(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownRegionBoundary();

  inline bool hasJunctionPointVector();
  inline  ::gac::rscl::VectorPoint2f::Builder getJunctionPointVector();
  inline void setJunctionPointVector( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initJunctionPointVector();
  inline void adoptJunctionPointVector(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownJunctionPointVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalRegion::Pipeline {
public:
  typedef InternalRegion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint2f::Pipeline getRegionBoundary();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getJunctionPointVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalRegion::Reader {
public:
  typedef VectorInternalRegion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalRegion::Builder {
public:
  typedef VectorInternalRegion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalRegion::Pipeline {
public:
  typedef VectorInternalRegion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalCrosswalk::Reader {
public:
  typedef InternalCrosswalk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getImagePoints() const;

  inline bool hasBirdviewPoints() const;
  inline  ::gac::rscl::VectorPoint2f::Reader getBirdviewPoints() const;

  inline float getLength() const;

  inline float getWidth() const;

  inline float getConfidence() const;

  inline  ::uint32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalCrosswalk::Builder {
public:
  typedef InternalCrosswalk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getImagePoints();
  inline void setImagePoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initImagePoints();
  inline void adoptImagePoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownImagePoints();

  inline bool hasBirdviewPoints();
  inline  ::gac::rscl::VectorPoint2f::Builder getBirdviewPoints();
  inline void setBirdviewPoints( ::gac::rscl::VectorPoint2f::Reader value);
  inline  ::gac::rscl::VectorPoint2f::Builder initBirdviewPoints();
  inline void adoptBirdviewPoints(::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> disownBirdviewPoints();

  inline float getLength();
  inline void setLength(float value);

  inline float getWidth();
  inline void setWidth(float value);

  inline float getConfidence();
  inline void setConfidence(float value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalCrosswalk::Pipeline {
public:
  typedef InternalCrosswalk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorPoint2f::Pipeline getImagePoints();
  inline  ::gac::rscl::VectorPoint2f::Pipeline getBirdviewPoints();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalTSR::Reader {
public:
  typedef VectorInternalTSR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalTSR::Builder {
public:
  typedef VectorInternalTSR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalTSR::Pipeline {
public:
  typedef VectorInternalTSR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalTSLR::Reader {
public:
  typedef InternalTSLR Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfo() const;
  inline  ::gac::rscl::HistInfo::Reader getHistInfo() const;

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline bool hasTsrVector() const;
  inline  ::gac::rscl::VectorInternalTSR::Reader getTsrVector() const;

  inline bool hasTlrVector() const;
  inline  ::gac::rscl::VectorInternalTLR::Reader getTlrVector() const;

  inline bool hasRoadMarkerVector() const;
  inline  ::gac::rscl::VectorInternalRoadMarker::Reader getRoadMarkerVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalTSLR::Builder {
public:
  typedef InternalTSLR Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfo();
  inline  ::gac::rscl::HistInfo::Builder getHistInfo();
  inline void setHistInfo( ::gac::rscl::HistInfo::Reader value);
  inline  ::gac::rscl::HistInfo::Builder initHistInfo();
  inline void adoptHistInfo(::capnp::Orphan< ::gac::rscl::HistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::HistInfo> disownHistInfo();

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline bool hasTsrVector();
  inline  ::gac::rscl::VectorInternalTSR::Builder getTsrVector();
  inline void setTsrVector( ::gac::rscl::VectorInternalTSR::Reader value);
  inline  ::gac::rscl::VectorInternalTSR::Builder initTsrVector();
  inline void adoptTsrVector(::capnp::Orphan< ::gac::rscl::VectorInternalTSR>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalTSR> disownTsrVector();

  inline bool hasTlrVector();
  inline  ::gac::rscl::VectorInternalTLR::Builder getTlrVector();
  inline void setTlrVector( ::gac::rscl::VectorInternalTLR::Reader value);
  inline  ::gac::rscl::VectorInternalTLR::Builder initTlrVector();
  inline void adoptTlrVector(::capnp::Orphan< ::gac::rscl::VectorInternalTLR>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalTLR> disownTlrVector();

  inline bool hasRoadMarkerVector();
  inline  ::gac::rscl::VectorInternalRoadMarker::Builder getRoadMarkerVector();
  inline void setRoadMarkerVector( ::gac::rscl::VectorInternalRoadMarker::Reader value);
  inline  ::gac::rscl::VectorInternalRoadMarker::Builder initRoadMarkerVector();
  inline void adoptRoadMarkerVector(::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker> disownRoadMarkerVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalTSLR::Pipeline {
public:
  typedef InternalTSLR Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::HistInfo::Pipeline getHistInfo();
  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorInternalTSR::Pipeline getTsrVector();
  inline  ::gac::rscl::VectorInternalTLR::Pipeline getTlrVector();
  inline  ::gac::rscl::VectorInternalRoadMarker::Pipeline getRoadMarkerVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VEDCheck::Reader {
public:
  typedef VEDCheck Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getType() const;

  inline bool hasVedAttributeVector() const;
  inline  ::gac::rscl::VectorVEDAttribute::Reader getVedAttributeVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VEDCheck::Builder {
public:
  typedef VEDCheck Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getType();
  inline void setType( ::uint32_t value);

  inline bool hasVedAttributeVector();
  inline  ::gac::rscl::VectorVEDAttribute::Builder getVedAttributeVector();
  inline void setVedAttributeVector( ::gac::rscl::VectorVEDAttribute::Reader value);
  inline  ::gac::rscl::VectorVEDAttribute::Builder initVedAttributeVector();
  inline void adoptVedAttributeVector(::capnp::Orphan< ::gac::rscl::VectorVEDAttribute>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorVEDAttribute> disownVedAttributeVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VEDCheck::Pipeline {
public:
  typedef VEDCheck Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::VectorVEDAttribute::Pipeline getVedAttributeVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VectorInternalCrosswalk::Reader {
public:
  typedef VectorInternalCrosswalk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VectorInternalCrosswalk::Builder {
public:
  typedef VectorInternalCrosswalk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VectorInternalCrosswalk::Pipeline {
public:
  typedef VectorInternalCrosswalk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalRoadStructure::Reader {
public:
  typedef InternalRoadStructure Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHistInfo() const;
  inline  ::gac::rscl::HistInfo::Reader getHistInfo() const;

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasLanelineVector() const;
  inline  ::gac::rscl::VectorInternalLaneLine::Reader getLanelineVector() const;

  inline bool hasBoundaryVector() const;
  inline  ::gac::rscl::VectorInternalBoundary::Reader getBoundaryVector() const;

  inline bool hasStoplineVector() const;
  inline  ::gac::rscl::VectorInternalStopLine::Reader getStoplineVector() const;

  inline bool hasCrosswalkVector() const;
  inline  ::gac::rscl::VectorInternalCrosswalk::Reader getCrosswalkVector() const;

  inline bool hasTsrVector() const;
  inline  ::gac::rscl::VectorInternalTSR::Reader getTsrVector() const;

  inline bool hasTlrVector() const;
  inline  ::gac::rscl::VectorInternalTLR::Reader getTlrVector() const;

  inline bool hasRoadMarkerVector() const;
  inline  ::gac::rscl::VectorInternalRoadMarker::Reader getRoadMarkerVector() const;

  inline bool hasRegionVector() const;
  inline  ::gac::rscl::VectorInternalRegion::Reader getRegionVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalRoadStructure::Builder {
public:
  typedef InternalRoadStructure Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHistInfo();
  inline  ::gac::rscl::HistInfo::Builder getHistInfo();
  inline void setHistInfo( ::gac::rscl::HistInfo::Reader value);
  inline  ::gac::rscl::HistInfo::Builder initHistInfo();
  inline void adoptHistInfo(::capnp::Orphan< ::gac::rscl::HistInfo>&& value);
  inline ::capnp::Orphan< ::gac::rscl::HistInfo> disownHistInfo();

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasLanelineVector();
  inline  ::gac::rscl::VectorInternalLaneLine::Builder getLanelineVector();
  inline void setLanelineVector( ::gac::rscl::VectorInternalLaneLine::Reader value);
  inline  ::gac::rscl::VectorInternalLaneLine::Builder initLanelineVector();
  inline void adoptLanelineVector(::capnp::Orphan< ::gac::rscl::VectorInternalLaneLine>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalLaneLine> disownLanelineVector();

  inline bool hasBoundaryVector();
  inline  ::gac::rscl::VectorInternalBoundary::Builder getBoundaryVector();
  inline void setBoundaryVector( ::gac::rscl::VectorInternalBoundary::Reader value);
  inline  ::gac::rscl::VectorInternalBoundary::Builder initBoundaryVector();
  inline void adoptBoundaryVector(::capnp::Orphan< ::gac::rscl::VectorInternalBoundary>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalBoundary> disownBoundaryVector();

  inline bool hasStoplineVector();
  inline  ::gac::rscl::VectorInternalStopLine::Builder getStoplineVector();
  inline void setStoplineVector( ::gac::rscl::VectorInternalStopLine::Reader value);
  inline  ::gac::rscl::VectorInternalStopLine::Builder initStoplineVector();
  inline void adoptStoplineVector(::capnp::Orphan< ::gac::rscl::VectorInternalStopLine>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalStopLine> disownStoplineVector();

  inline bool hasCrosswalkVector();
  inline  ::gac::rscl::VectorInternalCrosswalk::Builder getCrosswalkVector();
  inline void setCrosswalkVector( ::gac::rscl::VectorInternalCrosswalk::Reader value);
  inline  ::gac::rscl::VectorInternalCrosswalk::Builder initCrosswalkVector();
  inline void adoptCrosswalkVector(::capnp::Orphan< ::gac::rscl::VectorInternalCrosswalk>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalCrosswalk> disownCrosswalkVector();

  inline bool hasTsrVector();
  inline  ::gac::rscl::VectorInternalTSR::Builder getTsrVector();
  inline void setTsrVector( ::gac::rscl::VectorInternalTSR::Reader value);
  inline  ::gac::rscl::VectorInternalTSR::Builder initTsrVector();
  inline void adoptTsrVector(::capnp::Orphan< ::gac::rscl::VectorInternalTSR>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalTSR> disownTsrVector();

  inline bool hasTlrVector();
  inline  ::gac::rscl::VectorInternalTLR::Builder getTlrVector();
  inline void setTlrVector( ::gac::rscl::VectorInternalTLR::Reader value);
  inline  ::gac::rscl::VectorInternalTLR::Builder initTlrVector();
  inline void adoptTlrVector(::capnp::Orphan< ::gac::rscl::VectorInternalTLR>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalTLR> disownTlrVector();

  inline bool hasRoadMarkerVector();
  inline  ::gac::rscl::VectorInternalRoadMarker::Builder getRoadMarkerVector();
  inline void setRoadMarkerVector( ::gac::rscl::VectorInternalRoadMarker::Reader value);
  inline  ::gac::rscl::VectorInternalRoadMarker::Builder initRoadMarkerVector();
  inline void adoptRoadMarkerVector(::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker> disownRoadMarkerVector();

  inline bool hasRegionVector();
  inline  ::gac::rscl::VectorInternalRegion::Builder getRegionVector();
  inline void setRegionVector( ::gac::rscl::VectorInternalRegion::Reader value);
  inline  ::gac::rscl::VectorInternalRegion::Builder initRegionVector();
  inline void adoptRegionVector(::capnp::Orphan< ::gac::rscl::VectorInternalRegion>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalRegion> disownRegionVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalRoadStructure::Pipeline {
public:
  typedef InternalRoadStructure Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::HistInfo::Pipeline getHistInfo();
  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::VectorInternalLaneLine::Pipeline getLanelineVector();
  inline  ::gac::rscl::VectorInternalBoundary::Pipeline getBoundaryVector();
  inline  ::gac::rscl::VectorInternalStopLine::Pipeline getStoplineVector();
  inline  ::gac::rscl::VectorInternalCrosswalk::Pipeline getCrosswalkVector();
  inline  ::gac::rscl::VectorInternalTSR::Pipeline getTsrVector();
  inline  ::gac::rscl::VectorInternalTLR::Pipeline getTlrVector();
  inline  ::gac::rscl::VectorInternalRoadMarker::Pipeline getRoadMarkerVector();
  inline  ::gac::rscl::VectorInternalRegion::Pipeline getRegionVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FusionMap::Reader {
public:
  typedef FusionMap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline bool hasLinkVector() const;
  inline  ::gac::rscl::VectorLink::Reader getLinkVector() const;

  inline bool hasLaneVector() const;
  inline  ::gac::rscl::VectorLane::Reader getLaneVector() const;

  inline bool hasBoundaryVector() const;
  inline  ::gac::rscl::VectorBoundary::Reader getBoundaryVector() const;

  inline bool hasStoplineVector() const;
  inline  ::gac::rscl::VectorStopline::Reader getStoplineVector() const;

  inline bool hasMarkingVector() const;
  inline  ::gac::rscl::VectorMarking::Reader getMarkingVector() const;

  inline bool hasSignVector() const;
  inline  ::gac::rscl::VectorSign::Reader getSignVector() const;

  inline bool hasLightVector() const;
  inline  ::gac::rscl::VectorLight::Reader getLightVector() const;

  inline bool hasSafeIslandVector() const;
  inline  ::gac::rscl::VectorSafeIsland::Reader getSafeIslandVector() const;

  inline bool hasPedestrianCrossingVector() const;
  inline  ::gac::rscl::VectorPedestrianCrossing::Reader getPedestrianCrossingVector() const;

  inline bool hasBumplikeVector() const;
  inline  ::gac::rscl::VectorBumpLike::Reader getBumplikeVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FusionMap::Builder {
public:
  typedef FusionMap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline bool hasLinkVector();
  inline  ::gac::rscl::VectorLink::Builder getLinkVector();
  inline void setLinkVector( ::gac::rscl::VectorLink::Reader value);
  inline  ::gac::rscl::VectorLink::Builder initLinkVector();
  inline void adoptLinkVector(::capnp::Orphan< ::gac::rscl::VectorLink>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLink> disownLinkVector();

  inline bool hasLaneVector();
  inline  ::gac::rscl::VectorLane::Builder getLaneVector();
  inline void setLaneVector( ::gac::rscl::VectorLane::Reader value);
  inline  ::gac::rscl::VectorLane::Builder initLaneVector();
  inline void adoptLaneVector(::capnp::Orphan< ::gac::rscl::VectorLane>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLane> disownLaneVector();

  inline bool hasBoundaryVector();
  inline  ::gac::rscl::VectorBoundary::Builder getBoundaryVector();
  inline void setBoundaryVector( ::gac::rscl::VectorBoundary::Reader value);
  inline  ::gac::rscl::VectorBoundary::Builder initBoundaryVector();
  inline void adoptBoundaryVector(::capnp::Orphan< ::gac::rscl::VectorBoundary>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorBoundary> disownBoundaryVector();

  inline bool hasStoplineVector();
  inline  ::gac::rscl::VectorStopline::Builder getStoplineVector();
  inline void setStoplineVector( ::gac::rscl::VectorStopline::Reader value);
  inline  ::gac::rscl::VectorStopline::Builder initStoplineVector();
  inline void adoptStoplineVector(::capnp::Orphan< ::gac::rscl::VectorStopline>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorStopline> disownStoplineVector();

  inline bool hasMarkingVector();
  inline  ::gac::rscl::VectorMarking::Builder getMarkingVector();
  inline void setMarkingVector( ::gac::rscl::VectorMarking::Reader value);
  inline  ::gac::rscl::VectorMarking::Builder initMarkingVector();
  inline void adoptMarkingVector(::capnp::Orphan< ::gac::rscl::VectorMarking>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorMarking> disownMarkingVector();

  inline bool hasSignVector();
  inline  ::gac::rscl::VectorSign::Builder getSignVector();
  inline void setSignVector( ::gac::rscl::VectorSign::Reader value);
  inline  ::gac::rscl::VectorSign::Builder initSignVector();
  inline void adoptSignVector(::capnp::Orphan< ::gac::rscl::VectorSign>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSign> disownSignVector();

  inline bool hasLightVector();
  inline  ::gac::rscl::VectorLight::Builder getLightVector();
  inline void setLightVector( ::gac::rscl::VectorLight::Reader value);
  inline  ::gac::rscl::VectorLight::Builder initLightVector();
  inline void adoptLightVector(::capnp::Orphan< ::gac::rscl::VectorLight>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorLight> disownLightVector();

  inline bool hasSafeIslandVector();
  inline  ::gac::rscl::VectorSafeIsland::Builder getSafeIslandVector();
  inline void setSafeIslandVector( ::gac::rscl::VectorSafeIsland::Reader value);
  inline  ::gac::rscl::VectorSafeIsland::Builder initSafeIslandVector();
  inline void adoptSafeIslandVector(::capnp::Orphan< ::gac::rscl::VectorSafeIsland>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorSafeIsland> disownSafeIslandVector();

  inline bool hasPedestrianCrossingVector();
  inline  ::gac::rscl::VectorPedestrianCrossing::Builder getPedestrianCrossingVector();
  inline void setPedestrianCrossingVector( ::gac::rscl::VectorPedestrianCrossing::Reader value);
  inline  ::gac::rscl::VectorPedestrianCrossing::Builder initPedestrianCrossingVector();
  inline void adoptPedestrianCrossingVector(::capnp::Orphan< ::gac::rscl::VectorPedestrianCrossing>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorPedestrianCrossing> disownPedestrianCrossingVector();

  inline bool hasBumplikeVector();
  inline  ::gac::rscl::VectorBumpLike::Builder getBumplikeVector();
  inline void setBumplikeVector( ::gac::rscl::VectorBumpLike::Reader value);
  inline  ::gac::rscl::VectorBumpLike::Builder initBumplikeVector();
  inline void adoptBumplikeVector(::capnp::Orphan< ::gac::rscl::VectorBumpLike>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorBumpLike> disownBumplikeVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FusionMap::Pipeline {
public:
  typedef FusionMap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorLink::Pipeline getLinkVector();
  inline  ::gac::rscl::VectorLane::Pipeline getLaneVector();
  inline  ::gac::rscl::VectorBoundary::Pipeline getBoundaryVector();
  inline  ::gac::rscl::VectorStopline::Pipeline getStoplineVector();
  inline  ::gac::rscl::VectorMarking::Pipeline getMarkingVector();
  inline  ::gac::rscl::VectorSign::Pipeline getSignVector();
  inline  ::gac::rscl::VectorLight::Pipeline getLightVector();
  inline  ::gac::rscl::VectorSafeIsland::Pipeline getSafeIslandVector();
  inline  ::gac::rscl::VectorPedestrianCrossing::Pipeline getPedestrianCrossingVector();
  inline  ::gac::rscl::VectorBumpLike::Pipeline getBumplikeVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InternalPerceptionObject::Reader {
public:
  typedef InternalPerceptionObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline bool hasCoordinate() const;
  inline  ::gac::rscl::CoordinateSystem::Reader getCoordinate() const;

  inline bool hasSensorId() const;
  inline  ::gac::rscl::SensorId::Reader getSensorId() const;

  inline  ::uint32_t getObstacleNum() const;

  inline bool hasInternalObjectVector() const;
  inline  ::gac::rscl::VectorInternalObject::Reader getInternalObjectVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InternalPerceptionObject::Builder {
public:
  typedef InternalPerceptionObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline bool hasCoordinate();
  inline  ::gac::rscl::CoordinateSystem::Builder getCoordinate();
  inline void setCoordinate( ::gac::rscl::CoordinateSystem::Reader value);
  inline  ::gac::rscl::CoordinateSystem::Builder initCoordinate();
  inline void adoptCoordinate(::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> disownCoordinate();

  inline bool hasSensorId();
  inline  ::gac::rscl::SensorId::Builder getSensorId();
  inline void setSensorId( ::gac::rscl::SensorId::Reader value);
  inline  ::gac::rscl::SensorId::Builder initSensorId();
  inline void adoptSensorId(::capnp::Orphan< ::gac::rscl::SensorId>&& value);
  inline ::capnp::Orphan< ::gac::rscl::SensorId> disownSensorId();

  inline  ::uint32_t getObstacleNum();
  inline void setObstacleNum( ::uint32_t value);

  inline bool hasInternalObjectVector();
  inline  ::gac::rscl::VectorInternalObject::Builder getInternalObjectVector();
  inline void setInternalObjectVector( ::gac::rscl::VectorInternalObject::Reader value);
  inline  ::gac::rscl::VectorInternalObject::Builder initInternalObjectVector();
  inline void adoptInternalObjectVector(::capnp::Orphan< ::gac::rscl::VectorInternalObject>&& value);
  inline ::capnp::Orphan< ::gac::rscl::VectorInternalObject> disownInternalObjectVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InternalPerceptionObject::Pipeline {
public:
  typedef InternalPerceptionObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
  inline  ::gac::rscl::CoordinateSystem::Pipeline getCoordinate();
  inline  ::gac::rscl::SensorId::Pipeline getSensorId();
  inline  ::gac::rscl::VectorInternalObject::Pipeline getInternalObjectVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AppStatus::Reader {
public:
  typedef AppStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStatus() const;
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader getStatus() const;

  inline bool hasTimestamp() const;
  inline  ::gac::rscl::TimeStamp::Reader getTimestamp() const;

  inline  ::uint8_t getNodeId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AppStatus::Builder {
public:
  typedef AppStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStatus();
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder getStatus();
  inline void setStatus( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setStatus(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder initStatus(unsigned int size);
  inline void adoptStatus(::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> disownStatus();

  inline bool hasTimestamp();
  inline  ::gac::rscl::TimeStamp::Builder getTimestamp();
  inline void setTimestamp( ::gac::rscl::TimeStamp::Reader value);
  inline  ::gac::rscl::TimeStamp::Builder initTimestamp();
  inline void adoptTimestamp(::capnp::Orphan< ::gac::rscl::TimeStamp>&& value);
  inline ::capnp::Orphan< ::gac::rscl::TimeStamp> disownTimestamp();

  inline  ::uint8_t getNodeId();
  inline void setNodeId( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AppStatus::Pipeline {
public:
  typedef AppStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::TimeStamp::Pipeline getTimestamp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraHeader::Reader {
public:
  typedef CameraHeader Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSec() const;

  inline  ::uint32_t getNSec() const;

  inline  ::uint32_t getExpStartS() const;

  inline  ::uint32_t getExpStartNs() const;

  inline  ::uint32_t getExpEndS() const;

  inline  ::uint32_t getExpEndNs() const;

  inline  ::uint32_t getShutter1() const;

  inline  ::uint32_t getShutter2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraHeader::Builder {
public:
  typedef CameraHeader Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSec();
  inline void setSec( ::uint32_t value);

  inline  ::uint32_t getNSec();
  inline void setNSec( ::uint32_t value);

  inline  ::uint32_t getExpStartS();
  inline void setExpStartS( ::uint32_t value);

  inline  ::uint32_t getExpStartNs();
  inline void setExpStartNs( ::uint32_t value);

  inline  ::uint32_t getExpEndS();
  inline void setExpEndS( ::uint32_t value);

  inline  ::uint32_t getExpEndNs();
  inline void setExpEndNs( ::uint32_t value);

  inline  ::uint32_t getShutter1();
  inline void setShutter1( ::uint32_t value);

  inline  ::uint32_t getShutter2();
  inline void setShutter2( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraHeader::Pipeline {
public:
  typedef CameraHeader Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraHeaderMbuf::Reader {
public:
  typedef CameraHeaderMbuf Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSeq() const;

  inline bool hasStamp() const;
  inline  ::gac::rscl::CameraHeader::Reader getStamp() const;

  inline bool hasFrameId() const;
  inline  ::capnp::Text::Reader getFrameId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraHeaderMbuf::Builder {
public:
  typedef CameraHeaderMbuf Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSeq();
  inline void setSeq( ::uint32_t value);

  inline bool hasStamp();
  inline  ::gac::rscl::CameraHeader::Builder getStamp();
  inline void setStamp( ::gac::rscl::CameraHeader::Reader value);
  inline  ::gac::rscl::CameraHeader::Builder initStamp();
  inline void adoptStamp(::capnp::Orphan< ::gac::rscl::CameraHeader>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CameraHeader> disownStamp();

  inline bool hasFrameId();
  inline  ::capnp::Text::Builder getFrameId();
  inline void setFrameId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFrameId(unsigned int size);
  inline void adoptFrameId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFrameId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraHeaderMbuf::Pipeline {
public:
  typedef CameraHeaderMbuf Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::CameraHeader::Pipeline getStamp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraEncodeMbuf::Reader {
public:
  typedef CameraEncodeMbuf Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSendTimeHigh() const;

  inline  ::uint32_t getSendTimeLow() const;

  inline  ::uint32_t getFrameType() const;

  inline bool hasVideoFrame() const;
  inline  ::capnp::Text::Reader getVideoFrame() const;

  inline  ::uint32_t getDataSize() const;

  inline  ::uint32_t getAdapterId() const;

  inline bool hasCameraHeader() const;
  inline  ::gac::rscl::CameraHeaderMbuf::Reader getCameraHeader() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraEncodeMbuf::Builder {
public:
  typedef CameraEncodeMbuf Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSendTimeHigh();
  inline void setSendTimeHigh( ::uint32_t value);

  inline  ::uint32_t getSendTimeLow();
  inline void setSendTimeLow( ::uint32_t value);

  inline  ::uint32_t getFrameType();
  inline void setFrameType( ::uint32_t value);

  inline bool hasVideoFrame();
  inline  ::capnp::Text::Builder getVideoFrame();
  inline void setVideoFrame( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initVideoFrame(unsigned int size);
  inline void adoptVideoFrame(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownVideoFrame();

  inline  ::uint32_t getDataSize();
  inline void setDataSize( ::uint32_t value);

  inline  ::uint32_t getAdapterId();
  inline void setAdapterId( ::uint32_t value);

  inline bool hasCameraHeader();
  inline  ::gac::rscl::CameraHeaderMbuf::Builder getCameraHeader();
  inline void setCameraHeader( ::gac::rscl::CameraHeaderMbuf::Reader value);
  inline  ::gac::rscl::CameraHeaderMbuf::Builder initCameraHeader();
  inline void adoptCameraHeader(::capnp::Orphan< ::gac::rscl::CameraHeaderMbuf>&& value);
  inline ::capnp::Orphan< ::gac::rscl::CameraHeaderMbuf> disownCameraHeader();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraEncodeMbuf::Pipeline {
public:
  typedef CameraEncodeMbuf Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::CameraHeaderMbuf::Pipeline getCameraHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DiagReport::Reader {
public:
  typedef DiagReport Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getAppId() const;

  inline bool hasAlarmID() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getAlarmID() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DiagReport::Builder {
public:
  typedef DiagReport Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getAppId();
  inline void setAppId( ::uint32_t value);

  inline bool hasAlarmID();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getAlarmID();
  inline void setAlarmID( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setAlarmID(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initAlarmID(unsigned int size);
  inline void adoptAlarmID(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownAlarmID();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DiagReport::Pipeline {
public:
  typedef DiagReport Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool TimeStamp::Reader::getIsValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TimeStamp::Builder::getIsValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimeStamp::Builder::setIsValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TimeStamp::Reader::getSec() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TimeStamp::Builder::getSec() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TimeStamp::Builder::setSec( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TimeStamp::Reader::getNsec() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TimeStamp::Builder::getNsec() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TimeStamp::Builder::setNsec( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Point3d::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Point3d::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point3d::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Point3d::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Point3d::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point3d::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Point3d::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Point3d::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point3d::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t VISLIGHTSPOT::Reader::getLsSpotId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t VISLIGHTSPOT::Builder::getLsSpotId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VISLIGHTSPOT::Reader::getLsSpotCalssification() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VISLIGHTSPOT::Builder::getLsSpotCalssification() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotCalssification( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float VISLIGHTSPOT::Reader::getLsSpotLongpos() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float VISLIGHTSPOT::Builder::getLsSpotLongpos() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotLongpos(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float VISLIGHTSPOT::Reader::getLsSpotLeftangle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float VISLIGHTSPOT::Builder::getLsSpotLeftangle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotLeftangle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float VISLIGHTSPOT::Reader::getLsSpotRightangle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float VISLIGHTSPOT::Builder::getLsSpotRightangle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotRightangle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float VISLIGHTSPOT::Reader::getLsSpotTopangle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float VISLIGHTSPOT::Builder::getLsSpotTopangle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotTopangle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float VISLIGHTSPOT::Reader::getLsSpotBottomangle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float VISLIGHTSPOT::Builder::getLsSpotBottomangle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void VISLIGHTSPOT::Builder::setLsSpotBottomangle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool VectorVISLIGHTSPOT::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorVISLIGHTSPOT::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Reader VectorVISLIGHTSPOT::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Builder VectorVISLIGHTSPOT::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorVISLIGHTSPOT::Builder::setData( ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>::Builder VectorVISLIGHTSPOT::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorVISLIGHTSPOT::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>> VectorVISLIGHTSPOT::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VISLIGHTSPOT,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t PilotProcessState::Reader::getProcessIndex() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t PilotProcessState::Builder::getProcessIndex() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PilotProcessState::Builder::setProcessIndex( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PilotProcessState::Reader::getStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t PilotProcessState::Builder::getStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void PilotProcessState::Builder::setStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PilotProcessState::Reader::getVendor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t PilotProcessState::Builder::getVendor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void PilotProcessState::Builder::setVendor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool PilotProcessStateVector::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PilotProcessStateVector::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Reader PilotProcessStateVector::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Builder PilotProcessStateVector::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PilotProcessStateVector::Builder::setData( ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>::Builder PilotProcessStateVector::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PilotProcessStateVector::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>> PilotProcessStateVector::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PilotProcessState,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PilotProcessStates::Reader::hasPilotProcessStates() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PilotProcessStates::Builder::hasPilotProcessStates() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::PilotProcessStateVector::Reader PilotProcessStates::Reader::getPilotProcessStates() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::PilotProcessStateVector>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::PilotProcessStateVector::Builder PilotProcessStates::Builder::getPilotProcessStates() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::PilotProcessStateVector>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::PilotProcessStateVector::Pipeline PilotProcessStates::Pipeline::getPilotProcessStates() {
  return  ::gac::rscl::PilotProcessStateVector::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PilotProcessStates::Builder::setPilotProcessStates( ::gac::rscl::PilotProcessStateVector::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::PilotProcessStateVector>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::PilotProcessStateVector::Builder PilotProcessStates::Builder::initPilotProcessStates() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::PilotProcessStateVector>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PilotProcessStates::Builder::adoptPilotProcessStates(
    ::capnp::Orphan< ::gac::rscl::PilotProcessStateVector>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::PilotProcessStateVector>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::PilotProcessStateVector> PilotProcessStates::Builder::disownPilotProcessStates() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::PilotProcessStateVector>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SensorSWCTimeStamp::Reader::hasSensorTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SensorSWCTimeStamp::Builder::hasSensorTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader SensorSWCTimeStamp::Reader::getSensorTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder SensorSWCTimeStamp::Builder::getSensorTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline SensorSWCTimeStamp::Pipeline::getSensorTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SensorSWCTimeStamp::Builder::setSensorTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder SensorSWCTimeStamp::Builder::initSensorTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SensorSWCTimeStamp::Builder::adoptSensorTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> SensorSWCTimeStamp::Builder::disownSensorTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SensorSWCTimeStamp::Reader::hasSwcTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SensorSWCTimeStamp::Builder::hasSwcTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader SensorSWCTimeStamp::Reader::getSwcTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder SensorSWCTimeStamp::Builder::getSwcTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline SensorSWCTimeStamp::Pipeline::getSwcTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SensorSWCTimeStamp::Builder::setSwcTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder SensorSWCTimeStamp::Builder::initSwcTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SensorSWCTimeStamp::Builder::adoptSwcTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> SensorSWCTimeStamp::Builder::disownSwcTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t CoordinateSystem::Reader::getIndex() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t CoordinateSystem::Builder::getIndex() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CoordinateSystem::Builder::setIndex( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t SensorId::Reader::getIndex() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t SensorId::Builder::getIndex() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SensorId::Builder::setIndex( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HistInfo::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HistInfo::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader HistInfo::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder HistInfo::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline HistInfo::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HistInfo::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder HistInfo::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HistInfo::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> HistInfo::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t HistInfo::Reader::getObstacleId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t HistInfo::Builder::getObstacleId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HistInfo::Builder::setObstacleId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HistInfo::Reader::hasRawSensorCaptureTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool HistInfo::Builder::hasRawSensorCaptureTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader HistInfo::Reader::getRawSensorCaptureTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::getRawSensorCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline HistInfo::Pipeline::getRawSensorCaptureTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void HistInfo::Builder::setRawSensorCaptureTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::initRawSensorCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void HistInfo::Builder::adoptRawSensorCaptureTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> HistInfo::Builder::disownRawSensorCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool HistInfo::Reader::hasSensorPerceptionCaptureTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool HistInfo::Builder::hasSensorPerceptionCaptureTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader HistInfo::Reader::getSensorPerceptionCaptureTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::getSensorPerceptionCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline HistInfo::Pipeline::getSensorPerceptionCaptureTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void HistInfo::Builder::setSensorPerceptionCaptureTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::initSensorPerceptionCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void HistInfo::Builder::adoptSensorPerceptionCaptureTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> HistInfo::Builder::disownSensorPerceptionCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool HistInfo::Reader::hasSensorPerceptionOutputTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool HistInfo::Builder::hasSensorPerceptionOutputTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader HistInfo::Reader::getSensorPerceptionOutputTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::getSensorPerceptionOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline HistInfo::Pipeline::getSensorPerceptionOutputTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void HistInfo::Builder::setSensorPerceptionOutputTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::initSensorPerceptionOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void HistInfo::Builder::adoptSensorPerceptionOutputTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> HistInfo::Builder::disownSensorPerceptionOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool HistInfo::Reader::hasFusionCaptureTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool HistInfo::Builder::hasFusionCaptureTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader HistInfo::Reader::getFusionCaptureTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::getFusionCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline HistInfo::Pipeline::getFusionCaptureTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void HistInfo::Builder::setFusionCaptureTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::initFusionCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void HistInfo::Builder::adoptFusionCaptureTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> HistInfo::Builder::disownFusionCaptureTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool HistInfo::Reader::hasFusionOutputTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool HistInfo::Builder::hasFusionOutputTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader HistInfo::Reader::getFusionOutputTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::getFusionOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline HistInfo::Pipeline::getFusionOutputTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void HistInfo::Builder::setFusionOutputTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder HistInfo::Builder::initFusionOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void HistInfo::Builder::adoptFusionOutputTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> HistInfo::Builder::disownFusionOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool VectorHistInfo::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorHistInfo::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader VectorHistInfo::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder VectorHistInfo::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorHistInfo::Builder::setData( ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder VectorHistInfo::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorHistInfo::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>> VectorHistInfo::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t ObstacleTypeInfo::Reader::getType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t ObstacleTypeInfo::Builder::getType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ObstacleTypeInfo::Builder::setType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t ObstacleTypeInfo::Reader::getSubType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t ObstacleTypeInfo::Builder::getSubType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ObstacleTypeInfo::Builder::setSubType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RoadMarkerTypeInfo::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RoadMarkerTypeInfo::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RoadMarkerTypeInfo::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TrafficSignTypeInfo::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TrafficSignTypeInfo::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TrafficSignTypeInfo::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TrafficLightSignal::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TrafficLightSignal::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TrafficLightSignal::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TrafficLightSignal::Reader::getStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TrafficLightSignal::Builder::getStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TrafficLightSignal::Builder::setStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point2f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Point2f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point2f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Point2f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Point2f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point2f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LaneWidth::Reader::hasCutPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneWidth::Builder::hasCutPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader LaneWidth::Reader::getCutPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder LaneWidth::Builder::getCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline LaneWidth::Pipeline::getCutPoint() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LaneWidth::Builder::setCutPoint( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder LaneWidth::Builder::initCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneWidth::Builder::adoptCutPoint(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> LaneWidth::Builder::disownCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t LaneWidth::Reader::getWidth() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneWidth::Builder::getWidth() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LaneWidth::Builder::setWidth( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LaneWidth::Reader::getWidthLeft() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneWidth::Builder::getWidthLeft() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LaneWidth::Builder::setWidthLeft( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LaneWidth::Reader::getWidthRight() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneWidth::Builder::getWidthRight() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LaneWidth::Builder::setWidthRight( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool VectorPoint2f::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPoint2f::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Reader VectorPoint2f::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Builder VectorPoint2f::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPoint2f::Builder::setData( ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>::Builder VectorPoint2f::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPoint2f::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>> VectorPoint2f::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Point2d::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Point2d::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point2d::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Point2d::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Point2d::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point2d::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point3f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Point3f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point3f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Point3f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Point3f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point3f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point3f::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Point3f::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point3f::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool VectorPoint3f::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPoint3f::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader VectorPoint3f::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder VectorPoint3f::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPoint3f::Builder::setData( ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder VectorPoint3f::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPoint3f::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>> VectorPoint3f::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VEDAttribute::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VEDAttribute::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorSWCTimeStamp::Reader VEDAttribute::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorSWCTimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorSWCTimeStamp::Builder VEDAttribute::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorSWCTimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorSWCTimeStamp::Pipeline VEDAttribute::Pipeline::getTimestamp() {
  return  ::gac::rscl::SensorSWCTimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VEDAttribute::Builder::setTimestamp( ::gac::rscl::SensorSWCTimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorSWCTimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorSWCTimeStamp::Builder VEDAttribute::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorSWCTimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VEDAttribute::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::SensorSWCTimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorSWCTimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorSWCTimeStamp> VEDAttribute::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorSWCTimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VEDAttribute::Reader::hasEgoCarLinearVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VEDAttribute::Builder::hasEgoCarLinearVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3d::Reader VEDAttribute::Reader::getEgoCarLinearVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3d::Builder VEDAttribute::Builder::getEgoCarLinearVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3d::Pipeline VEDAttribute::Pipeline::getEgoCarLinearVelocity() {
  return  ::gac::rscl::Point3d::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void VEDAttribute::Builder::setEgoCarLinearVelocity( ::gac::rscl::Point3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3d::Builder VEDAttribute::Builder::initEgoCarLinearVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VEDAttribute::Builder::adoptEgoCarLinearVelocity(
    ::capnp::Orphan< ::gac::rscl::Point3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3d> VEDAttribute::Builder::disownEgoCarLinearVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VEDAttribute::Reader::hasEgoCarAngularVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool VEDAttribute::Builder::hasEgoCarAngularVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3d::Reader VEDAttribute::Reader::getEgoCarAngularVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3d::Builder VEDAttribute::Builder::getEgoCarAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3d::Pipeline VEDAttribute::Pipeline::getEgoCarAngularVelocity() {
  return  ::gac::rscl::Point3d::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void VEDAttribute::Builder::setEgoCarAngularVelocity( ::gac::rscl::Point3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3d::Builder VEDAttribute::Builder::initEgoCarAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void VEDAttribute::Builder::adoptEgoCarAngularVelocity(
    ::capnp::Orphan< ::gac::rscl::Point3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3d> VEDAttribute::Builder::disownEgoCarAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorPoint3d::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPoint3d::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Reader VectorPoint3d::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Builder VectorPoint3d::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPoint3d::Builder::setData( ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>::Builder VectorPoint3d::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPoint3d::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>> VectorPoint3d::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3d,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Vector2f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Vector2f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector2f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Vector2f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Vector2f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector2f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Vector2d::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Vector2d::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector2d::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Vector2d::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Vector2d::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector2d::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Vector3d::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Vector3d::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3d::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Vector3d::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Vector3d::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3d::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Vector3d::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Vector3d::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3d::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Quaterniond::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Quaterniond::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Quaterniond::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Quaterniond::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Quaterniond::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Quaterniond::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Quaterniond::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Quaterniond::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Quaterniond::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Quaterniond::Reader::getW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Quaterniond::Builder::getW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Quaterniond::Builder::setW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float Quaternionf::Reader::getQx() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Quaternionf::Builder::getQx() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Quaternionf::Builder::setQx(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Quaternionf::Reader::getQy() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Quaternionf::Builder::getQy() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Quaternionf::Builder::setQy(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Quaternionf::Reader::getQz() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Quaternionf::Builder::getQz() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Quaternionf::Builder::setQz(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Quaternionf::Reader::getQw() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float Quaternionf::Builder::getQw() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Quaternionf::Builder::setQw(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Pose3f::Reader::hasTranslation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pose3f::Builder::hasTranslation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader Pose3f::Reader::getTranslation() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder Pose3f::Builder::getTranslation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline Pose3f::Pipeline::getTranslation() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Pose3f::Builder::setTranslation( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder Pose3f::Builder::initTranslation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pose3f::Builder::adoptTranslation(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> Pose3f::Builder::disownTranslation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Pose3f::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Pose3f::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Quaternionf::Reader Pose3f::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaternionf>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Quaternionf::Builder Pose3f::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaternionf>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Quaternionf::Pipeline Pose3f::Pipeline::getRotation() {
  return  ::gac::rscl::Quaternionf::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Pose3f::Builder::setRotation( ::gac::rscl::Quaternionf::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaternionf>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Quaternionf::Builder Pose3f::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaternionf>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Pose3f::Builder::adoptRotation(
    ::capnp::Orphan< ::gac::rscl::Quaternionf>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaternionf>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Quaternionf> Pose3f::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaternionf>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Pose3d::Reader::hasTranslation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pose3d::Builder::hasTranslation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3d::Reader Pose3d::Reader::getTranslation() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3d::Builder Pose3d::Builder::getTranslation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3d::Pipeline Pose3d::Pipeline::getTranslation() {
  return  ::gac::rscl::Point3d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Pose3d::Builder::setTranslation( ::gac::rscl::Point3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3d::Builder Pose3d::Builder::initTranslation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pose3d::Builder::adoptTranslation(
    ::capnp::Orphan< ::gac::rscl::Point3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3d> Pose3d::Builder::disownTranslation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Pose3d::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Pose3d::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Quaterniond::Reader Pose3d::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Quaterniond::Builder Pose3d::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Quaterniond::Pipeline Pose3d::Pipeline::getRotation() {
  return  ::gac::rscl::Quaterniond::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Pose3d::Builder::setRotation( ::gac::rscl::Quaterniond::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Quaterniond::Builder Pose3d::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Pose3d::Builder::adoptRotation(
    ::capnp::Orphan< ::gac::rscl::Quaterniond>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Quaterniond> Pose3d::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Matrix3f::Reader::hasX() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix3f::Builder::hasX() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3f::Reader Matrix3f::Reader::getX() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3f::Builder Matrix3f::Builder::getX() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3f::Pipeline Matrix3f::Pipeline::getX() {
  return  ::gac::rscl::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Matrix3f::Builder::setX( ::gac::rscl::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3f::Builder Matrix3f::Builder::initX() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Matrix3f::Builder::adoptX(
    ::capnp::Orphan< ::gac::rscl::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3f> Matrix3f::Builder::disownX() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Matrix3f::Reader::hasY() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix3f::Builder::hasY() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3f::Reader Matrix3f::Reader::getY() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3f::Builder Matrix3f::Builder::getY() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3f::Pipeline Matrix3f::Pipeline::getY() {
  return  ::gac::rscl::Vector3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Matrix3f::Builder::setY( ::gac::rscl::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3f::Builder Matrix3f::Builder::initY() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Matrix3f::Builder::adoptY(
    ::capnp::Orphan< ::gac::rscl::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3f> Matrix3f::Builder::disownY() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Matrix3f::Reader::hasZ() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix3f::Builder::hasZ() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3f::Reader Matrix3f::Reader::getZ() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3f::Builder Matrix3f::Builder::getZ() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3f::Pipeline Matrix3f::Pipeline::getZ() {
  return  ::gac::rscl::Vector3f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Matrix3f::Builder::setZ( ::gac::rscl::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3f::Builder Matrix3f::Builder::initZ() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Matrix3f::Builder::adoptZ(
    ::capnp::Orphan< ::gac::rscl::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3f> Matrix3f::Builder::disownZ() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Matrix2f::Reader::hasX() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix2f::Builder::hasX() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader Matrix2f::Reader::getX() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder Matrix2f::Builder::getX() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline Matrix2f::Pipeline::getX() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Matrix2f::Builder::setX( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder Matrix2f::Builder::initX() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Matrix2f::Builder::adoptX(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> Matrix2f::Builder::disownX() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Matrix2f::Reader::hasY() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix2f::Builder::hasY() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader Matrix2f::Reader::getY() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder Matrix2f::Builder::getY() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline Matrix2f::Pipeline::getY() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Matrix2f::Builder::setY( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder Matrix2f::Builder::initY() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Matrix2f::Builder::adoptY(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> Matrix2f::Builder::disownY() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PathPoint::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PathPoint::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader PathPoint::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder PathPoint::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline PathPoint::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PathPoint::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder PathPoint::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PathPoint::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> PathPoint::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PathPoint::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PathPoint::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader PathPoint::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder PathPoint::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline PathPoint::Pipeline::getPosition() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PathPoint::Builder::setPosition( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder PathPoint::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PathPoint::Builder::adoptPosition(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> PathPoint::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float PathPoint::Reader::getHeadingAngle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float PathPoint::Builder::getHeadingAngle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PathPoint::Builder::setHeadingAngle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PathPoint::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool PathPoint::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader PathPoint::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder PathPoint::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline PathPoint::Pipeline::getVelocity() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void PathPoint::Builder::setVelocity( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder PathPoint::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void PathPoint::Builder::adoptVelocity(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> PathPoint::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorPathPoint::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPathPoint::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader VectorPathPoint::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder VectorPathPoint::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPathPoint::Builder::setData( ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder VectorPathPoint::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPathPoint::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>> VectorPathPoint::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ImageKeyPoint::Reader::hasPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ImageKeyPoint::Builder::hasPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2d::Reader ImageKeyPoint::Reader::getPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2d::Builder ImageKeyPoint::Builder::getPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2d::Pipeline ImageKeyPoint::Pipeline::getPoint() {
  return  ::gac::rscl::Point2d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ImageKeyPoint::Builder::setPoint( ::gac::rscl::Point2d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2d::Builder ImageKeyPoint::Builder::initPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ImageKeyPoint::Builder::adoptPoint(
    ::capnp::Orphan< ::gac::rscl::Point2d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2d> ImageKeyPoint::Builder::disownPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float ImageKeyPoint::Reader::getXVar() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float ImageKeyPoint::Builder::getXVar() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageKeyPoint::Builder::setXVar(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ImageKeyPoint::Reader::getYVar() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ImageKeyPoint::Builder::getYVar() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ImageKeyPoint::Builder::setYVar(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool ImageKeyPoint::Reader::getIsVisable() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool ImageKeyPoint::Builder::getIsVisable() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void ImageKeyPoint::Builder::setIsVisable(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool VectorImageKeyPoint::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorImageKeyPoint::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Reader VectorImageKeyPoint::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Builder VectorImageKeyPoint::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorImageKeyPoint::Builder::setData( ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>::Builder VectorImageKeyPoint::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorImageKeyPoint::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>> VectorImageKeyPoint::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ImageKeyPoint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float ImageBbox2D::Reader::getTopLeftX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float ImageBbox2D::Builder::getTopLeftX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageBbox2D::Builder::setTopLeftX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ImageBbox2D::Reader::getTopLeftY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ImageBbox2D::Builder::getTopLeftY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ImageBbox2D::Builder::setTopLeftY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ImageBbox2D::Reader::getBottomRightX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ImageBbox2D::Builder::getBottomRightX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ImageBbox2D::Builder::setBottomRightX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float ImageBbox2D::Reader::getBottomRightY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float ImageBbox2D::Builder::getBottomRightY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ImageBbox2D::Builder::setBottomRightY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool BirdViewBbox2D::Reader::hasCenterPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BirdViewBbox2D::Builder::hasCenterPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader BirdViewBbox2D::Reader::getCenterPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder BirdViewBbox2D::Builder::getCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline BirdViewBbox2D::Pipeline::getCenterPosition() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BirdViewBbox2D::Builder::setCenterPosition( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder BirdViewBbox2D::Builder::initCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BirdViewBbox2D::Builder::adoptCenterPosition(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> BirdViewBbox2D::Builder::disownCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float BirdViewBbox2D::Reader::getHeading() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float BirdViewBbox2D::Builder::getHeading() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BirdViewBbox2D::Builder::setHeading(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float BirdViewBbox2D::Reader::getLength() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float BirdViewBbox2D::Builder::getLength() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BirdViewBbox2D::Builder::setLength(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float BirdViewBbox2D::Reader::getWidth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float BirdViewBbox2D::Builder::getWidth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BirdViewBbox2D::Builder::setWidth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Bbox3D::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Bbox3D::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Pose3f::Reader Bbox3D::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Pose3f::Builder Bbox3D::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Pose3f::Pipeline Bbox3D::Pipeline::getPose() {
  return  ::gac::rscl::Pose3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Bbox3D::Builder::setPose( ::gac::rscl::Pose3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Pose3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Pose3f::Builder Bbox3D::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Bbox3D::Builder::adoptPose(
    ::capnp::Orphan< ::gac::rscl::Pose3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Pose3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Pose3f> Bbox3D::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Bbox3D::Reader::getWidth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Bbox3D::Builder::getWidth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Bbox3D::Builder::setWidth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Bbox3D::Reader::getHeight() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Bbox3D::Builder::getHeight() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Bbox3D::Builder::setHeight(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Bbox3D::Reader::getLength() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Bbox3D::Builder::getLength() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Bbox3D::Builder::setLength(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t IntervalInfo::Reader::getDataId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t IntervalInfo::Builder::getDataId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntervalInfo::Builder::setDataId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double IntervalInfo::Reader::getDataValue() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double IntervalInfo::Builder::getDataValue() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void IntervalInfo::Builder::setDataValue(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t IntervalInfo::Reader::getDataType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t IntervalInfo::Builder::getDataType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void IntervalInfo::Builder::setDataType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t IntervalInfo::Reader::getOffsetStyle() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t IntervalInfo::Builder::getOffsetStyle() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void IntervalInfo::Builder::setOffsetStyle( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline double IntervalInfo::Reader::getStartOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double IntervalInfo::Builder::getStartOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void IntervalInfo::Builder::setStartOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double IntervalInfo::Reader::getEndOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline double IntervalInfo::Builder::getEndOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void IntervalInfo::Builder::setEndOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool VectorIntervalInfo::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorIntervalInfo::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Reader VectorIntervalInfo::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Builder VectorIntervalInfo::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorIntervalInfo::Builder::setData( ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>::Builder VectorIntervalInfo::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorIntervalInfo::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>> VectorIntervalInfo::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::IntervalInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Point3dAttribute::Reader::hasPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Point3dAttribute::Builder::hasPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3d::Reader Point3dAttribute::Reader::getPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3d::Builder Point3dAttribute::Builder::getPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3d::Pipeline Point3dAttribute::Pipeline::getPoint() {
  return  ::gac::rscl::Point3d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Point3dAttribute::Builder::setPoint( ::gac::rscl::Point3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3d::Builder Point3dAttribute::Builder::initPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Point3dAttribute::Builder::adoptPoint(
    ::capnp::Orphan< ::gac::rscl::Point3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3d> Point3dAttribute::Builder::disownPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Point3dAttribute::Reader::getHeading() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Point3dAttribute::Builder::getHeading() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point3dAttribute::Builder::setHeading(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Point3dAttribute::Reader::getLateralSlope() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Point3dAttribute::Builder::getLateralSlope() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point3dAttribute::Builder::setLateralSlope(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Point3dAttribute::Reader::getLongitudinalSlope() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Point3dAttribute::Builder::getLongitudinalSlope() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point3dAttribute::Builder::setLongitudinalSlope(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Point3dAttribute::Reader::getCurvatureRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Point3dAttribute::Builder::getCurvatureRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Point3dAttribute::Builder::setCurvatureRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool VectorPoint3dAttribute::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPoint3dAttribute::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Reader VectorPoint3dAttribute::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Builder VectorPoint3dAttribute::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPoint3dAttribute::Builder::setData( ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>::Builder VectorPoint3dAttribute::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPoint3dAttribute::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>> VectorPoint3dAttribute::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3dAttribute,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t BoundaryIntervalInfo::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t BoundaryIntervalInfo::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t BoundaryIntervalInfo::Reader::getStyle() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t BoundaryIntervalInfo::Builder::getStyle() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setStyle( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t BoundaryIntervalInfo::Reader::getColor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t BoundaryIntervalInfo::Builder::getColor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setColor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t BoundaryIntervalInfo::Reader::getWidth() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t BoundaryIntervalInfo::Builder::getWidth() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setWidth( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BoundaryIntervalInfo::Reader::getLength() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BoundaryIntervalInfo::Builder::getLength() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setLength( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t BoundaryIntervalInfo::Reader::getConfidence() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t BoundaryIntervalInfo::Builder::getConfidence() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setConfidence( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t BoundaryIntervalInfo::Reader::getOffsetStyle() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t BoundaryIntervalInfo::Builder::getOffsetStyle() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setOffsetStyle( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline double BoundaryIntervalInfo::Reader::getStartOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double BoundaryIntervalInfo::Builder::getStartOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setStartOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double BoundaryIntervalInfo::Reader::getEndOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double BoundaryIntervalInfo::Builder::getEndOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void BoundaryIntervalInfo::Builder::setEndOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool VectorBoundaryIntervalInfo::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorBoundaryIntervalInfo::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Reader VectorBoundaryIntervalInfo::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Builder VectorBoundaryIntervalInfo::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorBoundaryIntervalInfo::Builder::setData( ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>::Builder VectorBoundaryIntervalInfo::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorBoundaryIntervalInfo::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>> VectorBoundaryIntervalInfo::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BoundaryIntervalInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorBirdViewBbox2D::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorBirdViewBbox2D::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Reader VectorBirdViewBbox2D::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Builder VectorBirdViewBbox2D::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorBirdViewBbox2D::Builder::setData( ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>::Builder VectorBirdViewBbox2D::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorBirdViewBbox2D::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>> VectorBirdViewBbox2D::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BirdViewBbox2D,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t SegmentInfo::Reader::getStartPointIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SegmentInfo::Builder::getStartPointIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SegmentInfo::Builder::setStartPointIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t SegmentInfo::Reader::getEndPointIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SegmentInfo::Builder::getEndPointIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SegmentInfo::Builder::setEndPointIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t SegmentInfo::Reader::getType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SegmentInfo::Builder::getType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void SegmentInfo::Builder::setType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool VectorSegmentInfo::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorSegmentInfo::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Reader VectorSegmentInfo::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Builder VectorSegmentInfo::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorSegmentInfo::Builder::setData( ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>::Builder VectorSegmentInfo::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorSegmentInfo::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>> VectorSegmentInfo::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SegmentInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FreespaceInterior::Reader::hasInteriorPolygon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FreespaceInterior::Builder::hasInteriorPolygon() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint3d::Reader FreespaceInterior::Reader::getInteriorPolygon() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint3d::Builder FreespaceInterior::Builder::getInteriorPolygon() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint3d::Pipeline FreespaceInterior::Pipeline::getInteriorPolygon() {
  return  ::gac::rscl::VectorPoint3d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FreespaceInterior::Builder::setInteriorPolygon( ::gac::rscl::VectorPoint3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint3d::Builder FreespaceInterior::Builder::initInteriorPolygon() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FreespaceInterior::Builder::adoptInteriorPolygon(
    ::capnp::Orphan< ::gac::rscl::VectorPoint3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint3d> FreespaceInterior::Builder::disownInteriorPolygon() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FreespaceInterior::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FreespaceInterior::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSegmentInfo::Reader FreespaceInterior::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSegmentInfo::Builder FreespaceInterior::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSegmentInfo::Pipeline FreespaceInterior::Pipeline::getSegments() {
  return  ::gac::rscl::VectorSegmentInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FreespaceInterior::Builder::setSegments( ::gac::rscl::VectorSegmentInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSegmentInfo::Builder FreespaceInterior::Builder::initSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FreespaceInterior::Builder::adoptSegments(
    ::capnp::Orphan< ::gac::rscl::VectorSegmentInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSegmentInfo> FreespaceInterior::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VectorFreespaceInterior::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorFreespaceInterior::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Reader VectorFreespaceInterior::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Builder VectorFreespaceInterior::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorFreespaceInterior::Builder::setData( ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>::Builder VectorFreespaceInterior::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorFreespaceInterior::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>> VectorFreespaceInterior::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceInterior,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FreespaceExterior::Reader::hasExteriorPolygon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FreespaceExterior::Builder::hasExteriorPolygon() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint3f::Reader FreespaceExterior::Reader::getExteriorPolygon() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint3f::Builder FreespaceExterior::Builder::getExteriorPolygon() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint3f::Pipeline FreespaceExterior::Pipeline::getExteriorPolygon() {
  return  ::gac::rscl::VectorPoint3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FreespaceExterior::Builder::setExteriorPolygon( ::gac::rscl::VectorPoint3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint3f::Builder FreespaceExterior::Builder::initExteriorPolygon() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FreespaceExterior::Builder::adoptExteriorPolygon(
    ::capnp::Orphan< ::gac::rscl::VectorPoint3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint3f> FreespaceExterior::Builder::disownExteriorPolygon() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FreespaceExterior::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FreespaceExterior::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSegmentInfo::Reader FreespaceExterior::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSegmentInfo::Builder FreespaceExterior::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSegmentInfo::Pipeline FreespaceExterior::Pipeline::getSegments() {
  return  ::gac::rscl::VectorSegmentInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FreespaceExterior::Builder::setSegments( ::gac::rscl::VectorSegmentInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSegmentInfo::Builder FreespaceExterior::Builder::initSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FreespaceExterior::Builder::adoptSegments(
    ::capnp::Orphan< ::gac::rscl::VectorSegmentInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSegmentInfo> FreespaceExterior::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSegmentInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FreespaceExterior::Reader::hasInteriorVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FreespaceExterior::Builder::hasInteriorVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorFreespaceInterior::Reader FreespaceExterior::Reader::getInteriorVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceInterior>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorFreespaceInterior::Builder FreespaceExterior::Builder::getInteriorVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceInterior>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorFreespaceInterior::Pipeline FreespaceExterior::Pipeline::getInteriorVector() {
  return  ::gac::rscl::VectorFreespaceInterior::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void FreespaceExterior::Builder::setInteriorVector( ::gac::rscl::VectorFreespaceInterior::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceInterior>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorFreespaceInterior::Builder FreespaceExterior::Builder::initInteriorVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceInterior>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FreespaceExterior::Builder::adoptInteriorVector(
    ::capnp::Orphan< ::gac::rscl::VectorFreespaceInterior>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceInterior>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorFreespaceInterior> FreespaceExterior::Builder::disownInteriorVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceInterior>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorFreespaceExterior::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorFreespaceExterior::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Reader VectorFreespaceExterior::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Builder VectorFreespaceExterior::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorFreespaceExterior::Builder::setData( ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>::Builder VectorFreespaceExterior::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorFreespaceExterior::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>> VectorFreespaceExterior::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::FreespaceExterior,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GeneralFreeSpace::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralFreeSpace::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader GeneralFreeSpace::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder GeneralFreeSpace::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline GeneralFreeSpace::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GeneralFreeSpace::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder GeneralFreeSpace::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GeneralFreeSpace::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> GeneralFreeSpace::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GeneralFreeSpace::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralFreeSpace::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader GeneralFreeSpace::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder GeneralFreeSpace::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline GeneralFreeSpace::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GeneralFreeSpace::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder GeneralFreeSpace::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GeneralFreeSpace::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> GeneralFreeSpace::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GeneralFreeSpace::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralFreeSpace::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader GeneralFreeSpace::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder GeneralFreeSpace::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline GeneralFreeSpace::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GeneralFreeSpace::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder GeneralFreeSpace::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GeneralFreeSpace::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> GeneralFreeSpace::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GeneralFreeSpace::Reader::hasFreespaceVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralFreeSpace::Builder::hasFreespaceVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorFreespaceExterior::Reader GeneralFreeSpace::Reader::getFreespaceVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceExterior>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorFreespaceExterior::Builder GeneralFreeSpace::Builder::getFreespaceVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceExterior>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorFreespaceExterior::Pipeline GeneralFreeSpace::Pipeline::getFreespaceVector() {
  return  ::gac::rscl::VectorFreespaceExterior::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void GeneralFreeSpace::Builder::setFreespaceVector( ::gac::rscl::VectorFreespaceExterior::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceExterior>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorFreespaceExterior::Builder GeneralFreeSpace::Builder::initFreespaceVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceExterior>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void GeneralFreeSpace::Builder::adoptFreespaceVector(
    ::capnp::Orphan< ::gac::rscl::VectorFreespaceExterior>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceExterior>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorFreespaceExterior> GeneralFreeSpace::Builder::disownFreespaceVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFreespaceExterior>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint8_t MapCoordinate::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MapCoordinate::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MapCoordinate::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t MapCoordinate::Reader::getZoneId() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MapCoordinate::Builder::getZoneId() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MapCoordinate::Builder::setZoneId( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t MapCoordinate::Reader::getSouthFlag() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MapCoordinate::Builder::getSouthFlag() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MapCoordinate::Builder::setSouthFlag( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool LocalLocalization::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader LocalLocalization::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder LocalLocalization::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline LocalLocalization::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder LocalLocalization::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> LocalLocalization::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasOutputTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasOutputTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader LocalLocalization::Reader::getOutputTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder LocalLocalization::Builder::getOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline LocalLocalization::Pipeline::getOutputTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setOutputTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder LocalLocalization::Builder::initOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptOutputTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> LocalLocalization::Builder::disownOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasParent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasParent() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader LocalLocalization::Reader::getParent() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder LocalLocalization::Builder::getParent() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline LocalLocalization::Pipeline::getParent() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setParent( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder LocalLocalization::Builder::initParent() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptParent(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> LocalLocalization::Builder::disownParent() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasChild() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasChild() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader LocalLocalization::Reader::getChild() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder LocalLocalization::Builder::getChild() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline LocalLocalization::Pipeline::getChild() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setChild( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder LocalLocalization::Builder::initChild() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptChild(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> LocalLocalization::Builder::disownChild() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint32_t LocalLocalization::Reader::getAccuracyLevel() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LocalLocalization::Builder::getAccuracyLevel() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LocalLocalization::Builder::setAccuracyLevel( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool LocalLocalization::Reader::hasLocalPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasLocalPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Pose3d::Reader LocalLocalization::Reader::getLocalPose() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3d>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Pose3d::Builder LocalLocalization::Builder::getLocalPose() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3d>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Pose3d::Pipeline LocalLocalization::Pipeline::getLocalPose() {
  return  ::gac::rscl::Pose3d::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setLocalPose( ::gac::rscl::Pose3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Pose3d>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Pose3d::Builder LocalLocalization::Builder::initLocalPose() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3d>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptLocalPose(
    ::capnp::Orphan< ::gac::rscl::Pose3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Pose3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Pose3d> LocalLocalization::Builder::disownLocalPose() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Pose3d>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasEgoCarAngularVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasEgoCarAngularVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader LocalLocalization::Reader::getEgoCarAngularVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::getEgoCarAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline LocalLocalization::Pipeline::getEgoCarAngularVelocity() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setEgoCarAngularVelocity( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::initEgoCarAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptEgoCarAngularVelocity(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> LocalLocalization::Builder::disownEgoCarAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasEgoCarLinearVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasEgoCarLinearVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader LocalLocalization::Reader::getEgoCarLinearVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::getEgoCarLinearVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline LocalLocalization::Pipeline::getEgoCarLinearVelocity() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setEgoCarLinearVelocity( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::initEgoCarLinearVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptEgoCarLinearVelocity(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> LocalLocalization::Builder::disownEgoCarLinearVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasEgoCarLinearAcceleration() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasEgoCarLinearAcceleration() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader LocalLocalization::Reader::getEgoCarLinearAcceleration() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::getEgoCarLinearAcceleration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline LocalLocalization::Pipeline::getEgoCarLinearAcceleration() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setEgoCarLinearAcceleration( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::initEgoCarLinearAcceleration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptEgoCarLinearAcceleration(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> LocalLocalization::Builder::disownEgoCarLinearAcceleration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasEgoCarToGroundRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasEgoCarToGroundRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Quaterniond::Reader LocalLocalization::Reader::getEgoCarToGroundRotation() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Quaterniond::Builder LocalLocalization::Builder::getEgoCarToGroundRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Quaterniond::Pipeline LocalLocalization::Pipeline::getEgoCarToGroundRotation() {
  return  ::gac::rscl::Quaterniond::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setEgoCarToGroundRotation( ::gac::rscl::Quaterniond::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Quaterniond::Builder LocalLocalization::Builder::initEgoCarToGroundRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptEgoCarToGroundRotation(
    ::capnp::Orphan< ::gac::rscl::Quaterniond>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Quaterniond> LocalLocalization::Builder::disownEgoCarToGroundRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasLocalTranslationCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasLocalTranslationCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader LocalLocalization::Reader::getLocalTranslationCovariance() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::getLocalTranslationCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline LocalLocalization::Pipeline::getLocalTranslationCovariance() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setLocalTranslationCovariance( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::initLocalTranslationCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptLocalTranslationCovariance(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> LocalLocalization::Builder::disownLocalTranslationCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool LocalLocalization::Reader::hasLocalRotationCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool LocalLocalization::Builder::hasLocalRotationCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader LocalLocalization::Reader::getLocalRotationCovariance() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::getLocalRotationCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline LocalLocalization::Pipeline::getLocalRotationCovariance() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(10));
}
#endif  // !CAPNP_LITE
inline void LocalLocalization::Builder::setLocalRotationCovariance( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder LocalLocalization::Builder::initLocalRotationCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void LocalLocalization::Builder::adoptLocalRotationCovariance(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> LocalLocalization::Builder::disownLocalRotationCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline  ::int32_t Point3I::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Point3I::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point3I::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Point3I::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Point3I::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point3I::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Point3I::Reader::getZ() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Point3I::Builder::getZ() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point3I::Builder::setZ( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MatchingResult::Reader::getLinkId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MatchingResult::Builder::getLinkId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLinkId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MatchingResult::Reader::getLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MatchingResult::Builder::getLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MatchingResult::Reader::getLongitudinalOffStart() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchingResult::Builder::getLongitudinalOffStart() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLongitudinalOffStart( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MatchingResult::Reader::getLongitudinalOffEnd() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchingResult::Builder::getLongitudinalOffEnd() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLongitudinalOffEnd( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float MatchingResult::Reader::getAccuracy() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float MatchingResult::Builder::getAccuracy() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setAccuracy(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MatchingResult::Reader::getRelativeHeading() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchingResult::Builder::getRelativeHeading() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setRelativeHeading( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MatchingResult::Reader::getLateralOffLeft() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchingResult::Builder::getLateralOffLeft() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLateralOffLeft( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MatchingResult::Reader::getLateralOffRight() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchingResult::Builder::getLateralOffRight() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLateralOffRight( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MatchingResult::Reader::getLateralOffMiddle() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MatchingResult::Builder::getLateralOffMiddle() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setLateralOffMiddle( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t MatchingResult::Reader::getProbobility() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<44>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MatchingResult::Builder::getProbobility() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<44>() * ::capnp::ELEMENTS);
}
inline void MatchingResult::Builder::setProbobility( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<44>() * ::capnp::ELEMENTS, value);
}

inline bool VectorMatchingResult::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorMatchingResult::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Reader VectorMatchingResult::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Builder VectorMatchingResult::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorMatchingResult::Builder::setData( ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>::Builder VectorMatchingResult::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorMatchingResult::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>> VectorMatchingResult::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::MatchingResult,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader GlobalLocalization::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder GlobalLocalization::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline GlobalLocalization::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder GlobalLocalization::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> GlobalLocalization::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasOutputTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasOutputTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader GlobalLocalization::Reader::getOutputTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder GlobalLocalization::Builder::getOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline GlobalLocalization::Pipeline::getOutputTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setOutputTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder GlobalLocalization::Builder::initOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptOutputTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> GlobalLocalization::Builder::disownOutputTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasParent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasParent() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::MapCoordinate::Reader GlobalLocalization::Reader::getParent() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::MapCoordinate::Builder GlobalLocalization::Builder::getParent() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::MapCoordinate::Pipeline GlobalLocalization::Pipeline::getParent() {
  return  ::gac::rscl::MapCoordinate::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setParent( ::gac::rscl::MapCoordinate::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::MapCoordinate::Builder GlobalLocalization::Builder::initParent() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptParent(
    ::capnp::Orphan< ::gac::rscl::MapCoordinate>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::MapCoordinate> GlobalLocalization::Builder::disownParent() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasChild() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasChild() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::MapCoordinate::Reader GlobalLocalization::Reader::getChild() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::MapCoordinate::Builder GlobalLocalization::Builder::getChild() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::MapCoordinate::Pipeline GlobalLocalization::Pipeline::getChild() {
  return  ::gac::rscl::MapCoordinate::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setChild( ::gac::rscl::MapCoordinate::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::MapCoordinate::Builder GlobalLocalization::Builder::initChild() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptChild(
    ::capnp::Orphan< ::gac::rscl::MapCoordinate>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::MapCoordinate> GlobalLocalization::Builder::disownChild() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::MapCoordinate>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3I::Reader GlobalLocalization::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3I>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3I::Builder GlobalLocalization::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3I>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3I::Pipeline GlobalLocalization::Pipeline::getPosition() {
  return  ::gac::rscl::Point3I::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setPosition( ::gac::rscl::Point3I::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3I>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3I::Builder GlobalLocalization::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3I>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptPosition(
    ::capnp::Orphan< ::gac::rscl::Point3I>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3I>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3I> GlobalLocalization::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3I>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Quaterniond::Reader GlobalLocalization::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Quaterniond::Builder GlobalLocalization::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Quaterniond::Pipeline GlobalLocalization::Pipeline::getRotation() {
  return  ::gac::rscl::Quaterniond::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setRotation( ::gac::rscl::Quaterniond::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Quaterniond::Builder GlobalLocalization::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptRotation(
    ::capnp::Orphan< ::gac::rscl::Quaterniond>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Quaterniond> GlobalLocalization::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Quaterniond>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasLocCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasLocCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader GlobalLocalization::Reader::getLocCovariance() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder GlobalLocalization::Builder::getLocCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline GlobalLocalization::Pipeline::getLocCovariance() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setLocCovariance( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder GlobalLocalization::Builder::initLocCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptLocCovariance(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> GlobalLocalization::Builder::disownLocCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool GlobalLocalization::Reader::hasPoseCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasPoseCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3d::Reader GlobalLocalization::Reader::getPoseCovariance() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3d::Builder GlobalLocalization::Builder::getPoseCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3d::Pipeline GlobalLocalization::Pipeline::getPoseCovariance() {
  return  ::gac::rscl::Vector3d::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setPoseCovariance( ::gac::rscl::Vector3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3d::Builder GlobalLocalization::Builder::initPoseCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptPoseCovariance(
    ::capnp::Orphan< ::gac::rscl::Vector3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3d> GlobalLocalization::Builder::disownPoseCovariance() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3d>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline  ::uint8_t GlobalLocalization::Reader::getStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GlobalLocalization::Builder::getStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GlobalLocalization::Builder::setStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t GlobalLocalization::Reader::getVehicleSpeed() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int16_t GlobalLocalization::Builder::getVehicleSpeed() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GlobalLocalization::Builder::setVehicleSpeed( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GlobalLocalization::Reader::getHeading() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GlobalLocalization::Builder::getHeading() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GlobalLocalization::Builder::setHeading( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool GlobalLocalization::Reader::getActived() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline bool GlobalLocalization::Builder::getActived() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void GlobalLocalization::Builder::setActived(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool GlobalLocalization::Reader::hasMatchingResults() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool GlobalLocalization::Builder::hasMatchingResults() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorMatchingResult::Reader GlobalLocalization::Reader::getMatchingResults() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMatchingResult>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorMatchingResult::Builder GlobalLocalization::Builder::getMatchingResults() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMatchingResult>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorMatchingResult::Pipeline GlobalLocalization::Pipeline::getMatchingResults() {
  return  ::gac::rscl::VectorMatchingResult::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void GlobalLocalization::Builder::setMatchingResults( ::gac::rscl::VectorMatchingResult::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorMatchingResult>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorMatchingResult::Builder GlobalLocalization::Builder::initMatchingResults() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMatchingResult>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void GlobalLocalization::Builder::adoptMatchingResults(
    ::capnp::Orphan< ::gac::rscl::VectorMatchingResult>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorMatchingResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorMatchingResult> GlobalLocalization::Builder::disownMatchingResults() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMatchingResult>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline float PredictPath::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float PredictPath::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PredictPath::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PredictPath::Reader::hasPathPointVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PredictPath::Builder::hasPathPointVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader PredictPath::Reader::getPathPointVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder PredictPath::Builder::getPathPointVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PredictPath::Builder::setPathPointVector( ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>::Builder PredictPath::Builder::initPathPointVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PredictPath::Builder::adoptPathPointVector(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>> PredictPath::Builder::disownPathPointVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PathPoint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorPredictPath::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPredictPath::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader VectorPredictPath::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder VectorPredictPath::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPredictPath::Builder::setData( ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder VectorPredictPath::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPredictPath::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>> VectorPredictPath::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader GeneralObstacle::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder GeneralObstacle::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::setHistInfoVector( ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>::Builder GeneralObstacle::Builder::initHistInfoVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GeneralObstacle::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>> GeneralObstacle::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::HistInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t GeneralObstacle::Reader::getObstacleId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t GeneralObstacle::Builder::getObstacleId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setObstacleId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::hasObstacleTypeInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasObstacleTypeInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ObstacleTypeInfo::Reader GeneralObstacle::Reader::getObstacleTypeInfo() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ObstacleTypeInfo::Builder GeneralObstacle::Builder::getObstacleTypeInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ObstacleTypeInfo::Pipeline GeneralObstacle::Pipeline::getObstacleTypeInfo() {
  return  ::gac::rscl::ObstacleTypeInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setObstacleTypeInfo( ::gac::rscl::ObstacleTypeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ObstacleTypeInfo::Builder GeneralObstacle::Builder::initObstacleTypeInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptObstacleTypeInfo(
    ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo> GeneralObstacle::Builder::disownObstacleTypeInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float GeneralObstacle::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getExistenceConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getExistenceConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setExistenceConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getClassConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getClassConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setClassConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::hasCenterPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasCenterPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader GeneralObstacle::Reader::getCenterPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder GeneralObstacle::Builder::getCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline GeneralObstacle::Pipeline::getCenterPosition() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setCenterPosition( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder GeneralObstacle::Builder::initCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptCenterPosition(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> GeneralObstacle::Builder::disownCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasAbsoluteVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasAbsoluteVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader GeneralObstacle::Reader::getAbsoluteVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder GeneralObstacle::Builder::getAbsoluteVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline GeneralObstacle::Pipeline::getAbsoluteVelocity() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setAbsoluteVelocity( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder GeneralObstacle::Builder::initAbsoluteVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptAbsoluteVelocity(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> GeneralObstacle::Builder::disownAbsoluteVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasRelativeVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasRelativeVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader GeneralObstacle::Reader::getRelativeVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder GeneralObstacle::Builder::getRelativeVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline GeneralObstacle::Pipeline::getRelativeVelocity() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setRelativeVelocity( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder GeneralObstacle::Builder::initRelativeVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptRelativeVelocity(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> GeneralObstacle::Builder::disownRelativeVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasAbsoluteAccelaration() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasAbsoluteAccelaration() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader GeneralObstacle::Reader::getAbsoluteAccelaration() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder GeneralObstacle::Builder::getAbsoluteAccelaration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline GeneralObstacle::Pipeline::getAbsoluteAccelaration() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setAbsoluteAccelaration( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder GeneralObstacle::Builder::initAbsoluteAccelaration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptAbsoluteAccelaration(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> GeneralObstacle::Builder::disownAbsoluteAccelaration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline float GeneralObstacle::Reader::getHeadingAngle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getHeadingAngle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setHeadingAngle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getHeadingAngularVelocity() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getHeadingAngularVelocity() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setHeadingAngularVelocity(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t GeneralObstacle::Reader::getMovingStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GeneralObstacle::Builder::getMovingStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setMovingStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getBbox3dWidth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getBbox3dWidth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setBbox3dWidth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getBbox3dHeight() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getBbox3dHeight() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setBbox3dHeight(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getBbox3dLength() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getBbox3dLength() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setBbox3dLength(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::hasCenterPositionCov() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasCenterPositionCov() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix2f::Reader GeneralObstacle::Reader::getCenterPositionCov() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix2f::Builder GeneralObstacle::Builder::getCenterPositionCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix2f::Pipeline GeneralObstacle::Pipeline::getCenterPositionCov() {
  return  ::gac::rscl::Matrix2f::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setCenterPositionCov( ::gac::rscl::Matrix2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix2f::Builder GeneralObstacle::Builder::initCenterPositionCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptCenterPositionCov(
    ::capnp::Orphan< ::gac::rscl::Matrix2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix2f> GeneralObstacle::Builder::disownCenterPositionCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasVelocityCov() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasVelocityCov() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix2f::Reader GeneralObstacle::Reader::getVelocityCov() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix2f::Builder GeneralObstacle::Builder::getVelocityCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix2f::Pipeline GeneralObstacle::Pipeline::getVelocityCov() {
  return  ::gac::rscl::Matrix2f::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setVelocityCov( ::gac::rscl::Matrix2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix2f::Builder GeneralObstacle::Builder::initVelocityCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptVelocityCov(
    ::capnp::Orphan< ::gac::rscl::Matrix2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix2f> GeneralObstacle::Builder::disownVelocityCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasAccelarationCov() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasAccelarationCov() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix2f::Reader GeneralObstacle::Reader::getAccelarationCov() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix2f::Builder GeneralObstacle::Builder::getAccelarationCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix2f::Pipeline GeneralObstacle::Pipeline::getAccelarationCov() {
  return  ::gac::rscl::Matrix2f::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setAccelarationCov( ::gac::rscl::Matrix2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix2f::Builder GeneralObstacle::Builder::initAccelarationCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptAccelarationCov(
    ::capnp::Orphan< ::gac::rscl::Matrix2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix2f> GeneralObstacle::Builder::disownAccelarationCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasSizeCov() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasSizeCov() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix3f::Reader GeneralObstacle::Reader::getSizeCov() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix3f::Builder GeneralObstacle::Builder::getSizeCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix3f::Pipeline GeneralObstacle::Pipeline::getSizeCov() {
  return  ::gac::rscl::Matrix3f::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void GeneralObstacle::Builder::setSizeCov( ::gac::rscl::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix3f::Builder GeneralObstacle::Builder::initSizeCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::adoptSizeCov(
    ::capnp::Orphan< ::gac::rscl::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix3f> GeneralObstacle::Builder::disownSizeCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline float GeneralObstacle::Reader::getHeadingAngleStd() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getHeadingAngleStd() {
  return _builder.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setHeadingAngleStd(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline float GeneralObstacle::Reader::getTrackingPeriod() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline float GeneralObstacle::Builder::getTrackingPeriod() {
  return _builder.getDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setTrackingPeriod(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::getIsMovable() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<200>() * ::capnp::ELEMENTS);
}

inline bool GeneralObstacle::Builder::getIsMovable() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<200>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setIsMovable(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<200>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::getIsHeadingToEgoCar() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<201>() * ::capnp::ELEMENTS);
}

inline bool GeneralObstacle::Builder::getIsHeadingToEgoCar() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<201>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setIsHeadingToEgoCar(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<201>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::getIsEverHeadingToEgoCar() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<202>() * ::capnp::ELEMENTS);
}

inline bool GeneralObstacle::Builder::getIsEverHeadingToEgoCar() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<202>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setIsEverHeadingToEgoCar(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<202>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t GeneralObstacle::Reader::getLampStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<26>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GeneralObstacle::Builder::getLampStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<26>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setLampStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<26>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t GeneralObstacle::Reader::getTrackingStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<27>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GeneralObstacle::Builder::getTrackingStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<27>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setTrackingStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<27>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t GeneralObstacle::Reader::getCutInStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GeneralObstacle::Builder::getCutInStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setCutInStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t GeneralObstacle::Reader::getCutOutStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<49>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GeneralObstacle::Builder::getCutOutStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<49>() * ::capnp::ELEMENTS);
}
inline void GeneralObstacle::Builder::setCutOutStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<49>() * ::capnp::ELEMENTS, value);
}

inline bool GeneralObstacle::Reader::hasPredictPathVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasPredictPathVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader GeneralObstacle::Reader::getPredictPathVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder GeneralObstacle::Builder::getPredictPathVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::setPredictPathVector( ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>::Builder GeneralObstacle::Builder::initPredictPathVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), size);
}
inline void GeneralObstacle::Builder::adoptPredictPathVector(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>> GeneralObstacle::Builder::disownPredictPathVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PredictPath,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool GeneralObstacle::Reader::hasPolygon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool GeneralObstacle::Builder::hasPolygon() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader GeneralObstacle::Reader::getPolygon() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder GeneralObstacle::Builder::getPolygon() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void GeneralObstacle::Builder::setPolygon( ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>::Builder GeneralObstacle::Builder::initPolygon(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), size);
}
inline void GeneralObstacle::Builder::adoptPolygon(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>> GeneralObstacle::Builder::disownPolygon() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Point3f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline bool VectorGeneralObstacle::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorGeneralObstacle::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader VectorGeneralObstacle::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder VectorGeneralObstacle::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorGeneralObstacle::Builder::setData( ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder VectorGeneralObstacle::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorGeneralObstacle::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>> VectorGeneralObstacle::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionObstacle::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FusionObstacle::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader FusionObstacle::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder FusionObstacle::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline FusionObstacle::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FusionObstacle::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder FusionObstacle::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FusionObstacle::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> FusionObstacle::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionObstacle::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FusionObstacle::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader FusionObstacle::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionObstacle::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline FusionObstacle::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FusionObstacle::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionObstacle::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FusionObstacle::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> FusionObstacle::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FusionObstacle::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FusionObstacle::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader FusionObstacle::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder FusionObstacle::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline FusionObstacle::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void FusionObstacle::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder FusionObstacle::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FusionObstacle::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> FusionObstacle::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint32_t FusionObstacle::Reader::getObstacleNum() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FusionObstacle::Builder::getObstacleNum() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FusionObstacle::Builder::setObstacleNum( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FusionObstacle::Reader::hasGeneralObstacleVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool FusionObstacle::Builder::hasGeneralObstacleVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader FusionObstacle::Reader::getGeneralObstacleVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder FusionObstacle::Builder::getGeneralObstacleVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void FusionObstacle::Builder::setGeneralObstacleVector( ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>::Builder FusionObstacle::Builder::initGeneralObstacleVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void FusionObstacle::Builder::adoptGeneralObstacleVector(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>> FusionObstacle::Builder::disownGeneralObstacleVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::GeneralObstacle,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VisionObstacleUint::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacleUint::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader VisionObstacleUint::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder VisionObstacleUint::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline VisionObstacleUint::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VisionObstacleUint::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder VisionObstacleUint::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VisionObstacleUint::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> VisionObstacleUint::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t VisionObstacleUint::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t VisionObstacleUint::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VisionObstacleUint::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacleUint::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ObstacleTypeInfo::Reader VisionObstacleUint::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ObstacleTypeInfo::Builder VisionObstacleUint::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ObstacleTypeInfo::Pipeline VisionObstacleUint::Pipeline::getType() {
  return  ::gac::rscl::ObstacleTypeInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void VisionObstacleUint::Builder::setType( ::gac::rscl::ObstacleTypeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ObstacleTypeInfo::Builder VisionObstacleUint::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VisionObstacleUint::Builder::adoptType(
    ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo> VisionObstacleUint::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float VisionObstacleUint::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionObstacleUint::Reader::getMovingStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionObstacleUint::Builder::getMovingStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setMovingStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getTrackingPeriod() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getTrackingPeriod() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setTrackingPeriod(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionObstacleUint::Reader::getTrackingStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionObstacleUint::Builder::getTrackingStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setTrackingStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool VisionObstacleUint::Reader::hasSize() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacleUint::Builder::hasSize() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3f::Reader VisionObstacleUint::Reader::getSize() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3f::Builder VisionObstacleUint::Builder::getSize() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3f::Pipeline VisionObstacleUint::Pipeline::getSize() {
  return  ::gac::rscl::Vector3f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void VisionObstacleUint::Builder::setSize( ::gac::rscl::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3f::Builder VisionObstacleUint::Builder::initSize() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void VisionObstacleUint::Builder::adoptSize(
    ::capnp::Orphan< ::gac::rscl::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3f> VisionObstacleUint::Builder::disownSize() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline float VisionObstacleUint::Reader::getLongitudinalPosition() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getLongitudinalPosition() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setLongitudinalPosition(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getLateralPosition() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getLateralPosition() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setLateralPosition(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getLongitudinalVelocity() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getLongitudinalVelocity() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setLongitudinalVelocity(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getLateralVelocity() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getLateralVelocity() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setLateralVelocity(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getLongitudinalAcceleration() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getLongitudinalAcceleration() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setLongitudinalAcceleration(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getLateralAcceleration() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getLateralAcceleration() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setLateralAcceleration(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline float VisionObstacleUint::Reader::getHeadingAngle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline float VisionObstacleUint::Builder::getHeadingAngle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void VisionObstacleUint::Builder::setHeadingAngle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline bool VisionObstacleUint::Reader::hasCenterPositionCov() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacleUint::Builder::hasCenterPositionCov() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix2f::Reader VisionObstacleUint::Reader::getCenterPositionCov() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix2f::Builder VisionObstacleUint::Builder::getCenterPositionCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix2f::Pipeline VisionObstacleUint::Pipeline::getCenterPositionCov() {
  return  ::gac::rscl::Matrix2f::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void VisionObstacleUint::Builder::setCenterPositionCov( ::gac::rscl::Matrix2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix2f::Builder VisionObstacleUint::Builder::initCenterPositionCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void VisionObstacleUint::Builder::adoptCenterPositionCov(
    ::capnp::Orphan< ::gac::rscl::Matrix2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix2f> VisionObstacleUint::Builder::disownCenterPositionCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VisionObstacleUint::Reader::hasVelocityCov() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacleUint::Builder::hasVelocityCov() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix2f::Reader VisionObstacleUint::Reader::getVelocityCov() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix2f::Builder VisionObstacleUint::Builder::getVelocityCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix2f::Pipeline VisionObstacleUint::Pipeline::getVelocityCov() {
  return  ::gac::rscl::Matrix2f::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void VisionObstacleUint::Builder::setVelocityCov( ::gac::rscl::Matrix2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix2f::Builder VisionObstacleUint::Builder::initVelocityCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void VisionObstacleUint::Builder::adoptVelocityCov(
    ::capnp::Orphan< ::gac::rscl::Matrix2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix2f> VisionObstacleUint::Builder::disownVelocityCov() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix2f>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool VectorVisionObstacleUint::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorVisionObstacleUint::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Reader VectorVisionObstacleUint::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Builder VectorVisionObstacleUint::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorVisionObstacleUint::Builder::setData( ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>::Builder VectorVisionObstacleUint::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorVisionObstacleUint::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>> VectorVisionObstacleUint::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VisionObstacleUint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VisionObstacle::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacle::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader VisionObstacle::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder VisionObstacle::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline VisionObstacle::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VisionObstacle::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder VisionObstacle::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VisionObstacle::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> VisionObstacle::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VisionObstacle::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacle::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader VisionObstacle::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder VisionObstacle::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline VisionObstacle::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void VisionObstacle::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder VisionObstacle::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VisionObstacle::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> VisionObstacle::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VisionObstacle::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacle::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader VisionObstacle::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder VisionObstacle::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline VisionObstacle::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void VisionObstacle::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder VisionObstacle::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void VisionObstacle::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> VisionObstacle::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint32_t VisionObstacle::Reader::getObstacleNum() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t VisionObstacle::Builder::getObstacleNum() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VisionObstacle::Builder::setObstacleNum( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VisionObstacle::Reader::hasVisionObstacleVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool VisionObstacle::Builder::hasVisionObstacleVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorVisionObstacleUint::Reader VisionObstacle::Reader::getVisionObstacleVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVisionObstacleUint>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorVisionObstacleUint::Builder VisionObstacle::Builder::getVisionObstacleVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVisionObstacleUint>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorVisionObstacleUint::Pipeline VisionObstacle::Pipeline::getVisionObstacleVector() {
  return  ::gac::rscl::VectorVisionObstacleUint::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void VisionObstacle::Builder::setVisionObstacleVector( ::gac::rscl::VectorVisionObstacleUint::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorVisionObstacleUint>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorVisionObstacleUint::Builder VisionObstacle::Builder::initVisionObstacleVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVisionObstacleUint>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void VisionObstacle::Builder::adoptVisionObstacleVector(
    ::capnp::Orphan< ::gac::rscl::VectorVisionObstacleUint>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorVisionObstacleUint>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorVisionObstacleUint> VisionObstacle::Builder::disownVisionObstacleVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVisionObstacleUint>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VectorFloat::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorFloat::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader VectorFloat::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder VectorFloat::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorFloat::Builder::setData( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void VectorFloat::Builder::setData(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder VectorFloat::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorFloat::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> VectorFloat::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalBBox2D::Reader::hasTopLeft() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalBBox2D::Builder::hasTopLeft() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalBBox2D::Reader::getTopLeft() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalBBox2D::Builder::getTopLeft() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalBBox2D::Pipeline::getTopLeft() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalBBox2D::Builder::setTopLeft( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalBBox2D::Builder::initTopLeft() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalBBox2D::Builder::adoptTopLeft(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalBBox2D::Builder::disownTopLeft() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalBBox2D::Reader::hasBottomRight() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalBBox2D::Builder::hasBottomRight() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalBBox2D::Reader::getBottomRight() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalBBox2D::Builder::getBottomRight() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalBBox2D::Pipeline::getBottomRight() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalBBox2D::Builder::setBottomRight( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalBBox2D::Builder::initBottomRight() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalBBox2D::Builder::adoptBottomRight(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalBBox2D::Builder::disownBottomRight() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float InternalBBox2D::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float InternalBBox2D::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalBBox2D::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool InternalBBox2D::Reader::getIsLeftSideTruncated() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool InternalBBox2D::Builder::getIsLeftSideTruncated() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void InternalBBox2D::Builder::setIsLeftSideTruncated(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool InternalBBox2D::Reader::getIsRightSideTruncated() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline bool InternalBBox2D::Builder::getIsRightSideTruncated() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void InternalBBox2D::Builder::setIsRightSideTruncated(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline bool InternalBBox2D::Reader::getIsTopSideTruncated() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}

inline bool InternalBBox2D::Builder::getIsTopSideTruncated() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}
inline void InternalBBox2D::Builder::setIsTopSideTruncated(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS, value);
}

inline bool InternalBBox2D::Reader::getIsBottomSideTruncated() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<35>() * ::capnp::ELEMENTS);
}

inline bool InternalBBox2D::Builder::getIsBottomSideTruncated() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<35>() * ::capnp::ELEMENTS);
}
inline void InternalBBox2D::Builder::setIsBottomSideTruncated(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<35>() * ::capnp::ELEMENTS, value);
}

inline bool CameraBBox2DInfo::Reader::hasRawDetectionBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraBBox2DInfo::Builder::hasRawDetectionBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::InternalBBox2D::Reader CameraBBox2DInfo::Reader::getRawDetectionBox() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::InternalBBox2D::Builder CameraBBox2DInfo::Builder::getRawDetectionBox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::InternalBBox2D::Pipeline CameraBBox2DInfo::Pipeline::getRawDetectionBox() {
  return  ::gac::rscl::InternalBBox2D::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CameraBBox2DInfo::Builder::setRawDetectionBox( ::gac::rscl::InternalBBox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::InternalBBox2D::Builder CameraBBox2DInfo::Builder::initRawDetectionBox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraBBox2DInfo::Builder::adoptRawDetectionBox(
    ::capnp::Orphan< ::gac::rscl::InternalBBox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::InternalBBox2D> CameraBBox2DInfo::Builder::disownRawDetectionBox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraBBox2DInfo::Reader::hasTrackedBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraBBox2DInfo::Builder::hasTrackedBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::InternalBBox2D::Reader CameraBBox2DInfo::Reader::getTrackedBox() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::InternalBBox2D::Builder CameraBBox2DInfo::Builder::getTrackedBox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::InternalBBox2D::Pipeline CameraBBox2DInfo::Pipeline::getTrackedBox() {
  return  ::gac::rscl::InternalBBox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CameraBBox2DInfo::Builder::setTrackedBox( ::gac::rscl::InternalBBox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::InternalBBox2D::Builder CameraBBox2DInfo::Builder::initTrackedBox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraBBox2DInfo::Builder::adoptTrackedBox(
    ::capnp::Orphan< ::gac::rscl::InternalBBox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::InternalBBox2D> CameraBBox2DInfo::Builder::disownTrackedBox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::InternalBBox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ModelOutputFeature::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ModelOutputFeature::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ModelOutputFeature::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ModelOutputFeature::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ModelOutputFeature::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ModelOutputFeature::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ModelOutputFeature::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ModelOutputFeature::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ModelOutputFeature::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ModelOutputFeature::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorFloat::Reader ModelOutputFeature::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorFloat::Builder ModelOutputFeature::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorFloat::Pipeline ModelOutputFeature::Pipeline::getValue() {
  return  ::gac::rscl::VectorFloat::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ModelOutputFeature::Builder::setValue( ::gac::rscl::VectorFloat::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorFloat::Builder ModelOutputFeature::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ModelOutputFeature::Builder::adoptValue(
    ::capnp::Orphan< ::gac::rscl::VectorFloat>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorFloat> ModelOutputFeature::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BaseCameraAttribute::Reader::getIsLandmarkValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool BaseCameraAttribute::Builder::getIsLandmarkValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BaseCameraAttribute::Builder::setIsLandmarkValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BaseCameraAttribute::Reader::hasLandmark() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BaseCameraAttribute::Builder::hasLandmark() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader BaseCameraAttribute::Reader::getLandmark() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder BaseCameraAttribute::Builder::getLandmark() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline BaseCameraAttribute::Pipeline::getLandmark() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BaseCameraAttribute::Builder::setLandmark( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder BaseCameraAttribute::Builder::initLandmark() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BaseCameraAttribute::Builder::adoptLandmark(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> BaseCameraAttribute::Builder::disownLandmark() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BaseCameraAttribute::Reader::hasLandmarkScores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BaseCameraAttribute::Builder::hasLandmarkScores() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorFloat::Reader BaseCameraAttribute::Reader::getLandmarkScores() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorFloat::Builder BaseCameraAttribute::Builder::getLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorFloat::Pipeline BaseCameraAttribute::Pipeline::getLandmarkScores() {
  return  ::gac::rscl::VectorFloat::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void BaseCameraAttribute::Builder::setLandmarkScores( ::gac::rscl::VectorFloat::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorFloat::Builder BaseCameraAttribute::Builder::initLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BaseCameraAttribute::Builder::adoptLandmarkScores(
    ::capnp::Orphan< ::gac::rscl::VectorFloat>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorFloat> BaseCameraAttribute::Builder::disownLandmarkScores() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BaseCameraAttribute::Reader::getIsDirectionValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool BaseCameraAttribute::Builder::getIsDirectionValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BaseCameraAttribute::Builder::setIsDirectionValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BaseCameraAttribute::Reader::hasViewportDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BaseCameraAttribute::Builder::hasViewportDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector2f::Reader BaseCameraAttribute::Reader::getViewportDirection() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector2f::Builder BaseCameraAttribute::Builder::getViewportDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector2f::Pipeline BaseCameraAttribute::Pipeline::getViewportDirection() {
  return  ::gac::rscl::Vector2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void BaseCameraAttribute::Builder::setViewportDirection( ::gac::rscl::Vector2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector2f::Builder BaseCameraAttribute::Builder::initViewportDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BaseCameraAttribute::Builder::adoptViewportDirection(
    ::capnp::Orphan< ::gac::rscl::Vector2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector2f> BaseCameraAttribute::Builder::disownViewportDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::int32_t AutomobileLightStatus::Reader::getLeftTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getLeftTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setLeftTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AutomobileLightStatus::Reader::getRightTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getRightTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setRightTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AutomobileLightStatus::Reader::getHazard() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getHazard() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setHazard( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AutomobileLightStatus::Reader::getBrake() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t AutomobileLightStatus::Builder::getBrake() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AutomobileLightStatus::Builder::setBrake( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Reader::getLeftTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Builder::getLeftTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NonAutomobileVehicleLightStatus::Builder::setLeftTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Reader::getRightTurn() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Builder::getRightTurn() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NonAutomobileVehicleLightStatus::Builder::setRightTurn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Reader::getBrake() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NonAutomobileVehicleLightStatus::Builder::getBrake() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NonAutomobileVehicleLightStatus::Builder::setBrake( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float DepthDetPoint::Reader::getNearestPointX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float DepthDetPoint::Builder::getNearestPointX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setNearestPointX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float DepthDetPoint::Reader::getDepthPointX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float DepthDetPoint::Builder::getDepthPointX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setDepthPointX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float DepthDetPoint::Reader::getDepthPointY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float DepthDetPoint::Builder::getDepthPointY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setDepthPointY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t DepthDetPoint::Reader::getOrientation() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t DepthDetPoint::Builder::getOrientation() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setOrientation( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t DepthDetPoint::Reader::getLabel() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t DepthDetPoint::Builder::getLabel() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void DepthDetPoint::Builder::setLabel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t DerivedType::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t DerivedType::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DerivedType::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BirdViewCorners::Reader::hasBvCorners() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BirdViewCorners::Builder::hasBvCorners() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint3f::Reader BirdViewCorners::Reader::getBvCorners() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint3f::Builder BirdViewCorners::Builder::getBvCorners() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint3f::Pipeline BirdViewCorners::Pipeline::getBvCorners() {
  return  ::gac::rscl::VectorPoint3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BirdViewCorners::Builder::setBvCorners( ::gac::rscl::VectorPoint3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint3f::Builder BirdViewCorners::Builder::initBvCorners() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BirdViewCorners::Builder::adoptBvCorners(
    ::capnp::Orphan< ::gac::rscl::VectorPoint3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint3f> BirdViewCorners::Builder::disownBvCorners() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BirdViewCorners::Reader::hasCornerConf() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BirdViewCorners::Builder::hasCornerConf() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorFloat::Reader BirdViewCorners::Reader::getCornerConf() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorFloat::Builder BirdViewCorners::Builder::getCornerConf() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorFloat::Pipeline BirdViewCorners::Pipeline::getCornerConf() {
  return  ::gac::rscl::VectorFloat::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void BirdViewCorners::Builder::setCornerConf( ::gac::rscl::VectorFloat::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorFloat::Builder BirdViewCorners::Builder::initCornerConf() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BirdViewCorners::Builder::adoptCornerConf(
    ::capnp::Orphan< ::gac::rscl::VectorFloat>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorFloat> BirdViewCorners::Builder::disownCornerConf() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VectorModelOutputFeature::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorModelOutputFeature::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Reader VectorModelOutputFeature::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Builder VectorModelOutputFeature::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorModelOutputFeature::Builder::setData( ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>::Builder VectorModelOutputFeature::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorModelOutputFeature::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>> VectorModelOutputFeature::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::ModelOutputFeature,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasTimeStamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasTimeStamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader InternalObject::Reader::getTimeStamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder InternalObject::Builder::getTimeStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline InternalObject::Pipeline::getTimeStamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setTimeStamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder InternalObject::Builder::initTimeStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptTimeStamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> InternalObject::Builder::disownTimeStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ObstacleTypeInfo::Reader InternalObject::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ObstacleTypeInfo::Builder InternalObject::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ObstacleTypeInfo::Pipeline InternalObject::Pipeline::getType() {
  return  ::gac::rscl::ObstacleTypeInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setType( ::gac::rscl::ObstacleTypeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ObstacleTypeInfo::Builder InternalObject::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptType(
    ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ObstacleTypeInfo> InternalObject::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ObstacleTypeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float InternalObject::Reader::getTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getExistenceConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getExistenceConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setExistenceConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader InternalObject::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder InternalObject::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline InternalObject::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder InternalObject::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> InternalObject::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint32_t InternalObject::Reader::getTrackId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalObject::Builder::getTrackId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t InternalObject::Reader::getTrackAgeS() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalObject::Builder::getTrackAgeS() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackAgeS( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasDerivedType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasDerivedType() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::DerivedType::Reader InternalObject::Reader::getDerivedType() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DerivedType>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::DerivedType::Builder InternalObject::Builder::getDerivedType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DerivedType>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::DerivedType::Pipeline InternalObject::Pipeline::getDerivedType() {
  return  ::gac::rscl::DerivedType::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setDerivedType( ::gac::rscl::DerivedType::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::DerivedType>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::DerivedType::Builder InternalObject::Builder::initDerivedType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DerivedType>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptDerivedType(
    ::capnp::Orphan< ::gac::rscl::DerivedType>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::DerivedType>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::DerivedType> InternalObject::Builder::disownDerivedType() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DerivedType>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader InternalObject::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline InternalObject::Pipeline::getPosition() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setPosition( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptPosition(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> InternalObject::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasPositionUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasPositionUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix3f::Reader InternalObject::Reader::getPositionUncertainty() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix3f::Builder InternalObject::Builder::getPositionUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix3f::Pipeline InternalObject::Pipeline::getPositionUncertainty() {
  return  ::gac::rscl::Matrix3f::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setPositionUncertainty( ::gac::rscl::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix3f::Builder InternalObject::Builder::initPositionUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptPositionUncertainty(
    ::capnp::Orphan< ::gac::rscl::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix3f> InternalObject::Builder::disownPositionUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasRelativeVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasRelativeVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader InternalObject::Reader::getRelativeVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::getRelativeVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline InternalObject::Pipeline::getRelativeVelocity() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setRelativeVelocity( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::initRelativeVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptRelativeVelocity(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> InternalObject::Builder::disownRelativeVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasRelativeVelocityUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasRelativeVelocityUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix3f::Reader InternalObject::Reader::getRelativeVelocityUncertainty() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix3f::Builder InternalObject::Builder::getRelativeVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix3f::Pipeline InternalObject::Pipeline::getRelativeVelocityUncertainty() {
  return  ::gac::rscl::Matrix3f::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setRelativeVelocityUncertainty( ::gac::rscl::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix3f::Builder InternalObject::Builder::initRelativeVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptRelativeVelocityUncertainty(
    ::capnp::Orphan< ::gac::rscl::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix3f> InternalObject::Builder::disownRelativeVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasAcceleration() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasAcceleration() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader InternalObject::Reader::getAcceleration() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::getAcceleration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline InternalObject::Pipeline::getAcceleration() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setAcceleration( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::initAcceleration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptAcceleration(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> InternalObject::Builder::disownAcceleration() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasAccelerationUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasAccelerationUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader InternalObject::Reader::getAccelerationUncertainty() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::getAccelerationUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline InternalObject::Pipeline::getAccelerationUncertainty() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setAccelerationUncertainty( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::initAccelerationUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptAccelerationUncertainty(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> InternalObject::Builder::disownAccelerationUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasAbsoluteVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasAbsoluteVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader InternalObject::Reader::getAbsoluteVelocity() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::getAbsoluteVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline InternalObject::Pipeline::getAbsoluteVelocity() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(10));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setAbsoluteVelocity( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::initAbsoluteVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptAbsoluteVelocity(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> InternalObject::Builder::disownAbsoluteVelocity() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasAbsoluteVelocityUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasAbsoluteVelocityUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader InternalObject::Reader::getAbsoluteVelocityUncertainty() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::getAbsoluteVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline InternalObject::Pipeline::getAbsoluteVelocityUncertainty() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(11));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setAbsoluteVelocityUncertainty( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder InternalObject::Builder::initAbsoluteVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptAbsoluteVelocityUncertainty(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> InternalObject::Builder::disownAbsoluteVelocityUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasCoutourPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasCoutourPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalObject::Reader::getCoutourPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::getCoutourPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalObject::Pipeline::getCoutourPosition() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(12));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setCoutourPosition( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::initCoutourPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptCoutourPosition(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalObject::Builder::disownCoutourPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasCoutourPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasCoutourPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalObject::Reader::getCoutourPoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalObject::Builder::getCoutourPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalObject::Pipeline::getCoutourPoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(13));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setCoutourPoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalObject::Builder::initCoutourPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptCoutourPoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalObject::Builder::disownCoutourPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}

inline float InternalObject::Reader::getHeightLowerSurface() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getHeightLowerSurface() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setHeightLowerSurface(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getHeightUpperSurface() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getHeightUpperSurface() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setHeightUpperSurface(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Vector3f::Reader InternalObject::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Vector3f::Builder InternalObject::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Vector3f::Pipeline InternalObject::Pipeline::getShape() {
  return  ::gac::rscl::Vector3f::Pipeline(_typeless.getPointerField(14));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setShape( ::gac::rscl::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Vector3f::Builder InternalObject::Builder::initShape() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptShape(
    ::capnp::Orphan< ::gac::rscl::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Vector3f> InternalObject::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasShapeUncertainty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasShapeUncertainty() {
  return !_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Matrix3f::Reader InternalObject::Reader::getShapeUncertainty() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Matrix3f::Builder InternalObject::Builder::getShapeUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::get(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Matrix3f::Pipeline InternalObject::Pipeline::getShapeUncertainty() {
  return  ::gac::rscl::Matrix3f::Pipeline(_typeless.getPointerField(15));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setShapeUncertainty( ::gac::rscl::Matrix3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Matrix3f::Builder InternalObject::Builder::initShapeUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::init(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptShapeUncertainty(
    ::capnp::Orphan< ::gac::rscl::Matrix3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Matrix3f> InternalObject::Builder::disownShapeUncertainty() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Matrix3f>::disown(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}

inline float InternalObject::Reader::getHeading() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getHeading() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setHeading(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getHeadingUncertainty() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getHeadingUncertainty() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setHeadingUncertainty(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalObject::Reader::getMaintenanceStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<36>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalObject::Builder::getMaintenanceStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<36>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setMaintenanceStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<36>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalObject::Reader::getOcclusionStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<37>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalObject::Builder::getOcclusionStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<37>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setOcclusionStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<37>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasBirdviewCorners() const {
  return !_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasBirdviewCorners() {
  return !_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::BirdViewCorners::Reader InternalObject::Reader::getBirdviewCorners() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewCorners>::get(_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::BirdViewCorners::Builder InternalObject::Builder::getBirdviewCorners() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewCorners>::get(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::BirdViewCorners::Pipeline InternalObject::Pipeline::getBirdviewCorners() {
  return  ::gac::rscl::BirdViewCorners::Pipeline(_typeless.getPointerField(16));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setBirdviewCorners( ::gac::rscl::BirdViewCorners::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewCorners>::set(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::BirdViewCorners::Builder InternalObject::Builder::initBirdviewCorners() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewCorners>::init(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptBirdviewCorners(
    ::capnp::Orphan< ::gac::rscl::BirdViewCorners>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewCorners>::adopt(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::BirdViewCorners> InternalObject::Builder::disownBirdviewCorners() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewCorners>::disown(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasFeature() const {
  return !_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasFeature() {
  return !_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorModelOutputFeature::Reader InternalObject::Reader::getFeature() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorModelOutputFeature>::get(_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorModelOutputFeature::Builder InternalObject::Builder::getFeature() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorModelOutputFeature>::get(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorModelOutputFeature::Pipeline InternalObject::Pipeline::getFeature() {
  return  ::gac::rscl::VectorModelOutputFeature::Pipeline(_typeless.getPointerField(17));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setFeature( ::gac::rscl::VectorModelOutputFeature::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorModelOutputFeature>::set(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorModelOutputFeature::Builder InternalObject::Builder::initFeature() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorModelOutputFeature>::init(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptFeature(
    ::capnp::Orphan< ::gac::rscl::VectorModelOutputFeature>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorModelOutputFeature>::adopt(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorModelOutputFeature> InternalObject::Builder::disownFeature() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorModelOutputFeature>::disown(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasCameraBboxInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasCameraBboxInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CameraBBox2DInfo::Reader InternalObject::Reader::getCameraBboxInfo() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraBBox2DInfo>::get(_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CameraBBox2DInfo::Builder InternalObject::Builder::getCameraBboxInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraBBox2DInfo>::get(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CameraBBox2DInfo::Pipeline InternalObject::Pipeline::getCameraBboxInfo() {
  return  ::gac::rscl::CameraBBox2DInfo::Pipeline(_typeless.getPointerField(18));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setCameraBboxInfo( ::gac::rscl::CameraBBox2DInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CameraBBox2DInfo>::set(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CameraBBox2DInfo::Builder InternalObject::Builder::initCameraBboxInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraBBox2DInfo>::init(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptCameraBboxInfo(
    ::capnp::Orphan< ::gac::rscl::CameraBBox2DInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CameraBBox2DInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CameraBBox2DInfo> InternalObject::Builder::disownCameraBboxInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraBBox2DInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasBaseCameraAttribute() const {
  return !_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasBaseCameraAttribute() {
  return !_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::BaseCameraAttribute::Reader InternalObject::Reader::getBaseCameraAttribute() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BaseCameraAttribute>::get(_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::BaseCameraAttribute::Builder InternalObject::Builder::getBaseCameraAttribute() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BaseCameraAttribute>::get(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::BaseCameraAttribute::Pipeline InternalObject::Pipeline::getBaseCameraAttribute() {
  return  ::gac::rscl::BaseCameraAttribute::Pipeline(_typeless.getPointerField(19));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setBaseCameraAttribute( ::gac::rscl::BaseCameraAttribute::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BaseCameraAttribute>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::BaseCameraAttribute::Builder InternalObject::Builder::initBaseCameraAttribute() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BaseCameraAttribute>::init(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptBaseCameraAttribute(
    ::capnp::Orphan< ::gac::rscl::BaseCameraAttribute>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BaseCameraAttribute>::adopt(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::BaseCameraAttribute> InternalObject::Builder::disownBaseCameraAttribute() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BaseCameraAttribute>::disown(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasAutomobileLightStatus() const {
  return !_reader.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasAutomobileLightStatus() {
  return !_builder.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::AutomobileLightStatus::Reader InternalObject::Reader::getAutomobileLightStatus() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::AutomobileLightStatus>::get(_reader.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::AutomobileLightStatus::Builder InternalObject::Builder::getAutomobileLightStatus() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::AutomobileLightStatus>::get(_builder.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::AutomobileLightStatus::Pipeline InternalObject::Pipeline::getAutomobileLightStatus() {
  return  ::gac::rscl::AutomobileLightStatus::Pipeline(_typeless.getPointerField(20));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setAutomobileLightStatus( ::gac::rscl::AutomobileLightStatus::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::AutomobileLightStatus>::set(_builder.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::AutomobileLightStatus::Builder InternalObject::Builder::initAutomobileLightStatus() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::AutomobileLightStatus>::init(_builder.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptAutomobileLightStatus(
    ::capnp::Orphan< ::gac::rscl::AutomobileLightStatus>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::AutomobileLightStatus>::adopt(_builder.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::AutomobileLightStatus> InternalObject::Builder::disownAutomobileLightStatus() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::AutomobileLightStatus>::disown(_builder.getPointerField(
      ::capnp::bounded<20>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasNonAutomobileLightStatus() const {
  return !_reader.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasNonAutomobileLightStatus() {
  return !_builder.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Reader InternalObject::Reader::getNonAutomobileLightStatus() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::NonAutomobileVehicleLightStatus>::get(_reader.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Builder InternalObject::Builder::getNonAutomobileLightStatus() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::NonAutomobileVehicleLightStatus>::get(_builder.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Pipeline InternalObject::Pipeline::getNonAutomobileLightStatus() {
  return  ::gac::rscl::NonAutomobileVehicleLightStatus::Pipeline(_typeless.getPointerField(21));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setNonAutomobileLightStatus( ::gac::rscl::NonAutomobileVehicleLightStatus::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::NonAutomobileVehicleLightStatus>::set(_builder.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::NonAutomobileVehicleLightStatus::Builder InternalObject::Builder::initNonAutomobileLightStatus() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::NonAutomobileVehicleLightStatus>::init(_builder.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptNonAutomobileLightStatus(
    ::capnp::Orphan< ::gac::rscl::NonAutomobileVehicleLightStatus>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::NonAutomobileVehicleLightStatus>::adopt(_builder.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::NonAutomobileVehicleLightStatus> InternalObject::Builder::disownNonAutomobileLightStatus() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::NonAutomobileVehicleLightStatus>::disown(_builder.getPointerField(
      ::capnp::bounded<21>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::getIsWithPed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<304>() * ::capnp::ELEMENTS);
}

inline bool InternalObject::Builder::getIsWithPed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<304>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setIsWithPed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<304>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasUpperBodyDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasUpperBodyDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalObject::Reader::getUpperBodyDirection() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::getUpperBodyDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalObject::Pipeline::getUpperBodyDirection() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(22));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setUpperBodyDirection( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::initUpperBodyDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptUpperBodyDirection(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalObject::Builder::disownUpperBodyDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<22>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasLowerBodyDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasLowerBodyDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalObject::Reader::getLowerBodyDirection() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::getLowerBodyDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalObject::Pipeline::getLowerBodyDirection() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(23));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setLowerBodyDirection( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::initLowerBodyDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptLowerBodyDirection(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalObject::Builder::disownLowerBodyDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<23>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::hasFaceDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasFaceDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalObject::Reader::getFaceDirection() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::getFaceDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalObject::Pipeline::getFaceDirection() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(24));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setFaceDirection( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalObject::Builder::initFaceDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptFaceDirection(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalObject::Builder::disownFaceDirection() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<24>() * ::capnp::POINTERS));
}

inline bool InternalObject::Reader::getIsOnBike() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<305>() * ::capnp::ELEMENTS);
}

inline bool InternalObject::Builder::getIsOnBike() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<305>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setIsOnBike(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<305>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasDepthPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasDepthPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::DepthDetPoint::Reader InternalObject::Reader::getDepthPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DepthDetPoint>::get(_reader.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::DepthDetPoint::Builder InternalObject::Builder::getDepthPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DepthDetPoint>::get(_builder.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::DepthDetPoint::Pipeline InternalObject::Pipeline::getDepthPoint() {
  return  ::gac::rscl::DepthDetPoint::Pipeline(_typeless.getPointerField(25));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setDepthPoint( ::gac::rscl::DepthDetPoint::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::DepthDetPoint>::set(_builder.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::DepthDetPoint::Builder InternalObject::Builder::initDepthPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DepthDetPoint>::init(_builder.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptDepthPoint(
    ::capnp::Orphan< ::gac::rscl::DepthDetPoint>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::DepthDetPoint>::adopt(_builder.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::DepthDetPoint> InternalObject::Builder::disownDepthPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::DepthDetPoint>::disown(_builder.getPointerField(
      ::capnp::bounded<25>() * ::capnp::POINTERS));
}

inline float InternalObject::Reader::getTrackRange() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTrackRange() {
  return _builder.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackRange(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getTrackRangeRate() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTrackRangeRate() {
  return _builder.getDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackRangeRate(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getTrackRangeAccelRate() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTrackRangeAccelRate() {
  return _builder.getDataField<float>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackRangeAccelRate(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getTrackRangeLatRate() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTrackRangeLatRate() {
  return _builder.getDataField<float>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackRangeLatRate(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline float InternalObject::Reader::getTrackLatRate() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTrackLatRate() {
  return _builder.getDataField<float>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackLatRate(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS).isNull();
}
inline bool InternalObject::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader InternalObject::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder InternalObject::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline InternalObject::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(26));
}
#endif  // !CAPNP_LITE
inline void InternalObject::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder InternalObject::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS));
}
inline void InternalObject::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> InternalObject::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<26>() * ::capnp::POINTERS));
}

inline float InternalObject::Reader::getTrackingPeriod() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline float InternalObject::Builder::getTrackingPeriod() {
  return _builder.getDataField<float>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackingPeriod(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::getIsMovable() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<306>() * ::capnp::ELEMENTS);
}

inline bool InternalObject::Builder::getIsMovable() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<306>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setIsMovable(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<306>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::getIsHeadingToEgoCar() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<307>() * ::capnp::ELEMENTS);
}

inline bool InternalObject::Builder::getIsHeadingToEgoCar() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<307>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setIsHeadingToEgoCar(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<307>() * ::capnp::ELEMENTS, value);
}

inline bool InternalObject::Reader::getIsEverHeadingToEgoCar() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<308>() * ::capnp::ELEMENTS);
}

inline bool InternalObject::Builder::getIsEverHeadingToEgoCar() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<308>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setIsEverHeadingToEgoCar(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<308>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalObject::Reader::getLampStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<39>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalObject::Builder::getLampStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<39>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setLampStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<39>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalObject::Reader::getTrackingStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalObject::Builder::getTrackingStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setTrackingStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t InternalObject::Reader::getMotionStatus() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}

inline  ::int8_t InternalObject::Builder::getMotionStatus() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setMotionStatus( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t InternalObject::Reader::getLaneAssignments() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}

inline  ::int8_t InternalObject::Builder::getLaneAssignments() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}
inline void InternalObject::Builder::setLaneAssignments( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalObject::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalObject::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Reader VectorInternalObject::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Builder VectorInternalObject::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalObject::Builder::setData( ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>::Builder VectorInternalObject::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalObject::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>> VectorInternalObject::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalObject,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorSensorSWCTimeStamp::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorSensorSWCTimeStamp::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Reader VectorSensorSWCTimeStamp::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Builder VectorSensorSWCTimeStamp::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorSensorSWCTimeStamp::Builder::setData( ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>::Builder VectorSensorSWCTimeStamp::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorSensorSWCTimeStamp::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>> VectorSensorSWCTimeStamp::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SensorSWCTimeStamp,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t TimeStampGap::Reader::getType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TimeStampGap::Builder::getType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimeStampGap::Builder::setType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TimeStampGap::Reader::hasSensorTimestampVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeStampGap::Builder::hasSensorTimestampVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSensorSWCTimeStamp::Reader TimeStampGap::Reader::getSensorTimestampVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSensorSWCTimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSensorSWCTimeStamp::Builder TimeStampGap::Builder::getSensorTimestampVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSensorSWCTimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSensorSWCTimeStamp::Pipeline TimeStampGap::Pipeline::getSensorTimestampVector() {
  return  ::gac::rscl::VectorSensorSWCTimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TimeStampGap::Builder::setSensorTimestampVector( ::gac::rscl::VectorSensorSWCTimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSensorSWCTimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSensorSWCTimeStamp::Builder TimeStampGap::Builder::initSensorTimestampVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSensorSWCTimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeStampGap::Builder::adoptSensorTimestampVector(
    ::capnp::Orphan< ::gac::rscl::VectorSensorSWCTimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSensorSWCTimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSensorSWCTimeStamp> TimeStampGap::Builder::disownSensorTimestampVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSensorSWCTimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorVEDAttribute::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorVEDAttribute::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Reader VectorVEDAttribute::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Builder VectorVEDAttribute::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorVEDAttribute::Builder::setData( ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>::Builder VectorVEDAttribute::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorVEDAttribute::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>> VectorVEDAttribute::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::VEDAttribute,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LightSpot::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LightSpot::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader LightSpot::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder LightSpot::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline LightSpot::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LightSpot::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder LightSpot::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LightSpot::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> LightSpot::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LightSpot::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LightSpot::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader LightSpot::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder LightSpot::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline LightSpot::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void LightSpot::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder LightSpot::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LightSpot::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> LightSpot::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LightSpot::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LightSpot::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader LightSpot::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder LightSpot::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline LightSpot::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void LightSpot::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder LightSpot::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LightSpot::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> LightSpot::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint8_t LightSpot::Reader::getLsDayTimeStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LightSpot::Builder::getLsDayTimeStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LightSpot::Builder::setLsDayTimeStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LightSpot::Reader::getLsTunnelAreaDetection() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LightSpot::Builder::getLsTunnelAreaDetection() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LightSpot::Builder::setLsTunnelAreaDetection( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LightSpot::Reader::getLsSpotsNumber() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LightSpot::Builder::getLsSpotsNumber() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LightSpot::Builder::setLsSpotsNumber( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LightSpot::Reader::hasLightSpotVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LightSpot::Builder::hasLightSpotVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorVISLIGHTSPOT::Reader LightSpot::Reader::getLightSpotVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVISLIGHTSPOT>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorVISLIGHTSPOT::Builder LightSpot::Builder::getLightSpotVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVISLIGHTSPOT>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorVISLIGHTSPOT::Pipeline LightSpot::Pipeline::getLightSpotVector() {
  return  ::gac::rscl::VectorVISLIGHTSPOT::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void LightSpot::Builder::setLightSpotVector( ::gac::rscl::VectorVISLIGHTSPOT::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorVISLIGHTSPOT>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorVISLIGHTSPOT::Builder LightSpot::Builder::initLightSpotVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVISLIGHTSPOT>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LightSpot::Builder::adoptLightSpotVector(
    ::capnp::Orphan< ::gac::rscl::VectorVISLIGHTSPOT>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorVISLIGHTSPOT>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorVISLIGHTSPOT> LightSpot::Builder::disownLightSpotVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVISLIGHTSPOT>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VisionOdd::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VisionOdd::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader VisionOdd::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder VisionOdd::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline VisionOdd::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VisionOdd::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder VisionOdd::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VisionOdd::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> VisionOdd::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VisionOdd::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VisionOdd::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader VisionOdd::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder VisionOdd::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline VisionOdd::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void VisionOdd::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder VisionOdd::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VisionOdd::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> VisionOdd::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t VisionOdd::Reader::getWeatherInfo() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionOdd::Builder::getWeatherInfo() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VisionOdd::Builder::setWeatherInfo( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionOdd::Reader::getVisibleDistance() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionOdd::Builder::getVisibleDistance() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VisionOdd::Builder::setVisibleDistance( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionOdd::Reader::getEnvironmentLightStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionOdd::Builder::getEnvironmentLightStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void VisionOdd::Builder::setEnvironmentLightStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionOdd::Reader::getRainfallInfo() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionOdd::Builder::getRainfallInfo() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void VisionOdd::Builder::setRainfallInfo( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionOdd::Reader::getTollgateStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionOdd::Builder::getTollgateStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void VisionOdd::Builder::setTollgateStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t VisionOdd::Reader::getRoadCondition() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t VisionOdd::Builder::getRoadCondition() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void VisionOdd::Builder::setRoadCondition( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool CameraTSLRObject::Reader::hasKeypoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraTSLRObject::Builder::hasKeypoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorImageKeyPoint::Reader CameraTSLRObject::Reader::getKeypoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorImageKeyPoint>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorImageKeyPoint::Builder CameraTSLRObject::Builder::getKeypoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorImageKeyPoint>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorImageKeyPoint::Pipeline CameraTSLRObject::Pipeline::getKeypoints() {
  return  ::gac::rscl::VectorImageKeyPoint::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CameraTSLRObject::Builder::setKeypoints( ::gac::rscl::VectorImageKeyPoint::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorImageKeyPoint>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorImageKeyPoint::Builder CameraTSLRObject::Builder::initKeypoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorImageKeyPoint>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraTSLRObject::Builder::adoptKeypoints(
    ::capnp::Orphan< ::gac::rscl::VectorImageKeyPoint>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorImageKeyPoint>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorImageKeyPoint> CameraTSLRObject::Builder::disownKeypoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorImageKeyPoint>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t CameraTSLRObject::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t CameraTSLRObject::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CameraTSLRObject::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float CameraTSLRObject::Reader::getClassConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float CameraTSLRObject::Builder::getClassConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CameraTSLRObject::Builder::setClassConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool CameraTSLRObject::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraTSLRObject::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ImageBbox2D::Reader CameraTSLRObject::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ImageBbox2D::Builder CameraTSLRObject::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ImageBbox2D::Pipeline CameraTSLRObject::Pipeline::getBbox2d() {
  return  ::gac::rscl::ImageBbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CameraTSLRObject::Builder::setBbox2d( ::gac::rscl::ImageBbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ImageBbox2D::Builder CameraTSLRObject::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraTSLRObject::Builder::adoptBbox2d(
    ::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> CameraTSLRObject::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VectorCameraTSLRObject::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorCameraTSLRObject::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Reader VectorCameraTSLRObject::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Builder VectorCameraTSLRObject::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorCameraTSLRObject::Builder::setData( ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>::Builder VectorCameraTSLRObject::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorCameraTSLRObject::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>> VectorCameraTSLRObject::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::CameraTSLRObject,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraTSLR::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraTSLR::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader CameraTSLR::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder CameraTSLR::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline CameraTSLR::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CameraTSLR::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder CameraTSLR::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraTSLR::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> CameraTSLR::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraTSLR::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraTSLR::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader CameraTSLR::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder CameraTSLR::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline CameraTSLR::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CameraTSLR::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder CameraTSLR::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraTSLR::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> CameraTSLR::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CameraTSLR::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool CameraTSLR::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader CameraTSLR::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder CameraTSLR::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline CameraTSLR::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void CameraTSLR::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder CameraTSLR::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void CameraTSLR::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> CameraTSLR::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool CameraTSLR::Reader::hasObjects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool CameraTSLR::Builder::hasObjects() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorCameraTSLRObject::Reader CameraTSLR::Reader::getObjects() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorCameraTSLRObject>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorCameraTSLRObject::Builder CameraTSLR::Builder::getObjects() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorCameraTSLRObject>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorCameraTSLRObject::Pipeline CameraTSLR::Pipeline::getObjects() {
  return  ::gac::rscl::VectorCameraTSLRObject::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void CameraTSLR::Builder::setObjects( ::gac::rscl::VectorCameraTSLRObject::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorCameraTSLRObject>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorCameraTSLRObject::Builder CameraTSLR::Builder::initObjects() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorCameraTSLRObject>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void CameraTSLR::Builder::adoptObjects(
    ::capnp::Orphan< ::gac::rscl::VectorCameraTSLRObject>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorCameraTSLRObject>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorCameraTSLRObject> CameraTSLR::Builder::disownObjects() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorCameraTSLRObject>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool LaneType::Reader::hasCutPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneType::Builder::hasCutPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader LaneType::Reader::getCutPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder LaneType::Builder::getCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline LaneType::Pipeline::getCutPoint() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LaneType::Builder::setCutPoint( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder LaneType::Builder::initCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneType::Builder::adoptCutPoint(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> LaneType::Builder::disownCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t LaneType::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneType::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LaneType::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VectorLaneType::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLaneType::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Reader VectorLaneType::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Builder VectorLaneType::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLaneType::Builder::setData( ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>::Builder VectorLaneType::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLaneType::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>> VectorLaneType::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneType,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LaneColor::Reader::hasCutPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneColor::Builder::hasCutPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader LaneColor::Reader::getCutPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder LaneColor::Builder::getCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline LaneColor::Pipeline::getCutPoint() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LaneColor::Builder::setCutPoint( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder LaneColor::Builder::initCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneColor::Builder::adoptCutPoint(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> LaneColor::Builder::disownCutPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t LaneColor::Reader::getColor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneColor::Builder::getColor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LaneColor::Builder::setColor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VectorLaneColor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLaneColor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Reader VectorLaneColor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Builder VectorLaneColor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLaneColor::Builder::setData( ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>::Builder VectorLaneColor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLaneColor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>> VectorLaneColor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneColor,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float InternalLanePoint2f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float InternalLanePoint2f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float InternalLanePoint2f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float InternalLanePoint2f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalLanePoint2f::Reader::getNextSegmentLaneLineType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalLanePoint2f::Builder::getNextSegmentLaneLineType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setNextSegmentLaneLineType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalLanePoint2f::Reader::getNextSegmentLaneLineColor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalLanePoint2f::Builder::getNextSegmentLaneLineColor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setNextSegmentLaneLineColor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool InternalLanePoint2f::Reader::hasNextSegmentLaneLineWidth() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLanePoint2f::Builder::hasNextSegmentLaneLineWidth() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::LaneWidth::Reader InternalLanePoint2f::Reader::getNextSegmentLaneLineWidth() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::LaneWidth::Builder InternalLanePoint2f::Builder::getNextSegmentLaneLineWidth() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::LaneWidth::Pipeline InternalLanePoint2f::Pipeline::getNextSegmentLaneLineWidth() {
  return  ::gac::rscl::LaneWidth::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalLanePoint2f::Builder::setNextSegmentLaneLineWidth( ::gac::rscl::LaneWidth::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::LaneWidth::Builder InternalLanePoint2f::Builder::initNextSegmentLaneLineWidth() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalLanePoint2f::Builder::adoptNextSegmentLaneLineWidth(
    ::capnp::Orphan< ::gac::rscl::LaneWidth>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::LaneWidth> InternalLanePoint2f::Builder::disownNextSegmentLaneLineWidth() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float InternalLanePoint2f::Reader::getNextSegmentLaneLineColorConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float InternalLanePoint2f::Builder::getNextSegmentLaneLineColorConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setNextSegmentLaneLineColorConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float InternalLanePoint2f::Reader::getNextSegmentLaneLineTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float InternalLanePoint2f::Builder::getNextSegmentLaneLineTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setNextSegmentLaneLineTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float InternalLanePoint2f::Reader::getNextSegmentLaneLineWidthConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float InternalLanePoint2f::Builder::getNextSegmentLaneLineWidthConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setNextSegmentLaneLineWidthConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalLanePoint2f::Reader::getPointType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalLanePoint2f::Builder::getPointType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void InternalLanePoint2f::Builder::setPointType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline bool VectorLaneWidth::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLaneWidth::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Reader VectorLaneWidth::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Builder VectorLaneWidth::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLaneWidth::Builder::setData( ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>::Builder VectorLaneWidth::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLaneWidth::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>> VectorLaneWidth::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneWidth,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LaneBoundary::Reader::hasHistInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneBoundary::Builder::hasHistInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader LaneBoundary::Reader::getHistInfo() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder LaneBoundary::Builder::getHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline LaneBoundary::Pipeline::getHistInfo() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LaneBoundary::Builder::setHistInfo( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder LaneBoundary::Builder::initHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneBoundary::Builder::adoptHistInfo(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> LaneBoundary::Builder::disownHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t LaneBoundary::Reader::getLaneId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LaneBoundary::Builder::getLaneId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setLaneId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LaneBoundary::Reader::getLanePositionIndex() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneBoundary::Builder::getLanePositionIndex() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setLanePositionIndex( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LaneBoundary::Reader::getAvailability() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneBoundary::Builder::getAvailability() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setAvailability( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getC0() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getC0() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setC0(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getC1() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getC1() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setC1(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getC2() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getC2() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setC2(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getC3() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getC3() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setC3(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getRangeStart() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getRangeStart() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setRangeStart(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float LaneBoundary::Reader::getRangeEnd() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float LaneBoundary::Builder::getRangeEnd() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void LaneBoundary::Builder::setRangeEnd(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool LaneBoundary::Reader::hasLaneTypeVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LaneBoundary::Builder::hasLaneTypeVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLaneType::Reader LaneBoundary::Reader::getLaneTypeVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneType>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLaneType::Builder LaneBoundary::Builder::getLaneTypeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneType>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLaneType::Pipeline LaneBoundary::Pipeline::getLaneTypeVector() {
  return  ::gac::rscl::VectorLaneType::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void LaneBoundary::Builder::setLaneTypeVector( ::gac::rscl::VectorLaneType::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneType>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLaneType::Builder LaneBoundary::Builder::initLaneTypeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneType>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LaneBoundary::Builder::adoptLaneTypeVector(
    ::capnp::Orphan< ::gac::rscl::VectorLaneType>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneType>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLaneType> LaneBoundary::Builder::disownLaneTypeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneType>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LaneBoundary::Reader::hasLaneColorVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LaneBoundary::Builder::hasLaneColorVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLaneColor::Reader LaneBoundary::Reader::getLaneColorVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneColor>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLaneColor::Builder LaneBoundary::Builder::getLaneColorVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneColor>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLaneColor::Pipeline LaneBoundary::Pipeline::getLaneColorVector() {
  return  ::gac::rscl::VectorLaneColor::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void LaneBoundary::Builder::setLaneColorVector( ::gac::rscl::VectorLaneColor::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneColor>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLaneColor::Builder LaneBoundary::Builder::initLaneColorVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneColor>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LaneBoundary::Builder::adoptLaneColorVector(
    ::capnp::Orphan< ::gac::rscl::VectorLaneColor>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLaneColor> LaneBoundary::Builder::disownLaneColorVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneColor>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LaneBoundary::Reader::hasLaneWidthVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LaneBoundary::Builder::hasLaneWidthVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLaneWidth::Reader LaneBoundary::Reader::getLaneWidthVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneWidth>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLaneWidth::Builder LaneBoundary::Builder::getLaneWidthVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneWidth>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLaneWidth::Pipeline LaneBoundary::Pipeline::getLaneWidthVector() {
  return  ::gac::rscl::VectorLaneWidth::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void LaneBoundary::Builder::setLaneWidthVector( ::gac::rscl::VectorLaneWidth::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneWidth>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLaneWidth::Builder LaneBoundary::Builder::initLaneWidthVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneWidth>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LaneBoundary::Builder::adoptLaneWidthVector(
    ::capnp::Orphan< ::gac::rscl::VectorLaneWidth>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneWidth>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLaneWidth> LaneBoundary::Builder::disownLaneWidthVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneWidth>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VectorLaneBoundary::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLaneBoundary::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Reader VectorLaneBoundary::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Builder VectorLaneBoundary::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLaneBoundary::Builder::setData( ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>::Builder VectorLaneBoundary::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLaneBoundary::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>> VectorLaneBoundary::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::LaneBoundary,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionLane::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FusionLane::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader FusionLane::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder FusionLane::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline FusionLane::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FusionLane::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder FusionLane::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FusionLane::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> FusionLane::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionLane::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FusionLane::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader FusionLane::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionLane::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline FusionLane::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FusionLane::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionLane::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FusionLane::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> FusionLane::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FusionLane::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FusionLane::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader FusionLane::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder FusionLane::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline FusionLane::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void FusionLane::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder FusionLane::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FusionLane::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> FusionLane::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool FusionLane::Reader::hasLaneBoundaryVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool FusionLane::Builder::hasLaneBoundaryVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLaneBoundary::Reader FusionLane::Reader::getLaneBoundaryVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLaneBoundary::Builder FusionLane::Builder::getLaneBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLaneBoundary::Pipeline FusionLane::Pipeline::getLaneBoundaryVector() {
  return  ::gac::rscl::VectorLaneBoundary::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void FusionLane::Builder::setLaneBoundaryVector( ::gac::rscl::VectorLaneBoundary::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLaneBoundary::Builder FusionLane::Builder::initLaneBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void FusionLane::Builder::adoptLaneBoundaryVector(
    ::capnp::Orphan< ::gac::rscl::VectorLaneBoundary>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLaneBoundary> FusionLane::Builder::disownLaneBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VectorUInt64::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorUInt64::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader VectorUInt64::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder VectorUInt64::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorUInt64::Builder::setData( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void VectorUInt64::Builder::setData(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder VectorUInt64::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorUInt64::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> VectorUInt64::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Link::Reader::getLinkId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Link::Builder::getLinkId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Link::Builder::setLinkId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Link::Reader::getLinkType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Link::Builder::getLinkType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void Link::Builder::setLinkType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Link::Reader::getLinkAttribute() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Link::Builder::getLinkAttribute() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void Link::Builder::setLinkAttribute( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline double Link::Reader::getLength() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Link::Builder::getLength() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Link::Builder::setLength(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Link::Reader::getIntersectionId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Link::Builder::getIntersectionId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Link::Builder::setIntersectionId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Link::Reader::hasLaneIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Link::Builder::hasLaneIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Link::Reader::getLaneIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::getLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Link::Pipeline::getLaneIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Link::Builder::setLaneIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::initLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Link::Builder::adoptLaneIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Link::Builder::disownLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Link::Reader::hasLeftBoundaryIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Link::Builder::hasLeftBoundaryIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Link::Reader::getLeftBoundaryIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::getLeftBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Link::Pipeline::getLeftBoundaryIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Link::Builder::setLeftBoundaryIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::initLeftBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Link::Builder::adoptLeftBoundaryIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Link::Builder::disownLeftBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Link::Reader::hasRightBoundaryIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Link::Builder::hasRightBoundaryIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Link::Reader::getRightBoundaryIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::getRightBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Link::Pipeline::getRightBoundaryIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Link::Builder::setRightBoundaryIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::initRightBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Link::Builder::adoptRightBoundaryIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Link::Builder::disownRightBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Link::Reader::hasPrecedingLinkIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Link::Builder::hasPrecedingLinkIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Link::Reader::getPrecedingLinkIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::getPrecedingLinkIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Link::Pipeline::getPrecedingLinkIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Link::Builder::setPrecedingLinkIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::initPrecedingLinkIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Link::Builder::adoptPrecedingLinkIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Link::Builder::disownPrecedingLinkIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Link::Reader::hasSucceedingLinkIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Link::Builder::hasSucceedingLinkIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Link::Reader::getSucceedingLinkIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::getSucceedingLinkIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Link::Pipeline::getSucceedingLinkIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Link::Builder::setSucceedingLinkIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Link::Builder::initSucceedingLinkIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Link::Builder::adoptSucceedingLinkIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Link::Builder::disownSucceedingLinkIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::uint8_t Link::Reader::getLinkClass() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Link::Builder::getLinkClass() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void Link::Builder::setLinkClass( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getLinkId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getLinkId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setLinkId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Lane::Reader::getLaneType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Lane::Builder::getLaneType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setLaneType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Lane::Reader::getTurnType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Lane::Builder::getTurnType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setTurnType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Lane::Reader::getTransType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Lane::Builder::getTransType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setTransType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Lane::Reader::getSequence() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Lane::Builder::getSequence() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setSequence( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getIntersectionId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getIntersectionId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setIntersectionId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getLeftLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getLeftLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setLeftLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getRightLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getRightLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setRightLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getLeftBoundaryId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getLeftBoundaryId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setLeftBoundaryId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Lane::Reader::getRightBoundaryId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Lane::Builder::getRightBoundaryId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setRightBoundaryId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline bool Lane::Reader::hasPrecedingLaneIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Lane::Builder::hasPrecedingLaneIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Lane::Reader::getPrecedingLaneIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Lane::Builder::getPrecedingLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Lane::Pipeline::getPrecedingLaneIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Lane::Builder::setPrecedingLaneIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Lane::Builder::initPrecedingLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Lane::Builder::adoptPrecedingLaneIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Lane::Builder::disownPrecedingLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Lane::Reader::hasSucceedingLaneIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Lane::Builder::hasSucceedingLaneIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Lane::Reader::getSucceedingLaneIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Lane::Builder::getSucceedingLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Lane::Pipeline::getSucceedingLaneIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Lane::Builder::setSucceedingLaneIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Lane::Builder::initSucceedingLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Lane::Builder::adoptSucceedingLaneIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Lane::Builder::disownSucceedingLaneIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Lane::Reader::getLength() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline double Lane::Builder::getLength() {
  return _builder.getDataField<double>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void Lane::Builder::setLength(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool Lane::Reader::hasWidthVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Lane::Builder::hasWidthVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorIntervalInfo::Reader Lane::Reader::getWidthVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorIntervalInfo::Builder Lane::Builder::getWidthVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorIntervalInfo::Pipeline Lane::Pipeline::getWidthVector() {
  return  ::gac::rscl::VectorIntervalInfo::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Lane::Builder::setWidthVector( ::gac::rscl::VectorIntervalInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorIntervalInfo::Builder Lane::Builder::initWidthVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Lane::Builder::adoptWidthVector(
    ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo> Lane::Builder::disownWidthVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Lane::Reader::hasSpeedLimitVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Lane::Builder::hasSpeedLimitVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorIntervalInfo::Reader Lane::Reader::getSpeedLimitVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorIntervalInfo::Builder Lane::Builder::getSpeedLimitVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorIntervalInfo::Pipeline Lane::Pipeline::getSpeedLimitVector() {
  return  ::gac::rscl::VectorIntervalInfo::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Lane::Builder::setSpeedLimitVector( ::gac::rscl::VectorIntervalInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorIntervalInfo::Builder Lane::Builder::initSpeedLimitVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Lane::Builder::adoptSpeedLimitVector(
    ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo> Lane::Builder::disownSpeedLimitVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Lane::Reader::hasObjectIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Lane::Builder::hasObjectIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorIntervalInfo::Reader Lane::Reader::getObjectIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorIntervalInfo::Builder Lane::Builder::getObjectIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorIntervalInfo::Pipeline Lane::Pipeline::getObjectIds() {
  return  ::gac::rscl::VectorIntervalInfo::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Lane::Builder::setObjectIds( ::gac::rscl::VectorIntervalInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorIntervalInfo::Builder Lane::Builder::initObjectIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Lane::Builder::adoptObjectIds(
    ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorIntervalInfo> Lane::Builder::disownObjectIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorIntervalInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Lane::Reader::hasCenterLine() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Lane::Builder::hasCenterLine() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint3dAttribute::Reader Lane::Reader::getCenterLine() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3dAttribute>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint3dAttribute::Builder Lane::Builder::getCenterLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3dAttribute>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint3dAttribute::Pipeline Lane::Pipeline::getCenterLine() {
  return  ::gac::rscl::VectorPoint3dAttribute::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Lane::Builder::setCenterLine( ::gac::rscl::VectorPoint3dAttribute::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3dAttribute>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint3dAttribute::Builder Lane::Builder::initCenterLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3dAttribute>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Lane::Builder::adoptCenterLine(
    ::capnp::Orphan< ::gac::rscl::VectorPoint3dAttribute>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3dAttribute>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint3dAttribute> Lane::Builder::disownCenterLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3dAttribute>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool VectorLane::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLane::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Reader VectorLane::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Builder VectorLane::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLane::Builder::setData( ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>::Builder VectorLane::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLane::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>> VectorLane::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Lane,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Boundary::Reader::getBoundaryId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Boundary::Builder::getBoundaryId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setBoundaryId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Boundary::Reader::getLinkId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Boundary::Builder::getLinkId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setLinkId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Boundary::Reader::getLeftLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Boundary::Builder::getLeftLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setLeftLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Boundary::Reader::getRightLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Boundary::Builder::getRightLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Boundary::Builder::setRightLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Boundary::Reader::hasPrecedingBoundaryIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Boundary::Builder::hasPrecedingBoundaryIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Boundary::Reader::getPrecedingBoundaryIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Boundary::Builder::getPrecedingBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Boundary::Pipeline::getPrecedingBoundaryIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Boundary::Builder::setPrecedingBoundaryIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Boundary::Builder::initPrecedingBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Boundary::Builder::adoptPrecedingBoundaryIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Boundary::Builder::disownPrecedingBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Boundary::Reader::hasSucceedingBoundaryIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Boundary::Builder::hasSucceedingBoundaryIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Boundary::Reader::getSucceedingBoundaryIds() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Boundary::Builder::getSucceedingBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Boundary::Pipeline::getSucceedingBoundaryIds() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Boundary::Builder::setSucceedingBoundaryIds( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Boundary::Builder::initSucceedingBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Boundary::Builder::adoptSucceedingBoundaryIds(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Boundary::Builder::disownSucceedingBoundaryIds() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Boundary::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Boundary::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorBoundaryIntervalInfo::Reader Boundary::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundaryIntervalInfo>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorBoundaryIntervalInfo::Builder Boundary::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundaryIntervalInfo>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorBoundaryIntervalInfo::Pipeline Boundary::Pipeline::getSegments() {
  return  ::gac::rscl::VectorBoundaryIntervalInfo::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Boundary::Builder::setSegments( ::gac::rscl::VectorBoundaryIntervalInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundaryIntervalInfo>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorBoundaryIntervalInfo::Builder Boundary::Builder::initSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundaryIntervalInfo>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Boundary::Builder::adoptSegments(
    ::capnp::Orphan< ::gac::rscl::VectorBoundaryIntervalInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundaryIntervalInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorBoundaryIntervalInfo> Boundary::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundaryIntervalInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Boundary::Reader::hasCenterLine() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Boundary::Builder::hasCenterLine() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint3d::Reader Boundary::Reader::getCenterLine() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint3d::Builder Boundary::Builder::getCenterLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint3d::Pipeline Boundary::Pipeline::getCenterLine() {
  return  ::gac::rscl::VectorPoint3d::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Boundary::Builder::setCenterLine( ::gac::rscl::VectorPoint3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint3d::Builder Boundary::Builder::initCenterLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Boundary::Builder::adoptCenterLine(
    ::capnp::Orphan< ::gac::rscl::VectorPoint3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint3d> Boundary::Builder::disownCenterLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VectorBoundary::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorBoundary::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Reader VectorBoundary::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Builder VectorBoundary::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorBoundary::Builder::setData( ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>::Builder VectorBoundary::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorBoundary::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>> VectorBoundary::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Boundary,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stopline::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stopline::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader Stopline::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder Stopline::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline Stopline::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stopline::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder Stopline::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stopline::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> Stopline::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Stopline::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Stopline::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Stopline::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Stopline::Reader::hasLaneId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Stopline::Builder::hasLaneId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Stopline::Reader::getLaneId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Stopline::Builder::getLaneId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Stopline::Pipeline::getLaneId() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Stopline::Builder::setLaneId( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Stopline::Builder::initLaneId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Stopline::Builder::adoptLaneId(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Stopline::Builder::disownLaneId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Stopline::Reader::hasStopLine() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Stopline::Builder::hasStopLine() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint3d::Reader Stopline::Reader::getStopLine() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint3d::Builder Stopline::Builder::getStopLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint3d::Pipeline Stopline::Pipeline::getStopLine() {
  return  ::gac::rscl::VectorPoint3d::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Stopline::Builder::setStopLine( ::gac::rscl::VectorPoint3d::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint3d::Builder Stopline::Builder::initStopLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Stopline::Builder::adoptStopLine(
    ::capnp::Orphan< ::gac::rscl::VectorPoint3d>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint3d> Stopline::Builder::disownStopLine() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint3d>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorStopline::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorStopline::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Reader VectorStopline::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Builder VectorStopline::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorStopline::Builder::setData( ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>::Builder VectorStopline::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorStopline::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>> VectorStopline::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Stopline,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Marking::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Marking::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader Marking::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder Marking::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline Marking::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Marking::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder Marking::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Marking::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> Marking::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Marking::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Marking::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Marking::Reader::getLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Marking::Builder::getLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Marking::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Marking::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader Marking::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder Marking::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline Marking::Pipeline::getPosition() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Marking::Builder::setPosition( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder Marking::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Marking::Builder::adoptPosition(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> Marking::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Marking::Reader::hasBbox3d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Marking::Builder::hasBbox3d() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Bbox3D::Reader Marking::Reader::getBbox3d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Bbox3D::Builder Marking::Builder::getBbox3d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Bbox3D::Pipeline Marking::Pipeline::getBbox3d() {
  return  ::gac::rscl::Bbox3D::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Marking::Builder::setBbox3d( ::gac::rscl::Bbox3D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Bbox3D::Builder Marking::Builder::initBbox3d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Marking::Builder::adoptBbox3d(
    ::capnp::Orphan< ::gac::rscl::Bbox3D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Bbox3D> Marking::Builder::disownBbox3d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint8_t Marking::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Marking::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Marking::Reader::getColor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Marking::Builder::getColor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setColor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline bool Marking::Reader::hasSemanticInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Marking::Builder::hasSemanticInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Marking::Reader::getSemanticInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Marking::Builder::getSemanticInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Marking::Builder::setSemanticInfo( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Marking::Builder::initSemanticInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Marking::Builder::adoptSemanticInfo(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Marking::Builder::disownSemanticInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline float Marking::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float Marking::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Marking::Reader::getLaneVectorIndex() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Marking::Builder::getLaneVectorIndex() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setLaneVectorIndex( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Marking::Reader::getDetectionStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Marking::Builder::getDetectionStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}
inline void Marking::Builder::setDetectionStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value);
}

inline bool VectorMarking::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorMarking::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Reader VectorMarking::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Builder VectorMarking::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorMarking::Builder::setData( ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>::Builder VectorMarking::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorMarking::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>> VectorMarking::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Marking,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Sign::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Sign::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader Sign::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder Sign::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline Sign::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Sign::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder Sign::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Sign::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> Sign::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Sign::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Sign::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Sign::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Sign::Reader::getLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Sign::Builder::getLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Sign::Builder::setLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Sign::Reader::getType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Sign::Builder::getType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Sign::Builder::setType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool Sign::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Sign::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader Sign::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder Sign::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline Sign::Pipeline::getPosition() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Sign::Builder::setPosition( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder Sign::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Sign::Builder::adoptPosition(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> Sign::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t Sign::Reader::getLaneVectorIndex() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Sign::Builder::getLaneVectorIndex() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Sign::Builder::setLaneVectorIndex( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Sign::Reader::getDetectionStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Sign::Builder::getDetectionStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}
inline void Sign::Builder::setDetectionStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS, value);
}

inline bool VectorSign::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorSign::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Reader VectorSign::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Builder VectorSign::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorSign::Builder::setData( ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>::Builder VectorSign::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorSign::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>> VectorSign::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Sign,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t Signal::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Signal::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Signal::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Signal::Reader::getStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Signal::Builder::getStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Signal::Builder::setStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool VectorSignal::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorSignal::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Reader VectorSignal::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Builder VectorSignal::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorSignal::Builder::setData( ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>::Builder VectorSignal::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorSignal::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>> VectorSignal::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Signal,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SafeIsland::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SafeIsland::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader SafeIsland::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder SafeIsland::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline SafeIsland::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SafeIsland::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder SafeIsland::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SafeIsland::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> SafeIsland::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t SafeIsland::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t SafeIsland::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SafeIsland::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool SafeIsland::Reader::hasLaneIdVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SafeIsland::Builder::hasLaneIdVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader SafeIsland::Reader::getLaneIdVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder SafeIsland::Builder::getLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline SafeIsland::Pipeline::getLaneIdVector() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SafeIsland::Builder::setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder SafeIsland::Builder::initLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SafeIsland::Builder::adoptLaneIdVector(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> SafeIsland::Builder::disownLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SafeIsland::Reader::hasBvBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool SafeIsland::Builder::hasBvBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::BirdViewBbox2D::Reader SafeIsland::Reader::getBvBbox2d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::BirdViewBbox2D::Builder SafeIsland::Builder::getBvBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::BirdViewBbox2D::Pipeline SafeIsland::Pipeline::getBvBbox2d() {
  return  ::gac::rscl::BirdViewBbox2D::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void SafeIsland::Builder::setBvBbox2d( ::gac::rscl::BirdViewBbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::BirdViewBbox2D::Builder SafeIsland::Builder::initBvBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void SafeIsland::Builder::adoptBvBbox2d(
    ::capnp::Orphan< ::gac::rscl::BirdViewBbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::BirdViewBbox2D> SafeIsland::Builder::disownBvBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorSafeIsland::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorSafeIsland::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Reader VectorSafeIsland::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Builder VectorSafeIsland::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorSafeIsland::Builder::setData( ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>::Builder VectorSafeIsland::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorSafeIsland::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>> VectorSafeIsland::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SafeIsland,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PedestrianCrossing::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PedestrianCrossing::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader PedestrianCrossing::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder PedestrianCrossing::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline PedestrianCrossing::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PedestrianCrossing::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder PedestrianCrossing::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PedestrianCrossing::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> PedestrianCrossing::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t PedestrianCrossing::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t PedestrianCrossing::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PedestrianCrossing::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PedestrianCrossing::Reader::hasLaneIdVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PedestrianCrossing::Builder::hasLaneIdVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader PedestrianCrossing::Reader::getLaneIdVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder PedestrianCrossing::Builder::getLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline PedestrianCrossing::Pipeline::getLaneIdVector() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PedestrianCrossing::Builder::setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder PedestrianCrossing::Builder::initLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PedestrianCrossing::Builder::adoptLaneIdVector(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> PedestrianCrossing::Builder::disownLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PedestrianCrossing::Reader::hasBvBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool PedestrianCrossing::Builder::hasBvBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::BirdViewBbox2D::Reader PedestrianCrossing::Reader::getBvBbox2d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::BirdViewBbox2D::Builder PedestrianCrossing::Builder::getBvBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::BirdViewBbox2D::Pipeline PedestrianCrossing::Pipeline::getBvBbox2d() {
  return  ::gac::rscl::BirdViewBbox2D::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void PedestrianCrossing::Builder::setBvBbox2d( ::gac::rscl::BirdViewBbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::BirdViewBbox2D::Builder PedestrianCrossing::Builder::initBvBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void PedestrianCrossing::Builder::adoptBvBbox2d(
    ::capnp::Orphan< ::gac::rscl::BirdViewBbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::BirdViewBbox2D> PedestrianCrossing::Builder::disownBvBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::BirdViewBbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorPedestrianCrossing::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorPedestrianCrossing::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Reader VectorPedestrianCrossing::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Builder VectorPedestrianCrossing::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorPedestrianCrossing::Builder::setData( ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>::Builder VectorPedestrianCrossing::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorPedestrianCrossing::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>> VectorPedestrianCrossing::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::PedestrianCrossing,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorLink::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLink::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Reader VectorLink::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Builder VectorLink::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLink::Builder::setData( ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>::Builder VectorLink::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLink::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>> VectorLink::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Link,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SpeedLimitSign::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SpeedLimitSign::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader SpeedLimitSign::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder SpeedLimitSign::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline SpeedLimitSign::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SpeedLimitSign::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder SpeedLimitSign::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SpeedLimitSign::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> SpeedLimitSign::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t SpeedLimitSign::Reader::getId() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t SpeedLimitSign::Builder::getId() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SpeedLimitSign::Builder::setId( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float SpeedLimitSign::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float SpeedLimitSign::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SpeedLimitSign::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t SpeedLimitSign::Reader::getTrackingStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t SpeedLimitSign::Builder::getTrackingStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SpeedLimitSign::Builder::setTrackingStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t SpeedLimitSign::Reader::getType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SpeedLimitSign::Builder::getType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void SpeedLimitSign::Builder::setType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool SpeedLimitSign::Reader::hasCenterPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SpeedLimitSign::Builder::hasCenterPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point3f::Reader SpeedLimitSign::Reader::getCenterPosition() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point3f::Builder SpeedLimitSign::Builder::getCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point3f::Pipeline SpeedLimitSign::Pipeline::getCenterPosition() {
  return  ::gac::rscl::Point3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SpeedLimitSign::Builder::setCenterPosition( ::gac::rscl::Point3f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point3f::Builder SpeedLimitSign::Builder::initCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SpeedLimitSign::Builder::adoptCenterPosition(
    ::capnp::Orphan< ::gac::rscl::Point3f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point3f> SpeedLimitSign::Builder::disownCenterPosition() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VectorSpeedLimitSign::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorSpeedLimitSign::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader VectorSpeedLimitSign::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder VectorSpeedLimitSign::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorSpeedLimitSign::Builder::setData( ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>::Builder VectorSpeedLimitSign::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorSpeedLimitSign::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>> VectorSpeedLimitSign::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::SpeedLimitSign,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionTrafficSign::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FusionTrafficSign::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader FusionTrafficSign::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder FusionTrafficSign::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline FusionTrafficSign::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FusionTrafficSign::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder FusionTrafficSign::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FusionTrafficSign::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> FusionTrafficSign::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionTrafficSign::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FusionTrafficSign::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader FusionTrafficSign::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionTrafficSign::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline FusionTrafficSign::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FusionTrafficSign::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionTrafficSign::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FusionTrafficSign::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> FusionTrafficSign::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FusionTrafficSign::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FusionTrafficSign::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader FusionTrafficSign::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder FusionTrafficSign::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline FusionTrafficSign::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void FusionTrafficSign::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder FusionTrafficSign::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FusionTrafficSign::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> FusionTrafficSign::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint32_t FusionTrafficSign::Reader::getTrafficSignNum() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FusionTrafficSign::Builder::getTrafficSignNum() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FusionTrafficSign::Builder::setTrafficSignNum( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FusionTrafficSign::Reader::hasSignVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool FusionTrafficSign::Builder::hasSignVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSpeedLimitSign::Reader FusionTrafficSign::Reader::getSignVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSpeedLimitSign>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSpeedLimitSign::Builder FusionTrafficSign::Builder::getSignVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSpeedLimitSign>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSpeedLimitSign::Pipeline FusionTrafficSign::Pipeline::getSignVector() {
  return  ::gac::rscl::VectorSpeedLimitSign::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void FusionTrafficSign::Builder::setSignVector( ::gac::rscl::VectorSpeedLimitSign::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSpeedLimitSign>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSpeedLimitSign::Builder FusionTrafficSign::Builder::initSignVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSpeedLimitSign>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void FusionTrafficSign::Builder::adoptSignVector(
    ::capnp::Orphan< ::gac::rscl::VectorSpeedLimitSign>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSpeedLimitSign>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSpeedLimitSign> FusionTrafficSign::Builder::disownSignVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSpeedLimitSign>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VectorTrafficLightSignal::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorTrafficLightSignal::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Reader VectorTrafficLightSignal::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Builder VectorTrafficLightSignal::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorTrafficLightSignal::Builder::setData( ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>::Builder VectorTrafficLightSignal::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorTrafficLightSignal::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>> VectorTrafficLightSignal::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::TrafficLightSignal,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Light::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Light::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader Light::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder Light::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline Light::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Light::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder Light::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Light::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> Light::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Light::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Light::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Light::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Light::Reader::getLaneId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Light::Builder::getLaneId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Light::Builder::setLaneId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Light::Reader::getIsDetectedByCamera() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}

inline bool Light::Builder::getIsDetectedByCamera() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}
inline void Light::Builder::setIsDetectedByCamera(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value);
}

inline bool Light::Reader::getIsGotOnlyByCamera() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}

inline bool Light::Builder::getIsGotOnlyByCamera() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}
inline void Light::Builder::setIsGotOnlyByCamera(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Light::Reader::getCountDownSecond() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Light::Builder::getCountDownSecond() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Light::Builder::setCountDownSecond( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float Light::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float Light::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Light::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool Light::Reader::hasBbox3d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Light::Builder::hasBbox3d() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Bbox3D::Reader Light::Reader::getBbox3d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Bbox3D::Builder Light::Builder::getBbox3d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Bbox3D::Pipeline Light::Pipeline::getBbox3d() {
  return  ::gac::rscl::Bbox3D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Light::Builder::setBbox3d( ::gac::rscl::Bbox3D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Bbox3D::Builder Light::Builder::initBbox3d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Light::Builder::adoptBbox3d(
    ::capnp::Orphan< ::gac::rscl::Bbox3D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Bbox3D> Light::Builder::disownBbox3d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Bbox3D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Light::Reader::hasLaneIdVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Light::Builder::hasLaneIdVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader Light::Reader::getLaneIdVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder Light::Builder::getLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline Light::Pipeline::getLaneIdVector() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Light::Builder::setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder Light::Builder::initLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Light::Builder::adoptLaneIdVector(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> Light::Builder::disownLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Light::Reader::hasSignalVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Light::Builder::hasSignalVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSignal::Reader Light::Reader::getSignalVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSignal>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSignal::Builder Light::Builder::getSignalVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSignal>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSignal::Pipeline Light::Pipeline::getSignalVector() {
  return  ::gac::rscl::VectorSignal::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Light::Builder::setSignalVector( ::gac::rscl::VectorSignal::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSignal>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSignal::Builder Light::Builder::initSignalVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSignal>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Light::Builder::adoptSignalVector(
    ::capnp::Orphan< ::gac::rscl::VectorSignal>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSignal>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSignal> Light::Builder::disownSignalVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSignal>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool VectorLight::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorLight::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Reader VectorLight::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Builder VectorLight::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorLight::Builder::setData( ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>::Builder VectorLight::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorLight::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>> VectorLight::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::Light,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BumpLike::Reader::hasHistInfoVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BumpLike::Builder::hasHistInfoVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorHistInfo::Reader BumpLike::Reader::getHistInfoVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorHistInfo::Builder BumpLike::Builder::getHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorHistInfo::Pipeline BumpLike::Pipeline::getHistInfoVector() {
  return  ::gac::rscl::VectorHistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BumpLike::Builder::setHistInfoVector( ::gac::rscl::VectorHistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorHistInfo::Builder BumpLike::Builder::initHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BumpLike::Builder::adoptHistInfoVector(
    ::capnp::Orphan< ::gac::rscl::VectorHistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorHistInfo> BumpLike::Builder::disownHistInfoVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorHistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t BumpLike::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t BumpLike::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BumpLike::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BumpLike::Reader::hasLaneIdVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BumpLike::Builder::hasLaneIdVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorUInt64::Reader BumpLike::Reader::getLaneIdVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorUInt64::Builder BumpLike::Builder::getLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorUInt64::Pipeline BumpLike::Pipeline::getLaneIdVector() {
  return  ::gac::rscl::VectorUInt64::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void BumpLike::Builder::setLaneIdVector( ::gac::rscl::VectorUInt64::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorUInt64::Builder BumpLike::Builder::initLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BumpLike::Builder::adoptLaneIdVector(
    ::capnp::Orphan< ::gac::rscl::VectorUInt64>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorUInt64> BumpLike::Builder::disownLaneIdVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorUInt64>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t BumpLike::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t BumpLike::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void BumpLike::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool BumpLike::Reader::hasBumplikeBbox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BumpLike::Builder::hasBumplikeBbox() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLaneBoundary::Reader BumpLike::Reader::getBumplikeBbox() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLaneBoundary::Builder BumpLike::Builder::getBumplikeBbox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLaneBoundary::Pipeline BumpLike::Pipeline::getBumplikeBbox() {
  return  ::gac::rscl::VectorLaneBoundary::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void BumpLike::Builder::setBumplikeBbox( ::gac::rscl::VectorLaneBoundary::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLaneBoundary::Builder BumpLike::Builder::initBumplikeBbox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BumpLike::Builder::adoptBumplikeBbox(
    ::capnp::Orphan< ::gac::rscl::VectorLaneBoundary>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLaneBoundary> BumpLike::Builder::disownBumplikeBbox() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLaneBoundary>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool VectorBumpLike::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorBumpLike::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Reader VectorBumpLike::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Builder VectorBumpLike::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorBumpLike::Builder::setData( ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>::Builder VectorBumpLike::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorBumpLike::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>> VectorBumpLike::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::BumpLike,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorInternalLanePoint2f::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalLanePoint2f::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Reader VectorInternalLanePoint2f::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Builder VectorInternalLanePoint2f::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalLanePoint2f::Builder::setData( ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>::Builder VectorInternalLanePoint2f::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalLanePoint2f::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>> VectorInternalLanePoint2f::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLanePoint2f,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t InternalLaneLine::Reader::getLaneIndex() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t InternalLaneLine::Builder::getLaneIndex() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setLaneIndex( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t InternalLaneLine::Reader::getTrackId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t InternalLaneLine::Builder::getTrackId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setTrackId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t InternalLaneLine::Reader::getTrackAge() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t InternalLaneLine::Builder::getTrackAge() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setTrackAge( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float InternalLaneLine::Reader::getDistanceToLeftBumper() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float InternalLaneLine::Builder::getDistanceToLeftBumper() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setDistanceToLeftBumper(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float InternalLaneLine::Reader::getDistanceToRightBumper() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float InternalLaneLine::Builder::getDistanceToRightBumper() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setDistanceToRightBumper(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool InternalLaneLine::Reader::hasLanelineWidth() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasLanelineWidth() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::LaneWidth::Reader InternalLaneLine::Reader::getLanelineWidth() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::LaneWidth::Builder InternalLaneLine::Builder::getLanelineWidth() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::LaneWidth::Pipeline InternalLaneLine::Pipeline::getLanelineWidth() {
  return  ::gac::rscl::LaneWidth::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setLanelineWidth( ::gac::rscl::LaneWidth::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::LaneWidth::Builder InternalLaneLine::Builder::initLanelineWidth() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptLanelineWidth(
    ::capnp::Orphan< ::gac::rscl::LaneWidth>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::LaneWidth> InternalLaneLine::Builder::disownLanelineWidth() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::LaneWidth>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t InternalLaneLine::Reader::getColor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalLaneLine::Builder::getColor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setColor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InternalLaneLine::Reader::getLaneType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalLaneLine::Builder::getLaneType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setLaneType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS, value);
}

inline float InternalLaneLine::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float InternalLaneLine::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float InternalLaneLine::Reader::getColorConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float InternalLaneLine::Builder::getColorConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setColorConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float InternalLaneLine::Reader::getTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float InternalLaneLine::Builder::getTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float InternalLaneLine::Reader::getWidthConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float InternalLaneLine::Builder::getWidthConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setWidthConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool InternalLaneLine::Reader::hasStartPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasStartPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalLaneLine::Reader::getStartPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalLaneLine::Builder::getStartPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalLaneLine::Pipeline::getStartPoint() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setStartPoint( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalLaneLine::Builder::initStartPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptStartPoint(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalLaneLine::Builder::disownStartPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool InternalLaneLine::Reader::hasEndPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasEndPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Point2f::Reader InternalLaneLine::Reader::getEndPoint() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Point2f::Builder InternalLaneLine::Builder::getEndPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Point2f::Pipeline InternalLaneLine::Pipeline::getEndPoint() {
  return  ::gac::rscl::Point2f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setEndPoint( ::gac::rscl::Point2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Point2f::Builder InternalLaneLine::Builder::initEndPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptEndPoint(
    ::capnp::Orphan< ::gac::rscl::Point2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Point2f> InternalLaneLine::Builder::disownEndPoint() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Point2f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool InternalLaneLine::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalLaneLine::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalLaneLine::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalLaneLine::Pipeline::getImagePoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setImagePoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalLaneLine::Builder::initImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptImagePoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalLaneLine::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool InternalLaneLine::Reader::hasBvPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasBvPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalLaneLine::Reader::getBvPoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalLaneLine::Builder::getBvPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalLaneLine::Pipeline::getBvPoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setBvPoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalLaneLine::Builder::initBvPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptBvPoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalLaneLine::Builder::disownBvPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::int32_t InternalLaneLine::Reader::getFittingType() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::int32_t InternalLaneLine::Builder::getFittingType() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setFittingType( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t InternalLaneLine::Reader::getFittingOrder() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline  ::int32_t InternalLaneLine::Builder::getFittingOrder() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setFittingOrder( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline bool InternalLaneLine::Reader::hasFittingCoefficients() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasFittingCoefficients() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorFloat::Reader InternalLaneLine::Reader::getFittingCoefficients() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorFloat::Builder InternalLaneLine::Builder::getFittingCoefficients() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorFloat::Pipeline InternalLaneLine::Pipeline::getFittingCoefficients() {
  return  ::gac::rscl::VectorFloat::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setFittingCoefficients( ::gac::rscl::VectorFloat::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorFloat::Builder InternalLaneLine::Builder::initFittingCoefficients() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptFittingCoefficients(
    ::capnp::Orphan< ::gac::rscl::VectorFloat>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorFloat> InternalLaneLine::Builder::disownFittingCoefficients() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorFloat>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool InternalLaneLine::Reader::hasCutPointVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool InternalLaneLine::Builder::hasCutPointVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalLanePoint2f::Reader InternalLaneLine::Reader::getCutPointVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLanePoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalLanePoint2f::Builder InternalLaneLine::Builder::getCutPointVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLanePoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalLanePoint2f::Pipeline InternalLaneLine::Pipeline::getCutPointVector() {
  return  ::gac::rscl::VectorInternalLanePoint2f::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void InternalLaneLine::Builder::setCutPointVector( ::gac::rscl::VectorInternalLanePoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLanePoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalLanePoint2f::Builder InternalLaneLine::Builder::initCutPointVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLanePoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void InternalLaneLine::Builder::adoptCutPointVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalLanePoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLanePoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalLanePoint2f> InternalLaneLine::Builder::disownCutPointVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLanePoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool InternalLaneLine::Reader::getIsLineJunctionValid() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<176>() * ::capnp::ELEMENTS);
}

inline bool InternalLaneLine::Builder::getIsLineJunctionValid() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<176>() * ::capnp::ELEMENTS);
}
inline void InternalLaneLine::Builder::setIsLineJunctionValid(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<176>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalLaneLine::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalLaneLine::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Reader VectorInternalLaneLine::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Builder VectorInternalLaneLine::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalLaneLine::Builder::setData( ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>::Builder VectorInternalLaneLine::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalLaneLine::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>> VectorInternalLaneLine::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalLaneLine,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalStopLine::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalStopLine::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalStopLine::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalStopLine::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalStopLine::Pipeline::getImagePoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalStopLine::Builder::setImagePoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalStopLine::Builder::initImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalStopLine::Builder::adoptImagePoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalStopLine::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalStopLine::Reader::hasBirdviewPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalStopLine::Builder::hasBirdviewPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalStopLine::Reader::getBirdviewPoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalStopLine::Builder::getBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalStopLine::Pipeline::getBirdviewPoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalStopLine::Builder::setBirdviewPoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalStopLine::Builder::initBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalStopLine::Builder::adoptBirdviewPoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalStopLine::Builder::disownBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float InternalStopLine::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float InternalStopLine::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalStopLine::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t InternalStopLine::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalStopLine::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalStopLine::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalStopLine::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalStopLine::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Reader VectorInternalStopLine::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Builder VectorInternalStopLine::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalStopLine::Builder::setData( ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>::Builder VectorInternalStopLine::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalStopLine::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>> VectorInternalStopLine::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalStopLine,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalBoundary::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalBoundary::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalBoundary::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalBoundary::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalBoundary::Pipeline::getImagePoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalBoundary::Builder::setImagePoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalBoundary::Builder::initImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalBoundary::Builder::adoptImagePoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalBoundary::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalBoundary::Reader::hasBirdviewPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalBoundary::Builder::hasBirdviewPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalBoundary::Reader::getBirdviewPoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalBoundary::Builder::getBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalBoundary::Pipeline::getBirdviewPoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalBoundary::Builder::setBirdviewPoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalBoundary::Builder::initBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalBoundary::Builder::adoptBirdviewPoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalBoundary::Builder::disownBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float InternalBoundary::Reader::getDirectionX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float InternalBoundary::Builder::getDirectionX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalBoundary::Builder::setDirectionX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float InternalBoundary::Reader::getDirectionY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float InternalBoundary::Builder::getDirectionY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalBoundary::Builder::setDirectionY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float InternalBoundary::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float InternalBoundary::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void InternalBoundary::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool InternalBoundary::Reader::getIsLine() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}

inline bool InternalBoundary::Builder::getIsLine() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}
inline void InternalBoundary::Builder::setIsLine(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t InternalBoundary::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalBoundary::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void InternalBoundary::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalBoundary::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalBoundary::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Reader VectorInternalBoundary::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Builder VectorInternalBoundary::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalBoundary::Builder::setData( ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>::Builder VectorInternalBoundary::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalBoundary::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>> VectorInternalBoundary::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalBoundary,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalTSR::Reader::hasLabel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSR::Builder::hasLabel() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TrafficSignTypeInfo::Reader InternalTSR::Reader::getLabel() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficSignTypeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TrafficSignTypeInfo::Builder InternalTSR::Builder::getLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficSignTypeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TrafficSignTypeInfo::Pipeline InternalTSR::Pipeline::getLabel() {
  return  ::gac::rscl::TrafficSignTypeInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalTSR::Builder::setLabel( ::gac::rscl::TrafficSignTypeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TrafficSignTypeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TrafficSignTypeInfo::Builder InternalTSR::Builder::initLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficSignTypeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalTSR::Builder::adoptLabel(
    ::capnp::Orphan< ::gac::rscl::TrafficSignTypeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TrafficSignTypeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TrafficSignTypeInfo> InternalTSR::Builder::disownLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficSignTypeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalTSR::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSR::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ImageBbox2D::Reader InternalTSR::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ImageBbox2D::Builder InternalTSR::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ImageBbox2D::Pipeline InternalTSR::Pipeline::getBbox2d() {
  return  ::gac::rscl::ImageBbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalTSR::Builder::setBbox2d( ::gac::rscl::ImageBbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ImageBbox2D::Builder InternalTSR::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalTSR::Builder::adoptBbox2d(
    ::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> InternalTSR::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t InternalTSR::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalTSR::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalTSR::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool InternalTLR::Reader::hasLabel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTLR::Builder::hasLabel() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TrafficLightSignal::Reader InternalTLR::Reader::getLabel() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficLightSignal>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TrafficLightSignal::Builder InternalTLR::Builder::getLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficLightSignal>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TrafficLightSignal::Pipeline InternalTLR::Pipeline::getLabel() {
  return  ::gac::rscl::TrafficLightSignal::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalTLR::Builder::setLabel( ::gac::rscl::TrafficLightSignal::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TrafficLightSignal>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TrafficLightSignal::Builder InternalTLR::Builder::initLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficLightSignal>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalTLR::Builder::adoptLabel(
    ::capnp::Orphan< ::gac::rscl::TrafficLightSignal>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TrafficLightSignal>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TrafficLightSignal> InternalTLR::Builder::disownLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TrafficLightSignal>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalTLR::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTLR::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ImageBbox2D::Reader InternalTLR::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ImageBbox2D::Builder InternalTLR::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ImageBbox2D::Pipeline InternalTLR::Pipeline::getBbox2d() {
  return  ::gac::rscl::ImageBbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalTLR::Builder::setBbox2d( ::gac::rscl::ImageBbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ImageBbox2D::Builder InternalTLR::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalTLR::Builder::adoptBbox2d(
    ::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> InternalTLR::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t InternalTLR::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalTLR::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalTLR::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalTLR::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalTLR::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Reader VectorInternalTLR::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Builder VectorInternalTLR::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalTLR::Builder::setData( ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>::Builder VectorInternalTLR::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalTLR::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>> VectorInternalTLR::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTLR,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalRoadMarker::Reader::hasLabel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadMarker::Builder::hasLabel() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::RoadMarkerTypeInfo::Reader InternalRoadMarker::Reader::getLabel() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::RoadMarkerTypeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::RoadMarkerTypeInfo::Builder InternalRoadMarker::Builder::getLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::RoadMarkerTypeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::RoadMarkerTypeInfo::Pipeline InternalRoadMarker::Pipeline::getLabel() {
  return  ::gac::rscl::RoadMarkerTypeInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalRoadMarker::Builder::setLabel( ::gac::rscl::RoadMarkerTypeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::RoadMarkerTypeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::RoadMarkerTypeInfo::Builder InternalRoadMarker::Builder::initLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::RoadMarkerTypeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalRoadMarker::Builder::adoptLabel(
    ::capnp::Orphan< ::gac::rscl::RoadMarkerTypeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::RoadMarkerTypeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::RoadMarkerTypeInfo> InternalRoadMarker::Builder::disownLabel() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::RoadMarkerTypeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalRoadMarker::Reader::hasBbox2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadMarker::Builder::hasBbox2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::ImageBbox2D::Reader InternalRoadMarker::Reader::getBbox2d() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::ImageBbox2D::Builder InternalRoadMarker::Builder::getBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::ImageBbox2D::Pipeline InternalRoadMarker::Pipeline::getBbox2d() {
  return  ::gac::rscl::ImageBbox2D::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalRoadMarker::Builder::setBbox2d( ::gac::rscl::ImageBbox2D::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::ImageBbox2D::Builder InternalRoadMarker::Builder::initBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalRoadMarker::Builder::adoptBbox2d(
    ::capnp::Orphan< ::gac::rscl::ImageBbox2D>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::ImageBbox2D> InternalRoadMarker::Builder::disownBbox2d() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::ImageBbox2D>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t InternalRoadMarker::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalRoadMarker::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalRoadMarker::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalRoadMarker::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalRoadMarker::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Reader VectorInternalRoadMarker::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Builder VectorInternalRoadMarker::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalRoadMarker::Builder::setData( ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>::Builder VectorInternalRoadMarker::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalRoadMarker::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>> VectorInternalRoadMarker::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRoadMarker,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t InternalRegion::Reader::getRegionType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InternalRegion::Builder::getRegionType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalRegion::Builder::setRegionType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float InternalRegion::Reader::getRegionTypeConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float InternalRegion::Builder::getRegionTypeConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalRegion::Builder::setRegionTypeConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t InternalRegion::Reader::getTrackId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalRegion::Builder::getTrackId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void InternalRegion::Builder::setTrackId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool InternalRegion::Reader::hasRegionBoundary() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRegion::Builder::hasRegionBoundary() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalRegion::Reader::getRegionBoundary() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalRegion::Builder::getRegionBoundary() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalRegion::Pipeline::getRegionBoundary() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalRegion::Builder::setRegionBoundary( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalRegion::Builder::initRegionBoundary() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalRegion::Builder::adoptRegionBoundary(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalRegion::Builder::disownRegionBoundary() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalRegion::Reader::hasJunctionPointVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRegion::Builder::hasJunctionPointVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalRegion::Reader::getJunctionPointVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalRegion::Builder::getJunctionPointVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalRegion::Pipeline::getJunctionPointVector() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalRegion::Builder::setJunctionPointVector( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalRegion::Builder::initJunctionPointVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalRegion::Builder::adoptJunctionPointVector(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalRegion::Builder::disownJunctionPointVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VectorInternalRegion::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalRegion::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Reader VectorInternalRegion::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Builder VectorInternalRegion::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalRegion::Builder::setData( ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>::Builder VectorInternalRegion::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalRegion::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>> VectorInternalRegion::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalRegion,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalCrosswalk::Reader::hasImagePoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalCrosswalk::Builder::hasImagePoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalCrosswalk::Reader::getImagePoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalCrosswalk::Builder::getImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalCrosswalk::Pipeline::getImagePoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalCrosswalk::Builder::setImagePoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalCrosswalk::Builder::initImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalCrosswalk::Builder::adoptImagePoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalCrosswalk::Builder::disownImagePoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalCrosswalk::Reader::hasBirdviewPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalCrosswalk::Builder::hasBirdviewPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPoint2f::Reader InternalCrosswalk::Reader::getBirdviewPoints() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalCrosswalk::Builder::getBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPoint2f::Pipeline InternalCrosswalk::Pipeline::getBirdviewPoints() {
  return  ::gac::rscl::VectorPoint2f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalCrosswalk::Builder::setBirdviewPoints( ::gac::rscl::VectorPoint2f::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPoint2f::Builder InternalCrosswalk::Builder::initBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalCrosswalk::Builder::adoptBirdviewPoints(
    ::capnp::Orphan< ::gac::rscl::VectorPoint2f>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPoint2f> InternalCrosswalk::Builder::disownBirdviewPoints() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPoint2f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float InternalCrosswalk::Reader::getLength() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float InternalCrosswalk::Builder::getLength() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalCrosswalk::Builder::setLength(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float InternalCrosswalk::Reader::getWidth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float InternalCrosswalk::Builder::getWidth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InternalCrosswalk::Builder::setWidth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float InternalCrosswalk::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float InternalCrosswalk::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void InternalCrosswalk::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t InternalCrosswalk::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalCrosswalk::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void InternalCrosswalk::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool VectorInternalTSR::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalTSR::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Reader VectorInternalTSR::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Builder VectorInternalTSR::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalTSR::Builder::setData( ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>::Builder VectorInternalTSR::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalTSR::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>> VectorInternalTSR::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalTSR,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasHistInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasHistInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::HistInfo::Reader InternalTSLR::Reader::getHistInfo() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::HistInfo::Builder InternalTSLR::Builder::getHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::HistInfo::Pipeline InternalTSLR::Pipeline::getHistInfo() {
  return  ::gac::rscl::HistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setHistInfo( ::gac::rscl::HistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::HistInfo::Builder InternalTSLR::Builder::initHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptHistInfo(
    ::capnp::Orphan< ::gac::rscl::HistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::HistInfo> InternalTSLR::Builder::disownHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader InternalTSLR::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder InternalTSLR::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline InternalTSLR::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder InternalTSLR::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> InternalTSLR::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader InternalTSLR::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder InternalTSLR::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline InternalTSLR::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder InternalTSLR::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> InternalTSLR::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader InternalTSLR::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder InternalTSLR::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline InternalTSLR::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder InternalTSLR::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> InternalTSLR::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasTsrVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasTsrVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalTSR::Reader InternalTSLR::Reader::getTsrVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalTSR::Builder InternalTSLR::Builder::getTsrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalTSR::Pipeline InternalTSLR::Pipeline::getTsrVector() {
  return  ::gac::rscl::VectorInternalTSR::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setTsrVector( ::gac::rscl::VectorInternalTSR::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalTSR::Builder InternalTSLR::Builder::initTsrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptTsrVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalTSR>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalTSR> InternalTSLR::Builder::disownTsrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasTlrVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasTlrVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalTLR::Reader InternalTSLR::Reader::getTlrVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalTLR::Builder InternalTSLR::Builder::getTlrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalTLR::Pipeline InternalTSLR::Pipeline::getTlrVector() {
  return  ::gac::rscl::VectorInternalTLR::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setTlrVector( ::gac::rscl::VectorInternalTLR::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalTLR::Builder InternalTSLR::Builder::initTlrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptTlrVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalTLR>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalTLR> InternalTSLR::Builder::disownTlrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool InternalTSLR::Reader::hasRoadMarkerVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool InternalTSLR::Builder::hasRoadMarkerVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalRoadMarker::Reader InternalTSLR::Reader::getRoadMarkerVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalRoadMarker::Builder InternalTSLR::Builder::getRoadMarkerVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalRoadMarker::Pipeline InternalTSLR::Pipeline::getRoadMarkerVector() {
  return  ::gac::rscl::VectorInternalRoadMarker::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void InternalTSLR::Builder::setRoadMarkerVector( ::gac::rscl::VectorInternalRoadMarker::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalRoadMarker::Builder InternalTSLR::Builder::initRoadMarkerVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void InternalTSLR::Builder::adoptRoadMarkerVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker> InternalTSLR::Builder::disownRoadMarkerVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline  ::uint32_t VEDCheck::Reader::getType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t VEDCheck::Builder::getType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VEDCheck::Builder::setType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool VEDCheck::Reader::hasVedAttributeVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VEDCheck::Builder::hasVedAttributeVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorVEDAttribute::Reader VEDCheck::Reader::getVedAttributeVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVEDAttribute>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorVEDAttribute::Builder VEDCheck::Builder::getVedAttributeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVEDAttribute>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorVEDAttribute::Pipeline VEDCheck::Pipeline::getVedAttributeVector() {
  return  ::gac::rscl::VectorVEDAttribute::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VEDCheck::Builder::setVedAttributeVector( ::gac::rscl::VectorVEDAttribute::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorVEDAttribute>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorVEDAttribute::Builder VEDCheck::Builder::initVedAttributeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVEDAttribute>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VEDCheck::Builder::adoptVedAttributeVector(
    ::capnp::Orphan< ::gac::rscl::VectorVEDAttribute>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorVEDAttribute>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorVEDAttribute> VEDCheck::Builder::disownVedAttributeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorVEDAttribute>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VectorInternalCrosswalk::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VectorInternalCrosswalk::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Reader VectorInternalCrosswalk::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Builder VectorInternalCrosswalk::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VectorInternalCrosswalk::Builder::setData( ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>::Builder VectorInternalCrosswalk::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void VectorInternalCrosswalk::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>> VectorInternalCrosswalk::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::gac::rscl::InternalCrosswalk,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasHistInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasHistInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::HistInfo::Reader InternalRoadStructure::Reader::getHistInfo() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::HistInfo::Builder InternalRoadStructure::Builder::getHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::HistInfo::Pipeline InternalRoadStructure::Pipeline::getHistInfo() {
  return  ::gac::rscl::HistInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setHistInfo( ::gac::rscl::HistInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::HistInfo::Builder InternalRoadStructure::Builder::initHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptHistInfo(
    ::capnp::Orphan< ::gac::rscl::HistInfo>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::HistInfo> InternalRoadStructure::Builder::disownHistInfo() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::HistInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader InternalRoadStructure::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder InternalRoadStructure::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline InternalRoadStructure::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder InternalRoadStructure::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> InternalRoadStructure::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader InternalRoadStructure::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder InternalRoadStructure::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline InternalRoadStructure::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder InternalRoadStructure::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> InternalRoadStructure::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasLanelineVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasLanelineVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalLaneLine::Reader InternalRoadStructure::Reader::getLanelineVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLaneLine>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalLaneLine::Builder InternalRoadStructure::Builder::getLanelineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLaneLine>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalLaneLine::Pipeline InternalRoadStructure::Pipeline::getLanelineVector() {
  return  ::gac::rscl::VectorInternalLaneLine::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setLanelineVector( ::gac::rscl::VectorInternalLaneLine::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLaneLine>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalLaneLine::Builder InternalRoadStructure::Builder::initLanelineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLaneLine>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptLanelineVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalLaneLine>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLaneLine>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalLaneLine> InternalRoadStructure::Builder::disownLanelineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalLaneLine>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasBoundaryVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasBoundaryVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalBoundary::Reader InternalRoadStructure::Reader::getBoundaryVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalBoundary>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalBoundary::Builder InternalRoadStructure::Builder::getBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalBoundary>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalBoundary::Pipeline InternalRoadStructure::Pipeline::getBoundaryVector() {
  return  ::gac::rscl::VectorInternalBoundary::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setBoundaryVector( ::gac::rscl::VectorInternalBoundary::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalBoundary>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalBoundary::Builder InternalRoadStructure::Builder::initBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalBoundary>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptBoundaryVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalBoundary>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalBoundary>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalBoundary> InternalRoadStructure::Builder::disownBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalBoundary>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasStoplineVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasStoplineVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalStopLine::Reader InternalRoadStructure::Reader::getStoplineVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalStopLine>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalStopLine::Builder InternalRoadStructure::Builder::getStoplineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalStopLine>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalStopLine::Pipeline InternalRoadStructure::Pipeline::getStoplineVector() {
  return  ::gac::rscl::VectorInternalStopLine::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setStoplineVector( ::gac::rscl::VectorInternalStopLine::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalStopLine>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalStopLine::Builder InternalRoadStructure::Builder::initStoplineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalStopLine>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptStoplineVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalStopLine>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalStopLine>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalStopLine> InternalRoadStructure::Builder::disownStoplineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalStopLine>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasCrosswalkVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasCrosswalkVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalCrosswalk::Reader InternalRoadStructure::Reader::getCrosswalkVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalCrosswalk>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalCrosswalk::Builder InternalRoadStructure::Builder::getCrosswalkVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalCrosswalk>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalCrosswalk::Pipeline InternalRoadStructure::Pipeline::getCrosswalkVector() {
  return  ::gac::rscl::VectorInternalCrosswalk::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setCrosswalkVector( ::gac::rscl::VectorInternalCrosswalk::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalCrosswalk>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalCrosswalk::Builder InternalRoadStructure::Builder::initCrosswalkVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalCrosswalk>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptCrosswalkVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalCrosswalk>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalCrosswalk>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalCrosswalk> InternalRoadStructure::Builder::disownCrosswalkVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalCrosswalk>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasTsrVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasTsrVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalTSR::Reader InternalRoadStructure::Reader::getTsrVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalTSR::Builder InternalRoadStructure::Builder::getTsrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalTSR::Pipeline InternalRoadStructure::Pipeline::getTsrVector() {
  return  ::gac::rscl::VectorInternalTSR::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setTsrVector( ::gac::rscl::VectorInternalTSR::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalTSR::Builder InternalRoadStructure::Builder::initTsrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptTsrVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalTSR>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalTSR> InternalRoadStructure::Builder::disownTsrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTSR>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasTlrVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasTlrVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalTLR::Reader InternalRoadStructure::Reader::getTlrVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalTLR::Builder InternalRoadStructure::Builder::getTlrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalTLR::Pipeline InternalRoadStructure::Pipeline::getTlrVector() {
  return  ::gac::rscl::VectorInternalTLR::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setTlrVector( ::gac::rscl::VectorInternalTLR::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalTLR::Builder InternalRoadStructure::Builder::initTlrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptTlrVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalTLR>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalTLR> InternalRoadStructure::Builder::disownTlrVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalTLR>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasRoadMarkerVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasRoadMarkerVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalRoadMarker::Reader InternalRoadStructure::Reader::getRoadMarkerVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalRoadMarker::Builder InternalRoadStructure::Builder::getRoadMarkerVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalRoadMarker::Pipeline InternalRoadStructure::Pipeline::getRoadMarkerVector() {
  return  ::gac::rscl::VectorInternalRoadMarker::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setRoadMarkerVector( ::gac::rscl::VectorInternalRoadMarker::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalRoadMarker::Builder InternalRoadStructure::Builder::initRoadMarkerVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptRoadMarkerVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalRoadMarker> InternalRoadStructure::Builder::disownRoadMarkerVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRoadMarker>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool InternalRoadStructure::Reader::hasRegionVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool InternalRoadStructure::Builder::hasRegionVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalRegion::Reader InternalRoadStructure::Reader::getRegionVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRegion>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalRegion::Builder InternalRoadStructure::Builder::getRegionVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRegion>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalRegion::Pipeline InternalRoadStructure::Pipeline::getRegionVector() {
  return  ::gac::rscl::VectorInternalRegion::Pipeline(_typeless.getPointerField(10));
}
#endif  // !CAPNP_LITE
inline void InternalRoadStructure::Builder::setRegionVector( ::gac::rscl::VectorInternalRegion::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRegion>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalRegion::Builder InternalRoadStructure::Builder::initRegionVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRegion>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void InternalRoadStructure::Builder::adoptRegionVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalRegion>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRegion>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalRegion> InternalRoadStructure::Builder::disownRegionVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalRegion>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader FusionMap::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder FusionMap::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline FusionMap::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder FusionMap::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> FusionMap::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader FusionMap::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionMap::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline FusionMap::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder FusionMap::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> FusionMap::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader FusionMap::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder FusionMap::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline FusionMap::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder FusionMap::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> FusionMap::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasLinkVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasLinkVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLink::Reader FusionMap::Reader::getLinkVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLink>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLink::Builder FusionMap::Builder::getLinkVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLink>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLink::Pipeline FusionMap::Pipeline::getLinkVector() {
  return  ::gac::rscl::VectorLink::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setLinkVector( ::gac::rscl::VectorLink::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLink>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLink::Builder FusionMap::Builder::initLinkVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLink>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptLinkVector(
    ::capnp::Orphan< ::gac::rscl::VectorLink>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLink>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLink> FusionMap::Builder::disownLinkVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLink>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasLaneVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasLaneVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLane::Reader FusionMap::Reader::getLaneVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLane>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLane::Builder FusionMap::Builder::getLaneVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLane>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLane::Pipeline FusionMap::Pipeline::getLaneVector() {
  return  ::gac::rscl::VectorLane::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setLaneVector( ::gac::rscl::VectorLane::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLane>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLane::Builder FusionMap::Builder::initLaneVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLane>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptLaneVector(
    ::capnp::Orphan< ::gac::rscl::VectorLane>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLane>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLane> FusionMap::Builder::disownLaneVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLane>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasBoundaryVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasBoundaryVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorBoundary::Reader FusionMap::Reader::getBoundaryVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundary>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorBoundary::Builder FusionMap::Builder::getBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundary>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorBoundary::Pipeline FusionMap::Pipeline::getBoundaryVector() {
  return  ::gac::rscl::VectorBoundary::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setBoundaryVector( ::gac::rscl::VectorBoundary::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundary>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorBoundary::Builder FusionMap::Builder::initBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundary>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptBoundaryVector(
    ::capnp::Orphan< ::gac::rscl::VectorBoundary>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundary>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorBoundary> FusionMap::Builder::disownBoundaryVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBoundary>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasStoplineVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasStoplineVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorStopline::Reader FusionMap::Reader::getStoplineVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorStopline>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorStopline::Builder FusionMap::Builder::getStoplineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorStopline>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorStopline::Pipeline FusionMap::Pipeline::getStoplineVector() {
  return  ::gac::rscl::VectorStopline::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setStoplineVector( ::gac::rscl::VectorStopline::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorStopline>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorStopline::Builder FusionMap::Builder::initStoplineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorStopline>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptStoplineVector(
    ::capnp::Orphan< ::gac::rscl::VectorStopline>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorStopline>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorStopline> FusionMap::Builder::disownStoplineVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorStopline>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasMarkingVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasMarkingVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorMarking::Reader FusionMap::Reader::getMarkingVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMarking>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorMarking::Builder FusionMap::Builder::getMarkingVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMarking>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorMarking::Pipeline FusionMap::Pipeline::getMarkingVector() {
  return  ::gac::rscl::VectorMarking::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setMarkingVector( ::gac::rscl::VectorMarking::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorMarking>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorMarking::Builder FusionMap::Builder::initMarkingVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMarking>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptMarkingVector(
    ::capnp::Orphan< ::gac::rscl::VectorMarking>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorMarking>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorMarking> FusionMap::Builder::disownMarkingVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorMarking>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasSignVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasSignVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSign::Reader FusionMap::Reader::getSignVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSign>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSign::Builder FusionMap::Builder::getSignVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSign>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSign::Pipeline FusionMap::Pipeline::getSignVector() {
  return  ::gac::rscl::VectorSign::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setSignVector( ::gac::rscl::VectorSign::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSign>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSign::Builder FusionMap::Builder::initSignVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSign>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptSignVector(
    ::capnp::Orphan< ::gac::rscl::VectorSign>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSign>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSign> FusionMap::Builder::disownSignVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSign>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasLightVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasLightVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorLight::Reader FusionMap::Reader::getLightVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLight>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorLight::Builder FusionMap::Builder::getLightVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLight>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorLight::Pipeline FusionMap::Pipeline::getLightVector() {
  return  ::gac::rscl::VectorLight::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setLightVector( ::gac::rscl::VectorLight::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLight>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorLight::Builder FusionMap::Builder::initLightVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLight>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptLightVector(
    ::capnp::Orphan< ::gac::rscl::VectorLight>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorLight>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorLight> FusionMap::Builder::disownLightVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorLight>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasSafeIslandVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasSafeIslandVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorSafeIsland::Reader FusionMap::Reader::getSafeIslandVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSafeIsland>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorSafeIsland::Builder FusionMap::Builder::getSafeIslandVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSafeIsland>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorSafeIsland::Pipeline FusionMap::Pipeline::getSafeIslandVector() {
  return  ::gac::rscl::VectorSafeIsland::Pipeline(_typeless.getPointerField(10));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setSafeIslandVector( ::gac::rscl::VectorSafeIsland::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSafeIsland>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorSafeIsland::Builder FusionMap::Builder::initSafeIslandVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSafeIsland>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptSafeIslandVector(
    ::capnp::Orphan< ::gac::rscl::VectorSafeIsland>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorSafeIsland>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorSafeIsland> FusionMap::Builder::disownSafeIslandVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorSafeIsland>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasPedestrianCrossingVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasPedestrianCrossingVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorPedestrianCrossing::Reader FusionMap::Reader::getPedestrianCrossingVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPedestrianCrossing>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorPedestrianCrossing::Builder FusionMap::Builder::getPedestrianCrossingVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPedestrianCrossing>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorPedestrianCrossing::Pipeline FusionMap::Pipeline::getPedestrianCrossingVector() {
  return  ::gac::rscl::VectorPedestrianCrossing::Pipeline(_typeless.getPointerField(11));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setPedestrianCrossingVector( ::gac::rscl::VectorPedestrianCrossing::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPedestrianCrossing>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorPedestrianCrossing::Builder FusionMap::Builder::initPedestrianCrossingVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPedestrianCrossing>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptPedestrianCrossingVector(
    ::capnp::Orphan< ::gac::rscl::VectorPedestrianCrossing>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorPedestrianCrossing>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorPedestrianCrossing> FusionMap::Builder::disownPedestrianCrossingVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorPedestrianCrossing>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline bool FusionMap::Reader::hasBumplikeVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline bool FusionMap::Builder::hasBumplikeVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorBumpLike::Reader FusionMap::Reader::getBumplikeVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBumpLike>::get(_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorBumpLike::Builder FusionMap::Builder::getBumplikeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBumpLike>::get(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorBumpLike::Pipeline FusionMap::Pipeline::getBumplikeVector() {
  return  ::gac::rscl::VectorBumpLike::Pipeline(_typeless.getPointerField(12));
}
#endif  // !CAPNP_LITE
inline void FusionMap::Builder::setBumplikeVector( ::gac::rscl::VectorBumpLike::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorBumpLike>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorBumpLike::Builder FusionMap::Builder::initBumplikeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBumpLike>::init(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline void FusionMap::Builder::adoptBumplikeVector(
    ::capnp::Orphan< ::gac::rscl::VectorBumpLike>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorBumpLike>::adopt(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorBumpLike> FusionMap::Builder::disownBumplikeVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorBumpLike>::disown(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}

inline bool InternalPerceptionObject::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InternalPerceptionObject::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader InternalPerceptionObject::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder InternalPerceptionObject::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline InternalPerceptionObject::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InternalPerceptionObject::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder InternalPerceptionObject::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InternalPerceptionObject::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> InternalPerceptionObject::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InternalPerceptionObject::Reader::hasCoordinate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InternalPerceptionObject::Builder::hasCoordinate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CoordinateSystem::Reader InternalPerceptionObject::Reader::getCoordinate() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CoordinateSystem::Builder InternalPerceptionObject::Builder::getCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CoordinateSystem::Pipeline InternalPerceptionObject::Pipeline::getCoordinate() {
  return  ::gac::rscl::CoordinateSystem::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InternalPerceptionObject::Builder::setCoordinate( ::gac::rscl::CoordinateSystem::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CoordinateSystem::Builder InternalPerceptionObject::Builder::initCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InternalPerceptionObject::Builder::adoptCoordinate(
    ::capnp::Orphan< ::gac::rscl::CoordinateSystem>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CoordinateSystem> InternalPerceptionObject::Builder::disownCoordinate() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CoordinateSystem>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool InternalPerceptionObject::Reader::hasSensorId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool InternalPerceptionObject::Builder::hasSensorId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::SensorId::Reader InternalPerceptionObject::Reader::getSensorId() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::SensorId::Builder InternalPerceptionObject::Builder::getSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::SensorId::Pipeline InternalPerceptionObject::Pipeline::getSensorId() {
  return  ::gac::rscl::SensorId::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void InternalPerceptionObject::Builder::setSensorId( ::gac::rscl::SensorId::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::SensorId::Builder InternalPerceptionObject::Builder::initSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void InternalPerceptionObject::Builder::adoptSensorId(
    ::capnp::Orphan< ::gac::rscl::SensorId>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::SensorId> InternalPerceptionObject::Builder::disownSensorId() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::SensorId>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint32_t InternalPerceptionObject::Reader::getObstacleNum() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t InternalPerceptionObject::Builder::getObstacleNum() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InternalPerceptionObject::Builder::setObstacleNum( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool InternalPerceptionObject::Reader::hasInternalObjectVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool InternalPerceptionObject::Builder::hasInternalObjectVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::VectorInternalObject::Reader InternalPerceptionObject::Reader::getInternalObjectVector() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalObject>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::VectorInternalObject::Builder InternalPerceptionObject::Builder::getInternalObjectVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalObject>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::VectorInternalObject::Pipeline InternalPerceptionObject::Pipeline::getInternalObjectVector() {
  return  ::gac::rscl::VectorInternalObject::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void InternalPerceptionObject::Builder::setInternalObjectVector( ::gac::rscl::VectorInternalObject::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalObject>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::VectorInternalObject::Builder InternalPerceptionObject::Builder::initInternalObjectVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalObject>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void InternalPerceptionObject::Builder::adoptInternalObjectVector(
    ::capnp::Orphan< ::gac::rscl::VectorInternalObject>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalObject>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::VectorInternalObject> InternalPerceptionObject::Builder::disownInternalObjectVector() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::VectorInternalObject>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool AppStatus::Reader::hasStatus() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AppStatus::Builder::hasStatus() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader AppStatus::Reader::getStatus() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder AppStatus::Builder::getStatus() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AppStatus::Builder::setStatus( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void AppStatus::Builder::setStatus(::kj::ArrayPtr<const  ::uint8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder AppStatus::Builder::initStatus(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AppStatus::Builder::adoptStatus(
    ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> AppStatus::Builder::disownStatus() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AppStatus::Reader::hasTimestamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AppStatus::Builder::hasTimestamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::TimeStamp::Reader AppStatus::Reader::getTimestamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::TimeStamp::Builder AppStatus::Builder::getTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::TimeStamp::Pipeline AppStatus::Pipeline::getTimestamp() {
  return  ::gac::rscl::TimeStamp::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AppStatus::Builder::setTimestamp( ::gac::rscl::TimeStamp::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::TimeStamp::Builder AppStatus::Builder::initTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AppStatus::Builder::adoptTimestamp(
    ::capnp::Orphan< ::gac::rscl::TimeStamp>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::TimeStamp> AppStatus::Builder::disownTimestamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::TimeStamp>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t AppStatus::Reader::getNodeId() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t AppStatus::Builder::getNodeId() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AppStatus::Builder::setNodeId( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getSec() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getSec() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setSec( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getNSec() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getNSec() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setNSec( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getExpStartS() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getExpStartS() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setExpStartS( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getExpStartNs() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getExpStartNs() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setExpStartNs( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getExpEndS() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getExpEndS() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setExpEndS( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getExpEndNs() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getExpEndNs() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setExpEndNs( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getShutter1() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getShutter1() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setShutter1( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeader::Reader::getShutter2() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeader::Builder::getShutter2() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void CameraHeader::Builder::setShutter2( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraHeaderMbuf::Reader::getSeq() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraHeaderMbuf::Builder::getSeq() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CameraHeaderMbuf::Builder::setSeq( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CameraHeaderMbuf::Reader::hasStamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraHeaderMbuf::Builder::hasStamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CameraHeader::Reader CameraHeaderMbuf::Reader::getStamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CameraHeader::Builder CameraHeaderMbuf::Builder::getStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CameraHeader::Pipeline CameraHeaderMbuf::Pipeline::getStamp() {
  return  ::gac::rscl::CameraHeader::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CameraHeaderMbuf::Builder::setStamp( ::gac::rscl::CameraHeader::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CameraHeader::Builder CameraHeaderMbuf::Builder::initStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeader>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraHeaderMbuf::Builder::adoptStamp(
    ::capnp::Orphan< ::gac::rscl::CameraHeader>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CameraHeader> CameraHeaderMbuf::Builder::disownStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraHeaderMbuf::Reader::hasFrameId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraHeaderMbuf::Builder::hasFrameId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CameraHeaderMbuf::Reader::getFrameId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CameraHeaderMbuf::Builder::getFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraHeaderMbuf::Builder::setFrameId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CameraHeaderMbuf::Builder::initFrameId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CameraHeaderMbuf::Builder::adoptFrameId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CameraHeaderMbuf::Builder::disownFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t CameraEncodeMbuf::Reader::getSendTimeHigh() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraEncodeMbuf::Builder::getSendTimeHigh() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CameraEncodeMbuf::Builder::setSendTimeHigh( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraEncodeMbuf::Reader::getSendTimeLow() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraEncodeMbuf::Builder::getSendTimeLow() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CameraEncodeMbuf::Builder::setSendTimeLow( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraEncodeMbuf::Reader::getFrameType() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraEncodeMbuf::Builder::getFrameType() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CameraEncodeMbuf::Builder::setFrameType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool CameraEncodeMbuf::Reader::hasVideoFrame() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraEncodeMbuf::Builder::hasVideoFrame() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CameraEncodeMbuf::Reader::getVideoFrame() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CameraEncodeMbuf::Builder::getVideoFrame() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraEncodeMbuf::Builder::setVideoFrame( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CameraEncodeMbuf::Builder::initVideoFrame(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CameraEncodeMbuf::Builder::adoptVideoFrame(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CameraEncodeMbuf::Builder::disownVideoFrame() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t CameraEncodeMbuf::Reader::getDataSize() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraEncodeMbuf::Builder::getDataSize() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void CameraEncodeMbuf::Builder::setDataSize( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CameraEncodeMbuf::Reader::getAdapterId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CameraEncodeMbuf::Builder::getAdapterId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void CameraEncodeMbuf::Builder::setAdapterId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool CameraEncodeMbuf::Reader::hasCameraHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraEncodeMbuf::Builder::hasCameraHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::CameraHeaderMbuf::Reader CameraEncodeMbuf::Reader::getCameraHeader() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeaderMbuf>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::CameraHeaderMbuf::Builder CameraEncodeMbuf::Builder::getCameraHeader() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeaderMbuf>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::CameraHeaderMbuf::Pipeline CameraEncodeMbuf::Pipeline::getCameraHeader() {
  return  ::gac::rscl::CameraHeaderMbuf::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CameraEncodeMbuf::Builder::setCameraHeader( ::gac::rscl::CameraHeaderMbuf::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeaderMbuf>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::CameraHeaderMbuf::Builder CameraEncodeMbuf::Builder::initCameraHeader() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeaderMbuf>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraEncodeMbuf::Builder::adoptCameraHeader(
    ::capnp::Orphan< ::gac::rscl::CameraHeaderMbuf>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeaderMbuf>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::CameraHeaderMbuf> CameraEncodeMbuf::Builder::disownCameraHeader() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::CameraHeaderMbuf>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t DiagReport::Reader::getAppId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t DiagReport::Builder::getAppId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DiagReport::Builder::setAppId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool DiagReport::Reader::hasAlarmID() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DiagReport::Builder::hasAlarmID() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader DiagReport::Reader::getAlarmID() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder DiagReport::Builder::getAlarmID() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DiagReport::Builder::setAlarmID( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void DiagReport::Builder::setAlarmID(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder DiagReport::Builder::initAlarmID(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void DiagReport::Builder::adoptAlarmID(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> DiagReport::Builder::disownAlarmID() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

