// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: radar_a_cm_data_type.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d21265d5164e303e);
CAPNP_DECLARE_SCHEMA(d53e971f4a2d2bfa);
CAPNP_DECLARE_SCHEMA(f411bf2a8d43534b);
CAPNP_DECLARE_SCHEMA(da1fe4b3af5756c5);
CAPNP_DECLARE_SCHEMA(fb29e425aa8e2a0a);
CAPNP_DECLARE_SCHEMA(e21dfc59ec3deedb);
CAPNP_DECLARE_SCHEMA(9f0f69c7d8a03134);

}  // namespace schemas
}  // namespace capnp

namespace gac {
namespace rscl {

struct FloatVector {
  FloatVector() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d21265d5164e303e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GuardnailInfo {
  GuardnailInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d53e971f4a2d2bfa, 5, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Header {
  Header() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f411bf2a8d43534b, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RadarState {
  RadarState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da1fe4b3af5756c5, 5, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Time {
  Time() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb29e425aa8e2a0a, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeStampInfo {
  TimeStampInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e21dfc59ec3deedb, 5, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Version {
  Version() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f0f69c7d8a03134, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class FloatVector::Reader {
public:
  typedef FloatVector Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FloatVector::Builder {
public:
  typedef FloatVector Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FloatVector::Pipeline {
public:
  typedef FloatVector Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GuardnailInfo::Reader {
public:
  typedef GuardnailInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getConfidence() const;

  inline float getDxStart() const;

  inline float getDxEnd() const;

  inline float getGuardnailC0() const;

  inline float getGuardnailC1() const;

  inline float getGuardnailC2() const;

  inline float getGuardnailC3() const;

  inline float getReserved1() const;

  inline float getReserved2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GuardnailInfo::Builder {
public:
  typedef GuardnailInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getConfidence();
  inline void setConfidence(float value);

  inline float getDxStart();
  inline void setDxStart(float value);

  inline float getDxEnd();
  inline void setDxEnd(float value);

  inline float getGuardnailC0();
  inline void setGuardnailC0(float value);

  inline float getGuardnailC1();
  inline void setGuardnailC1(float value);

  inline float getGuardnailC2();
  inline void setGuardnailC2(float value);

  inline float getGuardnailC3();
  inline void setGuardnailC3(float value);

  inline float getReserved1();
  inline void setReserved1(float value);

  inline float getReserved2();
  inline void setReserved2(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GuardnailInfo::Pipeline {
public:
  typedef GuardnailInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Header::Reader {
public:
  typedef Header Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSeq() const;

  inline bool hasStamp() const;
  inline  ::gac::rscl::Time::Reader getStamp() const;

  inline bool hasFrameId() const;
  inline  ::capnp::Text::Reader getFrameId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Header::Builder {
public:
  typedef Header Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSeq();
  inline void setSeq( ::uint32_t value);

  inline bool hasStamp();
  inline  ::gac::rscl::Time::Builder getStamp();
  inline void setStamp( ::gac::rscl::Time::Reader value);
  inline  ::gac::rscl::Time::Builder initStamp();
  inline void adoptStamp(::capnp::Orphan< ::gac::rscl::Time>&& value);
  inline ::capnp::Orphan< ::gac::rscl::Time> disownStamp();

  inline bool hasFrameId();
  inline  ::capnp::Text::Builder getFrameId();
  inline void setFrameId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFrameId(unsigned int size);
  inline void adoptFrameId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFrameId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Header::Pipeline {
public:
  typedef Header Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::gac::rscl::Time::Pipeline getStamp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RadarState::Reader {
public:
  typedef RadarState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getSensorId() const;

  inline  ::uint8_t getNvmReadStatus() const;

  inline  ::uint8_t getNvmWriteStatus() const;

  inline  ::uint8_t getPersistentError() const;

  inline  ::uint8_t getTemporaryError() const;

  inline  ::uint8_t getInterferenceError() const;

  inline  ::uint8_t getTemperatureError() const;

  inline  ::uint8_t getVoltageError() const;

  inline  ::uint16_t getMaxDistance() const;

  inline  ::uint8_t getSortIndex() const;

  inline  ::uint8_t getRadarPower() const;

  inline  ::uint8_t getCtrlRelay() const;

  inline  ::uint8_t getOutputType() const;

  inline  ::uint8_t getSendQuality() const;

  inline  ::uint8_t getSendExtinfo() const;

  inline  ::uint8_t getMotionRxState() const;

  inline  ::uint8_t getRcsThreshold() const;

  inline  ::uint8_t getBlockError() const;

  inline  ::uint8_t getBroadcastError() const;

  inline  ::uint8_t getElectricAxisError() const;

  inline  ::uint8_t getConfigError() const;

  inline  ::uint8_t getCalibrationError() const;

  inline  ::uint8_t getConnectorDirection() const;

  inline  ::uint8_t getCan0WorkMode() const;

  inline  ::uint8_t getCan1WorkMode() const;

  inline  ::uint8_t getDualCanMode() const;

  inline  ::uint8_t getTimmingMode() const;

  inline  ::uint8_t getPowerMode() const;

  inline  ::uint8_t getPerformanceMode() const;

  inline  ::uint8_t getRadarPosition() const;

  inline  ::uint8_t getHwError() const;

  inline  ::uint8_t getModulationStatus() const;

  inline  ::uint8_t getFailureFlag() const;

  inline  ::uint8_t getSleepSig() const;

  inline float getObjAziAngleCalib() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RadarState::Builder {
public:
  typedef RadarState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getSensorId();
  inline void setSensorId( ::uint8_t value);

  inline  ::uint8_t getNvmReadStatus();
  inline void setNvmReadStatus( ::uint8_t value);

  inline  ::uint8_t getNvmWriteStatus();
  inline void setNvmWriteStatus( ::uint8_t value);

  inline  ::uint8_t getPersistentError();
  inline void setPersistentError( ::uint8_t value);

  inline  ::uint8_t getTemporaryError();
  inline void setTemporaryError( ::uint8_t value);

  inline  ::uint8_t getInterferenceError();
  inline void setInterferenceError( ::uint8_t value);

  inline  ::uint8_t getTemperatureError();
  inline void setTemperatureError( ::uint8_t value);

  inline  ::uint8_t getVoltageError();
  inline void setVoltageError( ::uint8_t value);

  inline  ::uint16_t getMaxDistance();
  inline void setMaxDistance( ::uint16_t value);

  inline  ::uint8_t getSortIndex();
  inline void setSortIndex( ::uint8_t value);

  inline  ::uint8_t getRadarPower();
  inline void setRadarPower( ::uint8_t value);

  inline  ::uint8_t getCtrlRelay();
  inline void setCtrlRelay( ::uint8_t value);

  inline  ::uint8_t getOutputType();
  inline void setOutputType( ::uint8_t value);

  inline  ::uint8_t getSendQuality();
  inline void setSendQuality( ::uint8_t value);

  inline  ::uint8_t getSendExtinfo();
  inline void setSendExtinfo( ::uint8_t value);

  inline  ::uint8_t getMotionRxState();
  inline void setMotionRxState( ::uint8_t value);

  inline  ::uint8_t getRcsThreshold();
  inline void setRcsThreshold( ::uint8_t value);

  inline  ::uint8_t getBlockError();
  inline void setBlockError( ::uint8_t value);

  inline  ::uint8_t getBroadcastError();
  inline void setBroadcastError( ::uint8_t value);

  inline  ::uint8_t getElectricAxisError();
  inline void setElectricAxisError( ::uint8_t value);

  inline  ::uint8_t getConfigError();
  inline void setConfigError( ::uint8_t value);

  inline  ::uint8_t getCalibrationError();
  inline void setCalibrationError( ::uint8_t value);

  inline  ::uint8_t getConnectorDirection();
  inline void setConnectorDirection( ::uint8_t value);

  inline  ::uint8_t getCan0WorkMode();
  inline void setCan0WorkMode( ::uint8_t value);

  inline  ::uint8_t getCan1WorkMode();
  inline void setCan1WorkMode( ::uint8_t value);

  inline  ::uint8_t getDualCanMode();
  inline void setDualCanMode( ::uint8_t value);

  inline  ::uint8_t getTimmingMode();
  inline void setTimmingMode( ::uint8_t value);

  inline  ::uint8_t getPowerMode();
  inline void setPowerMode( ::uint8_t value);

  inline  ::uint8_t getPerformanceMode();
  inline void setPerformanceMode( ::uint8_t value);

  inline  ::uint8_t getRadarPosition();
  inline void setRadarPosition( ::uint8_t value);

  inline  ::uint8_t getHwError();
  inline void setHwError( ::uint8_t value);

  inline  ::uint8_t getModulationStatus();
  inline void setModulationStatus( ::uint8_t value);

  inline  ::uint8_t getFailureFlag();
  inline void setFailureFlag( ::uint8_t value);

  inline  ::uint8_t getSleepSig();
  inline void setSleepSig( ::uint8_t value);

  inline float getObjAziAngleCalib();
  inline void setObjAziAngleCalib(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RadarState::Pipeline {
public:
  typedef RadarState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Time::Reader {
public:
  typedef Time Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSec() const;

  inline  ::uint32_t getNsec() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Time::Builder {
public:
  typedef Time Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSec();
  inline void setSec( ::uint32_t value);

  inline  ::uint32_t getNsec();
  inline void setNsec( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Time::Pipeline {
public:
  typedef Time Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeStampInfo::Reader {
public:
  typedef TimeStampInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getTimeStampStatus() const;

  inline  ::uint64_t getTimeStamp() const;

  inline  ::uint64_t getAutoSarTimeStamp() const;

  inline  ::uint64_t getReserved1() const;

  inline  ::uint64_t getReserved2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeStampInfo::Builder {
public:
  typedef TimeStampInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getTimeStampStatus();
  inline void setTimeStampStatus( ::uint16_t value);

  inline  ::uint64_t getTimeStamp();
  inline void setTimeStamp( ::uint64_t value);

  inline  ::uint64_t getAutoSarTimeStamp();
  inline void setAutoSarTimeStamp( ::uint64_t value);

  inline  ::uint64_t getReserved1();
  inline void setReserved1( ::uint64_t value);

  inline  ::uint64_t getReserved2();
  inline void setReserved2( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeStampInfo::Pipeline {
public:
  typedef TimeStampInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Version::Reader {
public:
  typedef Version Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getMajor() const;

  inline  ::uint8_t getMinor() const;

  inline  ::uint8_t getPatch() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Version::Builder {
public:
  typedef Version Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getMajor();
  inline void setMajor( ::uint8_t value);

  inline  ::uint8_t getMinor();
  inline void setMinor( ::uint8_t value);

  inline  ::uint8_t getPatch();
  inline void setPatch( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Version::Pipeline {
public:
  typedef Version Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool FloatVector::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FloatVector::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader FloatVector::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FloatVector::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FloatVector::Builder::setData( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void FloatVector::Builder::setData(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FloatVector::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FloatVector::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> FloatVector::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float GuardnailInfo::Reader::getConfidence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getConfidence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setConfidence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getDxStart() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getDxStart() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setDxStart(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getDxEnd() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getDxEnd() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setDxEnd(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getGuardnailC0() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getGuardnailC0() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setGuardnailC0(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getGuardnailC1() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getGuardnailC1() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setGuardnailC1(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getGuardnailC2() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getGuardnailC2() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setGuardnailC2(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getGuardnailC3() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getGuardnailC3() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setGuardnailC3(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getReserved1() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getReserved1() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setReserved1(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float GuardnailInfo::Reader::getReserved2() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float GuardnailInfo::Builder::getReserved2() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void GuardnailInfo::Builder::setReserved2(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Header::Reader::getSeq() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Header::Builder::getSeq() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Header::Builder::setSeq( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Header::Reader::hasStamp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Header::Builder::hasStamp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::gac::rscl::Time::Reader Header::Reader::getStamp() const {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Time>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::gac::rscl::Time::Builder Header::Builder::getStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Time>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::gac::rscl::Time::Pipeline Header::Pipeline::getStamp() {
  return  ::gac::rscl::Time::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Header::Builder::setStamp( ::gac::rscl::Time::Reader value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Time>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::gac::rscl::Time::Builder Header::Builder::initStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Time>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Header::Builder::adoptStamp(
    ::capnp::Orphan< ::gac::rscl::Time>&& value) {
  ::capnp::_::PointerHelpers< ::gac::rscl::Time>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::gac::rscl::Time> Header::Builder::disownStamp() {
  return ::capnp::_::PointerHelpers< ::gac::rscl::Time>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Header::Reader::hasFrameId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Header::Builder::hasFrameId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Header::Reader::getFrameId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Header::Builder::getFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Header::Builder::setFrameId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Header::Builder::initFrameId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Header::Builder::adoptFrameId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Header::Builder::disownFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t RadarState::Reader::getSensorId() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getSensorId() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setSensorId( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getNvmReadStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getNvmReadStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setNvmReadStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getNvmWriteStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getNvmWriteStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setNvmWriteStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getPersistentError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getPersistentError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setPersistentError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getTemporaryError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getTemporaryError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setTemporaryError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getInterferenceError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getInterferenceError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setInterferenceError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getTemperatureError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getTemperatureError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setTemperatureError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getVoltageError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getVoltageError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setVoltageError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RadarState::Reader::getMaxDistance() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RadarState::Builder::getMaxDistance() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setMaxDistance( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getSortIndex() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getSortIndex() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setSortIndex( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getRadarPower() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getRadarPower() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setRadarPower( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getCtrlRelay() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getCtrlRelay() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setCtrlRelay( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getOutputType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getOutputType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setOutputType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getSendQuality() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getSendQuality() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setSendQuality( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getSendExtinfo() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getSendExtinfo() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setSendExtinfo( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getMotionRxState() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getMotionRxState() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setMotionRxState( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getRcsThreshold() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getRcsThreshold() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setRcsThreshold( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getBlockError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getBlockError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setBlockError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getBroadcastError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getBroadcastError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setBroadcastError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getElectricAxisError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getElectricAxisError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setElectricAxisError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getConfigError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getConfigError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setConfigError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getCalibrationError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<22>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getCalibrationError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<22>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setCalibrationError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<22>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getConnectorDirection() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<23>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getConnectorDirection() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<23>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setConnectorDirection( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<23>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getCan0WorkMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getCan0WorkMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setCan0WorkMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<24>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getCan1WorkMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<25>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getCan1WorkMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<25>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setCan1WorkMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<25>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getDualCanMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<26>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getDualCanMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<26>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setDualCanMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<26>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getTimmingMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<27>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getTimmingMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<27>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setTimmingMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<27>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getPowerMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<28>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getPowerMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<28>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setPowerMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<28>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getPerformanceMode() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<29>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getPerformanceMode() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<29>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setPerformanceMode( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<29>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getRadarPosition() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<30>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getRadarPosition() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<30>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setRadarPosition( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<30>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getHwError() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<31>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getHwError() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<31>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setHwError( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<31>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getModulationStatus() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getModulationStatus() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setModulationStatus( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getFailureFlag() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getFailureFlag() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setFailureFlag( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RadarState::Reader::getSleepSig() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RadarState::Builder::getSleepSig() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setSleepSig( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS, value);
}

inline float RadarState::Reader::getObjAziAngleCalib() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float RadarState::Builder::getObjAziAngleCalib() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void RadarState::Builder::setObjAziAngleCalib(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Time::Reader::getSec() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Time::Builder::getSec() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Time::Builder::setSec( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Time::Reader::getNsec() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Time::Builder::getNsec() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Time::Builder::setNsec( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TimeStampInfo::Reader::getTimeStampStatus() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TimeStampInfo::Builder::getTimeStampStatus() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimeStampInfo::Builder::setTimeStampStatus( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TimeStampInfo::Reader::getTimeStamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TimeStampInfo::Builder::getTimeStamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TimeStampInfo::Builder::setTimeStamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TimeStampInfo::Reader::getAutoSarTimeStamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TimeStampInfo::Builder::getAutoSarTimeStamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TimeStampInfo::Builder::setAutoSarTimeStamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TimeStampInfo::Reader::getReserved1() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TimeStampInfo::Builder::getReserved1() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TimeStampInfo::Builder::setReserved1( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TimeStampInfo::Reader::getReserved2() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TimeStampInfo::Builder::getReserved2() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TimeStampInfo::Builder::setReserved2( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Version::Reader::getMajor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Version::Builder::getMajor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Version::Builder::setMajor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Version::Reader::getMinor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Version::Builder::getMinor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Version::Builder::setMinor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Version::Reader::getPatch() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Version::Builder::getPatch() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Version::Builder::setPatch( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

