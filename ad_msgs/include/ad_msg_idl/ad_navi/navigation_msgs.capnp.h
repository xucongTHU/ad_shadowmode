// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: navigation_msgs.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <ad_msg_idl/std_msgs/header.capnp.h>

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(8312c57670b53abe);
CAPNP_DECLARE_SCHEMA(ec33753183540493);
CAPNP_DECLARE_SCHEMA(ed1bfa8a8874d17c);
CAPNP_DECLARE_SCHEMA(dae11ebbd99f6227);
CAPNP_DECLARE_SCHEMA(fada1876b8468886);
CAPNP_DECLARE_SCHEMA(81f0ccbf70d74f61);
CAPNP_DECLARE_SCHEMA(dd3158ec030b4a37);
CAPNP_DECLARE_SCHEMA(c2fe3b604e53953b);
CAPNP_DECLARE_SCHEMA(f71c659fa284a730);
CAPNP_DECLARE_SCHEMA(f0f29fa8999adf9a);
CAPNP_DECLARE_SCHEMA(c928b9fb27f77bcb);
CAPNP_DECLARE_SCHEMA(b404f1c6b8ae65b5);
CAPNP_DECLARE_SCHEMA(b3ff851ce1e05c97);
CAPNP_DECLARE_SCHEMA(d130002bbf452cf4);
CAPNP_DECLARE_SCHEMA(e334f8f216d803c6);

}  // namespace schemas
}  // namespace capnp

namespace senseAD {
namespace msg {
namespace navigation {

struct LocationPos {
  LocationPos() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8312c57670b53abe, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TencentRoute {
  TencentRoute() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec33753183540493, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RouteGuidance {
  RouteGuidance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed1bfa8a8874d17c, 4, 9)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct EntExitInfo {
  EntExitInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dae11ebbd99f6227, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneInfo {
  LaneInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fada1876b8468886, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RoutePos {
  RoutePos() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81f0ccbf70d74f61, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LaneData {
  LaneData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd3158ec030b4a37, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrafficLight {
  TrafficLight() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2fe3b604e53953b, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MultiLightBubbleInfo {
  MultiLightBubbleInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f71c659fa284a730, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OneLight {
  OneLight() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f0f29fa8999adf9a, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GeoCoordinateZ {
  GeoCoordinateZ() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c928b9fb27f77bcb, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SpeedLimit {
  SpeedLimit() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b404f1c6b8ae65b5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NaviSegment {
  NaviSegment() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3ff851ce1e05c97, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NaviSegmentList {
  NaviSegmentList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d130002bbf452cf4, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TTSInfo {
  TTSInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e334f8f216d803c6, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class LocationPos::Reader {
public:
  typedef LocationPos Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getLongitude() const;

  inline double getLatitude() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LocationPos::Builder {
public:
  typedef LocationPos Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getLongitude();
  inline void setLongitude(double value);

  inline double getLatitude();
  inline void setLatitude(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LocationPos::Pipeline {
public:
  typedef LocationPos Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TencentRoute::Reader {
public:
  typedef TencentRoute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLinkIds() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getLinkIds() const;

  inline bool hasRoutes() const;
  inline  ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Reader getRoutes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TencentRoute::Builder {
public:
  typedef TencentRoute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLinkIds();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getLinkIds();
  inline void setLinkIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setLinkIds(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initLinkIds(unsigned int size);
  inline void adoptLinkIds(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownLinkIds();

  inline bool hasRoutes();
  inline  ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Builder getRoutes();
  inline void setRoutes( ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Builder initRoutes(unsigned int size);
  inline void adoptRoutes(::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>> disownRoutes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TencentRoute::Pipeline {
public:
  typedef TencentRoute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RouteGuidance::Reader {
public:
  typedef RouteGuidance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasIntersectionPos() const;
  inline  ::senseAD::msg::navigation::RoutePos::Reader getIntersectionPos() const;

  inline bool getMatchResult() const;

  inline  ::uint16_t getNextIntersectionType() const;

  inline  ::uint16_t getNextSpecIntersectionType() const;

  inline  ::uint16_t getNewRemainDistance() const;

  inline bool hasPointId() const;
  inline  ::capnp::Text::Reader getPointId() const;

  inline  ::uint16_t getNextIntersectionRemainDistance() const;

  inline  ::uint16_t getTotalRemainDistance() const;

  inline  ::uint16_t getSegmentLength() const;

  inline  ::uint8_t getHintType() const;

  inline bool hasEnterPosA() const;
  inline  ::senseAD::msg::navigation::RoutePos::Reader getEnterPosA() const;

  inline bool hasLeavePosB() const;
  inline  ::senseAD::msg::navigation::RoutePos::Reader getLeavePosB() const;

  inline  ::uint16_t getActionLength() const;

  inline  ::uint16_t getTunnelLength() const;

  inline bool getHasCloseTurn() const;

  inline  ::uint16_t getCloseIntersectionType() const;

  inline  ::uint16_t getCloseIntersectionLength() const;

  inline bool hasCloseIntersectionPos() const;
  inline  ::senseAD::msg::navigation::RoutePos::Reader getCloseIntersectionPos() const;

  inline  ::uint16_t getNextSegmentLength() const;

  inline  ::uint16_t getLimitSpeedKmph() const;

  inline bool hasHighwayEntranceInfo() const;
  inline  ::senseAD::msg::navigation::EntExitInfo::Reader getHighwayEntranceInfo() const;

  inline bool hasHighwayExitInfo() const;
  inline  ::senseAD::msg::navigation::EntExitInfo::Reader getHighwayExitInfo() const;

  inline bool hasIntersectionLaneInfo() const;
  inline  ::senseAD::msg::navigation::LaneInfo::Reader getIntersectionLaneInfo() const;

  inline  ::uint16_t getCurSegmentIndex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RouteGuidance::Builder {
public:
  typedef RouteGuidance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasIntersectionPos();
  inline  ::senseAD::msg::navigation::RoutePos::Builder getIntersectionPos();
  inline void setIntersectionPos( ::senseAD::msg::navigation::RoutePos::Reader value);
  inline  ::senseAD::msg::navigation::RoutePos::Builder initIntersectionPos();
  inline void adoptIntersectionPos(::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> disownIntersectionPos();

  inline bool getMatchResult();
  inline void setMatchResult(bool value);

  inline  ::uint16_t getNextIntersectionType();
  inline void setNextIntersectionType( ::uint16_t value);

  inline  ::uint16_t getNextSpecIntersectionType();
  inline void setNextSpecIntersectionType( ::uint16_t value);

  inline  ::uint16_t getNewRemainDistance();
  inline void setNewRemainDistance( ::uint16_t value);

  inline bool hasPointId();
  inline  ::capnp::Text::Builder getPointId();
  inline void setPointId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPointId(unsigned int size);
  inline void adoptPointId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPointId();

  inline  ::uint16_t getNextIntersectionRemainDistance();
  inline void setNextIntersectionRemainDistance( ::uint16_t value);

  inline  ::uint16_t getTotalRemainDistance();
  inline void setTotalRemainDistance( ::uint16_t value);

  inline  ::uint16_t getSegmentLength();
  inline void setSegmentLength( ::uint16_t value);

  inline  ::uint8_t getHintType();
  inline void setHintType( ::uint8_t value);

  inline bool hasEnterPosA();
  inline  ::senseAD::msg::navigation::RoutePos::Builder getEnterPosA();
  inline void setEnterPosA( ::senseAD::msg::navigation::RoutePos::Reader value);
  inline  ::senseAD::msg::navigation::RoutePos::Builder initEnterPosA();
  inline void adoptEnterPosA(::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> disownEnterPosA();

  inline bool hasLeavePosB();
  inline  ::senseAD::msg::navigation::RoutePos::Builder getLeavePosB();
  inline void setLeavePosB( ::senseAD::msg::navigation::RoutePos::Reader value);
  inline  ::senseAD::msg::navigation::RoutePos::Builder initLeavePosB();
  inline void adoptLeavePosB(::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> disownLeavePosB();

  inline  ::uint16_t getActionLength();
  inline void setActionLength( ::uint16_t value);

  inline  ::uint16_t getTunnelLength();
  inline void setTunnelLength( ::uint16_t value);

  inline bool getHasCloseTurn();
  inline void setHasCloseTurn(bool value);

  inline  ::uint16_t getCloseIntersectionType();
  inline void setCloseIntersectionType( ::uint16_t value);

  inline  ::uint16_t getCloseIntersectionLength();
  inline void setCloseIntersectionLength( ::uint16_t value);

  inline bool hasCloseIntersectionPos();
  inline  ::senseAD::msg::navigation::RoutePos::Builder getCloseIntersectionPos();
  inline void setCloseIntersectionPos( ::senseAD::msg::navigation::RoutePos::Reader value);
  inline  ::senseAD::msg::navigation::RoutePos::Builder initCloseIntersectionPos();
  inline void adoptCloseIntersectionPos(::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> disownCloseIntersectionPos();

  inline  ::uint16_t getNextSegmentLength();
  inline void setNextSegmentLength( ::uint16_t value);

  inline  ::uint16_t getLimitSpeedKmph();
  inline void setLimitSpeedKmph( ::uint16_t value);

  inline bool hasHighwayEntranceInfo();
  inline  ::senseAD::msg::navigation::EntExitInfo::Builder getHighwayEntranceInfo();
  inline void setHighwayEntranceInfo( ::senseAD::msg::navigation::EntExitInfo::Reader value);
  inline  ::senseAD::msg::navigation::EntExitInfo::Builder initHighwayEntranceInfo();
  inline void adoptHighwayEntranceInfo(::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo> disownHighwayEntranceInfo();

  inline bool hasHighwayExitInfo();
  inline  ::senseAD::msg::navigation::EntExitInfo::Builder getHighwayExitInfo();
  inline void setHighwayExitInfo( ::senseAD::msg::navigation::EntExitInfo::Reader value);
  inline  ::senseAD::msg::navigation::EntExitInfo::Builder initHighwayExitInfo();
  inline void adoptHighwayExitInfo(::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo> disownHighwayExitInfo();

  inline bool hasIntersectionLaneInfo();
  inline  ::senseAD::msg::navigation::LaneInfo::Builder getIntersectionLaneInfo();
  inline void setIntersectionLaneInfo( ::senseAD::msg::navigation::LaneInfo::Reader value);
  inline  ::senseAD::msg::navigation::LaneInfo::Builder initIntersectionLaneInfo();
  inline void adoptIntersectionLaneInfo(::capnp::Orphan< ::senseAD::msg::navigation::LaneInfo>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::LaneInfo> disownIntersectionLaneInfo();

  inline  ::uint16_t getCurSegmentIndex();
  inline void setCurSegmentIndex( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RouteGuidance::Pipeline {
public:
  typedef RouteGuidance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
  inline  ::senseAD::msg::navigation::RoutePos::Pipeline getIntersectionPos();
  inline  ::senseAD::msg::navigation::RoutePos::Pipeline getEnterPosA();
  inline  ::senseAD::msg::navigation::RoutePos::Pipeline getLeavePosB();
  inline  ::senseAD::msg::navigation::RoutePos::Pipeline getCloseIntersectionPos();
  inline  ::senseAD::msg::navigation::EntExitInfo::Pipeline getHighwayEntranceInfo();
  inline  ::senseAD::msg::navigation::EntExitInfo::Pipeline getHighwayExitInfo();
  inline  ::senseAD::msg::navigation::LaneInfo::Pipeline getIntersectionLaneInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class EntExitInfo::Reader {
public:
  typedef EntExitInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getId() const;

  inline bool hasRoutePos() const;
  inline  ::senseAD::msg::navigation::RoutePos::Reader getRoutePos() const;

  inline bool hasNameInfo() const;
  inline  ::capnp::Text::Reader getNameInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class EntExitInfo::Builder {
public:
  typedef EntExitInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getId();
  inline void setId( ::uint16_t value);

  inline bool hasRoutePos();
  inline  ::senseAD::msg::navigation::RoutePos::Builder getRoutePos();
  inline void setRoutePos( ::senseAD::msg::navigation::RoutePos::Reader value);
  inline  ::senseAD::msg::navigation::RoutePos::Builder initRoutePos();
  inline void adoptRoutePos(::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> disownRoutePos();

  inline bool hasNameInfo();
  inline  ::capnp::Text::Builder getNameInfo();
  inline void setNameInfo( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initNameInfo(unsigned int size);
  inline void adoptNameInfo(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownNameInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class EntExitInfo::Pipeline {
public:
  typedef EntExitInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::navigation::RoutePos::Pipeline getRoutePos();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneInfo::Reader {
public:
  typedef LaneInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasPosition() const;
  inline  ::senseAD::msg::navigation::RoutePos::Reader getPosition() const;

  inline  ::uint16_t getDistanceToRouteEnd() const;

  inline bool hasLanesData() const;
  inline  ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Reader getLanesData() const;

  inline bool hasRecommendLanes() const;
  inline  ::capnp::Text::Reader getRecommendLanes() const;

  inline  ::uint8_t getLaneNumLeft() const;

  inline  ::uint8_t getLaneNumRight() const;

  inline bool getIsValidLaneInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneInfo::Builder {
public:
  typedef LaneInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasPosition();
  inline  ::senseAD::msg::navigation::RoutePos::Builder getPosition();
  inline void setPosition( ::senseAD::msg::navigation::RoutePos::Reader value);
  inline  ::senseAD::msg::navigation::RoutePos::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> disownPosition();

  inline  ::uint16_t getDistanceToRouteEnd();
  inline void setDistanceToRouteEnd( ::uint16_t value);

  inline bool hasLanesData();
  inline  ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Builder getLanesData();
  inline void setLanesData( ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Builder initLanesData(unsigned int size);
  inline void adoptLanesData(::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>> disownLanesData();

  inline bool hasRecommendLanes();
  inline  ::capnp::Text::Builder getRecommendLanes();
  inline void setRecommendLanes( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRecommendLanes(unsigned int size);
  inline void adoptRecommendLanes(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRecommendLanes();

  inline  ::uint8_t getLaneNumLeft();
  inline void setLaneNumLeft( ::uint8_t value);

  inline  ::uint8_t getLaneNumRight();
  inline void setLaneNumRight( ::uint8_t value);

  inline bool getIsValidLaneInfo();
  inline void setIsValidLaneInfo(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneInfo::Pipeline {
public:
  typedef LaneInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
  inline  ::senseAD::msg::navigation::RoutePos::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RoutePos::Reader {
public:
  typedef RoutePos Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCoorStart() const;

  inline double getLongitude() const;

  inline double getLatitude() const;

  inline float getAltitude() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RoutePos::Builder {
public:
  typedef RoutePos Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCoorStart();
  inline void setCoorStart( ::int32_t value);

  inline double getLongitude();
  inline void setLongitude(double value);

  inline double getLatitude();
  inline void setLatitude(double value);

  inline float getAltitude();
  inline void setAltitude(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RoutePos::Pipeline {
public:
  typedef RoutePos Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LaneData::Reader {
public:
  typedef LaneData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLaneFlag() const;
  inline  ::capnp::Text::Reader getLaneFlag() const;

  inline bool hasLaneArrow() const;
  inline  ::capnp::Text::Reader getLaneArrow() const;

  inline bool hasLaneProperty() const;
  inline  ::capnp::Text::Reader getLaneProperty() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LaneData::Builder {
public:
  typedef LaneData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLaneFlag();
  inline  ::capnp::Text::Builder getLaneFlag();
  inline void setLaneFlag( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLaneFlag(unsigned int size);
  inline void adoptLaneFlag(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLaneFlag();

  inline bool hasLaneArrow();
  inline  ::capnp::Text::Builder getLaneArrow();
  inline void setLaneArrow( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLaneArrow(unsigned int size);
  inline void adoptLaneArrow(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLaneArrow();

  inline bool hasLaneProperty();
  inline  ::capnp::Text::Builder getLaneProperty();
  inline void setLaneProperty( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLaneProperty(unsigned int size);
  inline void adoptLaneProperty(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLaneProperty();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LaneData::Pipeline {
public:
  typedef LaneData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrafficLight::Reader {
public:
  typedef TrafficLight Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasMultiLightInfo() const;
  inline  ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Reader getMultiLightInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrafficLight::Builder {
public:
  typedef TrafficLight Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasMultiLightInfo();
  inline  ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Builder getMultiLightInfo();
  inline void setMultiLightInfo( ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Builder initMultiLightInfo(unsigned int size);
  inline void adoptMultiLightInfo(::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>> disownMultiLightInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrafficLight::Pipeline {
public:
  typedef TrafficLight Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MultiLightBubbleInfo::Reader {
public:
  typedef MultiLightBubbleInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPoint() const;
  inline  ::senseAD::msg::navigation::GeoCoordinateZ::Reader getPoint() const;

  inline bool hasLightInfo() const;
  inline  ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Reader getLightInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MultiLightBubbleInfo::Builder {
public:
  typedef MultiLightBubbleInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPoint();
  inline  ::senseAD::msg::navigation::GeoCoordinateZ::Builder getPoint();
  inline void setPoint( ::senseAD::msg::navigation::GeoCoordinateZ::Reader value);
  inline  ::senseAD::msg::navigation::GeoCoordinateZ::Builder initPoint();
  inline void adoptPoint(::capnp::Orphan< ::senseAD::msg::navigation::GeoCoordinateZ>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::navigation::GeoCoordinateZ> disownPoint();

  inline bool hasLightInfo();
  inline  ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Builder getLightInfo();
  inline void setLightInfo( ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Builder initLightInfo(unsigned int size);
  inline void adoptLightInfo(::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>> disownLightInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MultiLightBubbleInfo::Pipeline {
public:
  typedef MultiLightBubbleInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::navigation::GeoCoordinateZ::Pipeline getPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OneLight::Reader {
public:
  typedef OneLight Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getLightType() const;

  inline  ::uint8_t getTurnArrowType() const;

  inline  ::uint8_t getRemainTime() const;

  inline  ::uint8_t getTotalTime() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OneLight::Builder {
public:
  typedef OneLight Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getLightType();
  inline void setLightType( ::uint8_t value);

  inline  ::uint8_t getTurnArrowType();
  inline void setTurnArrowType( ::uint8_t value);

  inline  ::uint8_t getRemainTime();
  inline void setRemainTime( ::uint8_t value);

  inline  ::uint8_t getTotalTime();
  inline void setTotalTime( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OneLight::Pipeline {
public:
  typedef OneLight Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GeoCoordinateZ::Reader {
public:
  typedef GeoCoordinateZ Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getLongitude() const;

  inline double getLatitude() const;

  inline float getAltitude() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeoCoordinateZ::Builder {
public:
  typedef GeoCoordinateZ Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getLongitude();
  inline void setLongitude(double value);

  inline double getLatitude();
  inline void setLatitude(double value);

  inline float getAltitude();
  inline void setAltitude(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeoCoordinateZ::Pipeline {
public:
  typedef GeoCoordinateZ Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SpeedLimit::Reader {
public:
  typedef SpeedLimit Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline  ::uint8_t getLimitSpeedKmph() const;

  inline  ::uint8_t getSpeedLimit() const;

  inline  ::uint8_t getAverageSpeedKmph() const;

  inline  ::uint16_t getRemainLength() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SpeedLimit::Builder {
public:
  typedef SpeedLimit Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline  ::uint8_t getLimitSpeedKmph();
  inline void setLimitSpeedKmph( ::uint8_t value);

  inline  ::uint8_t getSpeedLimit();
  inline void setSpeedLimit( ::uint8_t value);

  inline  ::uint8_t getAverageSpeedKmph();
  inline void setAverageSpeedKmph( ::uint8_t value);

  inline  ::uint16_t getRemainLength();
  inline void setRemainLength( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SpeedLimit::Pipeline {
public:
  typedef SpeedLimit Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NaviSegment::Reader {
public:
  typedef NaviSegment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getIntersectionType() const;

  inline  ::uint16_t getSegmentLength() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NaviSegment::Builder {
public:
  typedef NaviSegment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getIntersectionType();
  inline void setIntersectionType( ::uint16_t value);

  inline  ::uint16_t getSegmentLength();
  inline void setSegmentLength( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NaviSegment::Pipeline {
public:
  typedef NaviSegment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NaviSegmentList::Reader {
public:
  typedef NaviSegmentList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline bool hasSegmentList() const;
  inline  ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Reader getSegmentList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NaviSegmentList::Builder {
public:
  typedef NaviSegmentList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline bool hasSegmentList();
  inline  ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Builder getSegmentList();
  inline void setSegmentList( ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Builder initSegmentList(unsigned int size);
  inline void adoptSegmentList(::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>> disownSegmentList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NaviSegmentList::Pipeline {
public:
  typedef NaviSegmentList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TTSInfo::Reader {
public:
  typedef TTSInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::senseAD::msg::std_msgs::Header::Reader getHeader() const;

  inline  ::uint16_t getTtsType() const;

  inline  ::uint16_t getTtsSubType() const;

  inline bool hasTtsVoiceText() const;
  inline  ::capnp::Text::Reader getTtsVoiceText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TTSInfo::Builder {
public:
  typedef TTSInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::senseAD::msg::std_msgs::Header::Builder getHeader();
  inline void setHeader( ::senseAD::msg::std_msgs::Header::Reader value);
  inline  ::senseAD::msg::std_msgs::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value);
  inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> disownHeader();

  inline  ::uint16_t getTtsType();
  inline void setTtsType( ::uint16_t value);

  inline  ::uint16_t getTtsSubType();
  inline void setTtsSubType( ::uint16_t value);

  inline bool hasTtsVoiceText();
  inline  ::capnp::Text::Builder getTtsVoiceText();
  inline void setTtsVoiceText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTtsVoiceText(unsigned int size);
  inline void adoptTtsVoiceText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTtsVoiceText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TTSInfo::Pipeline {
public:
  typedef TTSInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::senseAD::msg::std_msgs::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline double LocationPos::Reader::getLongitude() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double LocationPos::Builder::getLongitude() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LocationPos::Builder::setLongitude(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double LocationPos::Reader::getLatitude() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double LocationPos::Builder::getLatitude() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LocationPos::Builder::setLatitude(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TencentRoute::Reader::hasLinkIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TencentRoute::Builder::hasLinkIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader TencentRoute::Reader::getLinkIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder TencentRoute::Builder::getLinkIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TencentRoute::Builder::setLinkIds( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TencentRoute::Builder::setLinkIds(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder TencentRoute::Builder::initLinkIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TencentRoute::Builder::adoptLinkIds(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> TencentRoute::Builder::disownLinkIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TencentRoute::Reader::hasRoutes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TencentRoute::Builder::hasRoutes() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Reader TencentRoute::Reader::getRoutes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Builder TencentRoute::Builder::getRoutes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TencentRoute::Builder::setRoutes( ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>::Builder TencentRoute::Builder::initRoutes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TencentRoute::Builder::adoptRoutes(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>> TencentRoute::Builder::disownRoutes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LocationPos,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RouteGuidance::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader RouteGuidance::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder RouteGuidance::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline RouteGuidance::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder RouteGuidance::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> RouteGuidance::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RouteGuidance::Reader::hasIntersectionPos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasIntersectionPos() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::RoutePos::Reader RouteGuidance::Reader::getIntersectionPos() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::getIntersectionPos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::RoutePos::Pipeline RouteGuidance::Pipeline::getIntersectionPos() {
  return  ::senseAD::msg::navigation::RoutePos::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setIntersectionPos( ::senseAD::msg::navigation::RoutePos::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::initIntersectionPos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptIntersectionPos(
    ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> RouteGuidance::Builder::disownIntersectionPos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RouteGuidance::Reader::getMatchResult() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool RouteGuidance::Builder::getMatchResult() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setMatchResult(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getNextIntersectionType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getNextIntersectionType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setNextIntersectionType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getNextSpecIntersectionType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getNextSpecIntersectionType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setNextSpecIntersectionType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getNewRemainDistance() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getNewRemainDistance() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setNewRemainDistance( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool RouteGuidance::Reader::hasPointId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasPointId() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RouteGuidance::Reader::getPointId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RouteGuidance::Builder::getPointId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::setPointId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RouteGuidance::Builder::initPointId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void RouteGuidance::Builder::adoptPointId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RouteGuidance::Builder::disownPointId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint16_t RouteGuidance::Reader::getNextIntersectionRemainDistance() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getNextIntersectionRemainDistance() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setNextIntersectionRemainDistance( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getTotalRemainDistance() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getTotalRemainDistance() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setTotalRemainDistance( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getSegmentLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getSegmentLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setSegmentLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t RouteGuidance::Reader::getHintType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RouteGuidance::Builder::getHintType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setHintType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RouteGuidance::Reader::hasEnterPosA() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasEnterPosA() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::RoutePos::Reader RouteGuidance::Reader::getEnterPosA() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::getEnterPosA() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::RoutePos::Pipeline RouteGuidance::Pipeline::getEnterPosA() {
  return  ::senseAD::msg::navigation::RoutePos::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setEnterPosA( ::senseAD::msg::navigation::RoutePos::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::initEnterPosA() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptEnterPosA(
    ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> RouteGuidance::Builder::disownEnterPosA() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool RouteGuidance::Reader::hasLeavePosB() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasLeavePosB() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::RoutePos::Reader RouteGuidance::Reader::getLeavePosB() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::getLeavePosB() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::RoutePos::Pipeline RouteGuidance::Pipeline::getLeavePosB() {
  return  ::senseAD::msg::navigation::RoutePos::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setLeavePosB( ::senseAD::msg::navigation::RoutePos::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::initLeavePosB() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptLeavePosB(
    ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> RouteGuidance::Builder::disownLeavePosB() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::uint16_t RouteGuidance::Reader::getActionLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getActionLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setActionLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getTunnelLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getTunnelLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setTunnelLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool RouteGuidance::Reader::getHasCloseTurn() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool RouteGuidance::Builder::getHasCloseTurn() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setHasCloseTurn(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getCloseIntersectionType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getCloseIntersectionType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setCloseIntersectionType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getCloseIntersectionLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getCloseIntersectionLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setCloseIntersectionLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline bool RouteGuidance::Reader::hasCloseIntersectionPos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasCloseIntersectionPos() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::RoutePos::Reader RouteGuidance::Reader::getCloseIntersectionPos() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::getCloseIntersectionPos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::RoutePos::Pipeline RouteGuidance::Pipeline::getCloseIntersectionPos() {
  return  ::senseAD::msg::navigation::RoutePos::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setCloseIntersectionPos( ::senseAD::msg::navigation::RoutePos::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::RoutePos::Builder RouteGuidance::Builder::initCloseIntersectionPos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptCloseIntersectionPos(
    ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> RouteGuidance::Builder::disownCloseIntersectionPos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline  ::uint16_t RouteGuidance::Reader::getNextSegmentLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getNextSegmentLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setNextSegmentLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t RouteGuidance::Reader::getLimitSpeedKmph() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getLimitSpeedKmph() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setLimitSpeedKmph( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline bool RouteGuidance::Reader::hasHighwayEntranceInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasHighwayEntranceInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::EntExitInfo::Reader RouteGuidance::Reader::getHighwayEntranceInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::EntExitInfo::Builder RouteGuidance::Builder::getHighwayEntranceInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::EntExitInfo::Pipeline RouteGuidance::Pipeline::getHighwayEntranceInfo() {
  return  ::senseAD::msg::navigation::EntExitInfo::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setHighwayEntranceInfo( ::senseAD::msg::navigation::EntExitInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::EntExitInfo::Builder RouteGuidance::Builder::initHighwayEntranceInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptHighwayEntranceInfo(
    ::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo> RouteGuidance::Builder::disownHighwayEntranceInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool RouteGuidance::Reader::hasHighwayExitInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasHighwayExitInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::EntExitInfo::Reader RouteGuidance::Reader::getHighwayExitInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::EntExitInfo::Builder RouteGuidance::Builder::getHighwayExitInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::EntExitInfo::Pipeline RouteGuidance::Pipeline::getHighwayExitInfo() {
  return  ::senseAD::msg::navigation::EntExitInfo::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setHighwayExitInfo( ::senseAD::msg::navigation::EntExitInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::EntExitInfo::Builder RouteGuidance::Builder::initHighwayExitInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptHighwayExitInfo(
    ::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::EntExitInfo> RouteGuidance::Builder::disownHighwayExitInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::EntExitInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool RouteGuidance::Reader::hasIntersectionLaneInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool RouteGuidance::Builder::hasIntersectionLaneInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::LaneInfo::Reader RouteGuidance::Reader::getIntersectionLaneInfo() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::LaneInfo>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::LaneInfo::Builder RouteGuidance::Builder::getIntersectionLaneInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::LaneInfo>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::LaneInfo::Pipeline RouteGuidance::Pipeline::getIntersectionLaneInfo() {
  return  ::senseAD::msg::navigation::LaneInfo::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void RouteGuidance::Builder::setIntersectionLaneInfo( ::senseAD::msg::navigation::LaneInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::LaneInfo>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::LaneInfo::Builder RouteGuidance::Builder::initIntersectionLaneInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::LaneInfo>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void RouteGuidance::Builder::adoptIntersectionLaneInfo(
    ::capnp::Orphan< ::senseAD::msg::navigation::LaneInfo>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::LaneInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::LaneInfo> RouteGuidance::Builder::disownIntersectionLaneInfo() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::LaneInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline  ::uint16_t RouteGuidance::Reader::getCurSegmentIndex() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t RouteGuidance::Builder::getCurSegmentIndex() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void RouteGuidance::Builder::setCurSegmentIndex( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t EntExitInfo::Reader::getId() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t EntExitInfo::Builder::getId() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void EntExitInfo::Builder::setId( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool EntExitInfo::Reader::hasRoutePos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool EntExitInfo::Builder::hasRoutePos() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::RoutePos::Reader EntExitInfo::Reader::getRoutePos() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::RoutePos::Builder EntExitInfo::Builder::getRoutePos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::RoutePos::Pipeline EntExitInfo::Pipeline::getRoutePos() {
  return  ::senseAD::msg::navigation::RoutePos::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void EntExitInfo::Builder::setRoutePos( ::senseAD::msg::navigation::RoutePos::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::RoutePos::Builder EntExitInfo::Builder::initRoutePos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void EntExitInfo::Builder::adoptRoutePos(
    ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> EntExitInfo::Builder::disownRoutePos() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool EntExitInfo::Reader::hasNameInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool EntExitInfo::Builder::hasNameInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader EntExitInfo::Reader::getNameInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder EntExitInfo::Builder::getNameInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void EntExitInfo::Builder::setNameInfo( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder EntExitInfo::Builder::initNameInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void EntExitInfo::Builder::adoptNameInfo(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> EntExitInfo::Builder::disownNameInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LaneInfo::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneInfo::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader LaneInfo::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder LaneInfo::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline LaneInfo::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LaneInfo::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder LaneInfo::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneInfo::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> LaneInfo::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LaneInfo::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LaneInfo::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::RoutePos::Reader LaneInfo::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::RoutePos::Builder LaneInfo::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::RoutePos::Pipeline LaneInfo::Pipeline::getPosition() {
  return  ::senseAD::msg::navigation::RoutePos::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void LaneInfo::Builder::setPosition( ::senseAD::msg::navigation::RoutePos::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::RoutePos::Builder LaneInfo::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LaneInfo::Builder::adoptPosition(
    ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::RoutePos> LaneInfo::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::RoutePos>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t LaneInfo::Reader::getDistanceToRouteEnd() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t LaneInfo::Builder::getDistanceToRouteEnd() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LaneInfo::Builder::setDistanceToRouteEnd( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool LaneInfo::Reader::hasLanesData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LaneInfo::Builder::hasLanesData() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Reader LaneInfo::Reader::getLanesData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Builder LaneInfo::Builder::getLanesData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LaneInfo::Builder::setLanesData( ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>::Builder LaneInfo::Builder::initLanesData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LaneInfo::Builder::adoptLanesData(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>> LaneInfo::Builder::disownLanesData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::LaneData,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LaneInfo::Reader::hasRecommendLanes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LaneInfo::Builder::hasRecommendLanes() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LaneInfo::Reader::getRecommendLanes() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LaneInfo::Builder::getRecommendLanes() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LaneInfo::Builder::setRecommendLanes( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LaneInfo::Builder::initRecommendLanes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void LaneInfo::Builder::adoptRecommendLanes(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LaneInfo::Builder::disownRecommendLanes() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint8_t LaneInfo::Reader::getLaneNumLeft() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneInfo::Builder::getLaneNumLeft() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LaneInfo::Builder::setLaneNumLeft( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LaneInfo::Reader::getLaneNumRight() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LaneInfo::Builder::getLaneNumRight() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void LaneInfo::Builder::setLaneNumRight( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool LaneInfo::Reader::getIsValidLaneInfo() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool LaneInfo::Builder::getIsValidLaneInfo() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void LaneInfo::Builder::setIsValidLaneInfo(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t RoutePos::Reader::getCoorStart() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t RoutePos::Builder::getCoorStart() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RoutePos::Builder::setCoorStart( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double RoutePos::Reader::getLongitude() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double RoutePos::Builder::getLongitude() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RoutePos::Builder::setLongitude(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double RoutePos::Reader::getLatitude() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double RoutePos::Builder::getLatitude() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RoutePos::Builder::setLatitude(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float RoutePos::Reader::getAltitude() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float RoutePos::Builder::getAltitude() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RoutePos::Builder::setAltitude(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LaneData::Reader::hasLaneFlag() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LaneData::Builder::hasLaneFlag() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LaneData::Reader::getLaneFlag() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LaneData::Builder::getLaneFlag() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LaneData::Builder::setLaneFlag( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LaneData::Builder::initLaneFlag(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LaneData::Builder::adoptLaneFlag(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LaneData::Builder::disownLaneFlag() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LaneData::Reader::hasLaneArrow() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LaneData::Builder::hasLaneArrow() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LaneData::Reader::getLaneArrow() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LaneData::Builder::getLaneArrow() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LaneData::Builder::setLaneArrow( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LaneData::Builder::initLaneArrow(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LaneData::Builder::adoptLaneArrow(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LaneData::Builder::disownLaneArrow() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LaneData::Reader::hasLaneProperty() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LaneData::Builder::hasLaneProperty() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LaneData::Reader::getLaneProperty() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LaneData::Builder::getLaneProperty() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LaneData::Builder::setLaneProperty( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LaneData::Builder::initLaneProperty(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LaneData::Builder::adoptLaneProperty(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LaneData::Builder::disownLaneProperty() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TrafficLight::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader TrafficLight::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder TrafficLight::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline TrafficLight::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TrafficLight::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder TrafficLight::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> TrafficLight::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TrafficLight::Reader::hasMultiLightInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TrafficLight::Builder::hasMultiLightInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Reader TrafficLight::Reader::getMultiLightInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Builder TrafficLight::Builder::getMultiLightInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TrafficLight::Builder::setMultiLightInfo( ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>::Builder TrafficLight::Builder::initMultiLightInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TrafficLight::Builder::adoptMultiLightInfo(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>> TrafficLight::Builder::disownMultiLightInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::MultiLightBubbleInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MultiLightBubbleInfo::Reader::hasPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MultiLightBubbleInfo::Builder::hasPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::navigation::GeoCoordinateZ::Reader MultiLightBubbleInfo::Reader::getPoint() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::GeoCoordinateZ>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::navigation::GeoCoordinateZ::Builder MultiLightBubbleInfo::Builder::getPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::GeoCoordinateZ>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::navigation::GeoCoordinateZ::Pipeline MultiLightBubbleInfo::Pipeline::getPoint() {
  return  ::senseAD::msg::navigation::GeoCoordinateZ::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MultiLightBubbleInfo::Builder::setPoint( ::senseAD::msg::navigation::GeoCoordinateZ::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::GeoCoordinateZ>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::navigation::GeoCoordinateZ::Builder MultiLightBubbleInfo::Builder::initPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::GeoCoordinateZ>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MultiLightBubbleInfo::Builder::adoptPoint(
    ::capnp::Orphan< ::senseAD::msg::navigation::GeoCoordinateZ>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::GeoCoordinateZ>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::navigation::GeoCoordinateZ> MultiLightBubbleInfo::Builder::disownPoint() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::navigation::GeoCoordinateZ>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MultiLightBubbleInfo::Reader::hasLightInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MultiLightBubbleInfo::Builder::hasLightInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Reader MultiLightBubbleInfo::Reader::getLightInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Builder MultiLightBubbleInfo::Builder::getLightInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MultiLightBubbleInfo::Builder::setLightInfo( ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>::Builder MultiLightBubbleInfo::Builder::initLightInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void MultiLightBubbleInfo::Builder::adoptLightInfo(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>> MultiLightBubbleInfo::Builder::disownLightInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::OneLight,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t OneLight::Reader::getLightType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t OneLight::Builder::getLightType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OneLight::Builder::setLightType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t OneLight::Reader::getTurnArrowType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t OneLight::Builder::getTurnArrowType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void OneLight::Builder::setTurnArrowType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t OneLight::Reader::getRemainTime() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t OneLight::Builder::getRemainTime() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void OneLight::Builder::setRemainTime( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t OneLight::Reader::getTotalTime() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t OneLight::Builder::getTotalTime() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void OneLight::Builder::setTotalTime( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double GeoCoordinateZ::Reader::getLongitude() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double GeoCoordinateZ::Builder::getLongitude() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GeoCoordinateZ::Builder::setLongitude(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double GeoCoordinateZ::Reader::getLatitude() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double GeoCoordinateZ::Builder::getLatitude() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GeoCoordinateZ::Builder::setLatitude(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float GeoCoordinateZ::Reader::getAltitude() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float GeoCoordinateZ::Builder::getAltitude() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void GeoCoordinateZ::Builder::setAltitude(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool SpeedLimit::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SpeedLimit::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader SpeedLimit::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder SpeedLimit::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline SpeedLimit::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SpeedLimit::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder SpeedLimit::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SpeedLimit::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> SpeedLimit::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t SpeedLimit::Reader::getLimitSpeedKmph() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t SpeedLimit::Builder::getLimitSpeedKmph() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SpeedLimit::Builder::setLimitSpeedKmph( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t SpeedLimit::Reader::getSpeedLimit() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t SpeedLimit::Builder::getSpeedLimit() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SpeedLimit::Builder::setSpeedLimit( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t SpeedLimit::Reader::getAverageSpeedKmph() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t SpeedLimit::Builder::getAverageSpeedKmph() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void SpeedLimit::Builder::setAverageSpeedKmph( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t SpeedLimit::Reader::getRemainLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t SpeedLimit::Builder::getRemainLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void SpeedLimit::Builder::setRemainLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t NaviSegment::Reader::getIntersectionType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t NaviSegment::Builder::getIntersectionType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NaviSegment::Builder::setIntersectionType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t NaviSegment::Reader::getSegmentLength() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t NaviSegment::Builder::getSegmentLength() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NaviSegment::Builder::setSegmentLength( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool NaviSegmentList::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool NaviSegmentList::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader NaviSegmentList::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder NaviSegmentList::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline NaviSegmentList::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void NaviSegmentList::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder NaviSegmentList::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void NaviSegmentList::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> NaviSegmentList::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool NaviSegmentList::Reader::hasSegmentList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool NaviSegmentList::Builder::hasSegmentList() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Reader NaviSegmentList::Reader::getSegmentList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Builder NaviSegmentList::Builder::getSegmentList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void NaviSegmentList::Builder::setSegmentList( ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>::Builder NaviSegmentList::Builder::initSegmentList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void NaviSegmentList::Builder::adoptSegmentList(
    ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>> NaviSegmentList::Builder::disownSegmentList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::senseAD::msg::navigation::NaviSegment,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TTSInfo::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TTSInfo::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::senseAD::msg::std_msgs::Header::Reader TTSInfo::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::senseAD::msg::std_msgs::Header::Builder TTSInfo::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::senseAD::msg::std_msgs::Header::Pipeline TTSInfo::Pipeline::getHeader() {
  return  ::senseAD::msg::std_msgs::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TTSInfo::Builder::setHeader( ::senseAD::msg::std_msgs::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::senseAD::msg::std_msgs::Header::Builder TTSInfo::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TTSInfo::Builder::adoptHeader(
    ::capnp::Orphan< ::senseAD::msg::std_msgs::Header>&& value) {
  ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::senseAD::msg::std_msgs::Header> TTSInfo::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::senseAD::msg::std_msgs::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t TTSInfo::Reader::getTtsType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TTSInfo::Builder::getTtsType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TTSInfo::Builder::setTtsType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TTSInfo::Reader::getTtsSubType() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TTSInfo::Builder::getTtsSubType() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TTSInfo::Builder::setTtsSubType( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TTSInfo::Reader::hasTtsVoiceText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TTSInfo::Builder::hasTtsVoiceText() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TTSInfo::Reader::getTtsVoiceText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TTSInfo::Builder::getTtsVoiceText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TTSInfo::Builder::setTtsVoiceText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TTSInfo::Builder::initTtsVoiceText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TTSInfo::Builder::adoptTtsVoiceText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TTSInfo::Builder::disownTtsVoiceText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

